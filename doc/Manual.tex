\NeedsTeXFormat{LaTeX2e}
\documentclass[twoside,titlepage]{article}
\usepackage{times,alltt,url,a4,amsmath}
\usepackage{pst-node}
\usepackage[dvips=true,a4paper=true,bookmarks=true,bookmarksopen=true,
pdfstartview=FitBH,pdfpagemode=UseOutlines,colorlinks=true,urlcolor=black,
citecolor=black,linkcolor=black,menucolor=black]{hyperref}

\setlength{\parskip}{1.5ex}
\setlength{\parindent}{0mm}

\newcommand{\void}[1]{}
\newcommand{\finto}{\ensuremath{\xrightarrow{\text{fin}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
\begin{center}

\vspace*{5cm}
{\Huge HaMLet S} \\
\vspace{5mm}
{\large\it To Become Or Not To Become Successor ML {\tt:-)}} \\
\vspace{1cm}
% {\Large\sc Manual} \\

\vspace{1cm}
Version 1.3.2/S6 \\
2025/07/27

\vspace{3cm}
\large
Andreas Rossberg \\
Universit\"at des Saarlandes \\
\url{rossberg@ps.uni-sb.de}

\end{center}
\end{titlepage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{
\setlength{\parskip}{0.5ex}
\tableofcontents
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vfill
\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{intro}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

HaMLet is an implementation of Standard ML (SML'97), as defined in {\it The Definition of Standard ML} \cite{definition} -- simply referred to as the {\em Definition} in the following text. HaMLet mainly is an interactive interpreter but also provides several alternative ways of operation. Moreover, HaMLet can perform different phases of execution -- like parsing, type checking, and evaluation -- selectively. In particular, it is possible to execute programs in an untyped manner, thus exploring the space where ``programs can go wrong''.

This special version of HaMLet is devoted to {\em Successor ML} \cite{successorml}, an envisioned evolutionary, conservative successor to Standard ML. It incorporates a number of preliminary proposals made for Successor ML and represents a personal vision of where SML could go. Currently, it concentrates on the following features:

\begin{itemize}\setlength{\itemsep}{0em}
\item Extensible records.
\item More expressive pattern matching.
\item Views.
\item Higher-order modules and nested signatures.
\item Local and first-class modules.
\item Miscellaneous fixes to known issues with SML and its specification.
\end{itemize}

See Appendix \ref{extensions} for a detailed description of all changes relative to Standard ML.
\void{
In the future, I would very much like to incorporate the following:

\begin{itemize}\setlength{\itemsep}{0em}
\item Higher-order and first-class polymorphism.
\item Type classes.
\item More expressive signature composition.
\end{itemize}
}


\subsection{Goals}
\label{goals}

The primary purpose of HaMLet is not to provide yet another SML system. Its goal is to provide a faithful model implementation and a test bed for experimentation with the SML language semantics as specified in the Definition. It also might serve educational purposes. The main feature of HaMLet therefore is the design of its source code: it follows the formalisation of the Definition as closely as possible, only deviating where it is unavoidable. The idea has been to try to translate the Definition into an ``executable specification''. Much care has been taken to resemble names, operations, and rule structure used in the Definition and the {\em Commentary} \cite{commentary}. Moreover, the source code contains references to the corresponding sections in the Definition wherever available.

On the other hand, HaMLet tries hard to get even the obscure details of the Definition right. There are some ``features'' of SML that are artefacts of its formal specification and are not straight-forward to implement. See the conclusion in Section \ref{conclusion} for an overview.

Some time ago, a loose for evolving SML has been started. For political reasons, the subject of this effort has been nicknamed {\em Successor ML} (sML) \cite{successorml}. This special version of HaMLet is a testbed for potential changes and extensions considered for Successor ML and incorporates a number of simple proposals. Appendix \ref{extensions} gives a complete list of these proposals and their specification.

Efficiency was not a goal. Execution speed of HaMLet is not competitive in any way, since it naively implements the interpretative evaluation rules from the Definition. Comfort was no priority either. The error messages given by HaMLet are usually taciturn as we tried to avoid complicating the implementation.

HaMLet has of course been written entirely in SML'97 and is able to bootstrap itself (see \ref{bootstrapping}).


\subsection{Bugs in the Definition}
\label{definitionbugsoverview}

The Definition is a complex formal piece of work, and so it is unavoidable that it contains several mistakes, ambiguities, and omissions. Many of these are inherited from the previous language version SML'90 \cite{definition90} and have been documented accurately by Kahrs \cite{mistakes, addenda}. Those, which still seem to be present or are new to SML'97, are listed in appendix \ref{definitionbugs}.

Most of the problems have been fixed in this version as part of the proposals for Successor ML, see especially Appendices \ref{ext-syntaxfixes} and \ref{ext-semanticfixes}.
The general approach we take for resolving remaining ambiguities and fixing bugs is doing it in the `most natural' way. Mostly, this is obvious, sometimes it is not.\void{ Moreover, in cases where the Definition allows implementations some freedom (e.g.\ the choice of context taken into account to resolve overloading) we choose the most restrictive view, so that HaMLet only accepts those programs that ought to be portable across all possible implementations.} The appendix discusses the solutions we chose.


\subsection{Related Work}
\label{related}

HaMLet owes much of its existence to the first version of the ML Kit \cite{kit}. While the original Kit shared a similar motivation and a lot of inspiration came from that work, more recent versions moved the Kit into another direction. We hope that HaMLet is suitable to fill the resulting gap.

We also believe that HaMLet is considerably simpler and closer to the Definition. Moreover, unlike the ML Kit, it also implements the dynamic semantics of SML directly.
On the other hand, HaMLet is probably less suited to serve as a library for real world projects, since no part of it has been tuned for efficiency in any way.


\subsection{Copyright}
\label{copyright}

Copyright of the HaMLet sources 1999-2007 by Andreas Rossberg.

The HaMLet source package includes portions of the SML/NJ library, which is copyright 1989-1998 by Lucent Technologies.

See {\tt LICENSE.txt} files for detailed copyright notices, licenses and disclaimers.

HaMLet is free, and we would be happy if others experiment with it. Feel free to modify the sources in whatever way you want.

Please post any questions, bug reports, critiques, and other comments to

\begin{quote}
\url{rossberg@ps.uni-sb.de}
\end{quote}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Usage}
\label{usage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Download}
\label{download}

HaMLet is available from the following web page:

\begin{quote}
\url{http://www.ps.uni-sb.de/hamlet/}
\end{quote}

The distribution contains a tar ball of the SML sources and this documentation.


\subsection{Systems Supported}
\label{systems}

HaMLet can be readily built with the following SML systems:%\footnote{This version of HaMLet fails to compile on Moscow ML \cite{mosml}, because it fails to correctly parse multiple {\tt where type} annotations. Since the alternative {\tt and type} syntax has been removed in this version, keeping it in the sources would prevent HaMLet from bootstrapping.}

\begin{itemize}
\setlength{\parskip}{0ex}
\item SML of New Jersey (110 or higher) \cite{smlnj}
\item Poly/ML (5.0 or higher) \cite{polyml}
\item Moscow ML (2.0 or higher) \cite{mosml}
\item Alice ML (1.4 or higher) \cite{alice}
\item MLton (20010706 or higher) \cite{mlton}
\item ML Kit (4.3.0 or higher)\footnote{Unfortunately, the ML Kit seems to hang itself compiling the parser module of the current version of HaMLet-S.} \cite{mlkit}
\item SML\# (0.20 or higher)\footnote{Hamlet on SML\# currently works with some glitches only, e.g.\ the interactive prompt does appear out of sync.} \cite{smlsharp}
\end{itemize}

You can produce an executable HaMLet standalone with all systems. The first four also allow you to use HaMLet from within their interactive toplevel. This gives access to a slightly richer interface (see Section \ref{usingembedded}).

Other SML systems have not been tested, but should of course work fine provided they support the full language and a reasonable subset of the Standard Basis Library \cite{basis}.


\subsection{Libraries and Tools Used}
\label{usedtools}

HaMLet makes use of the Standard ML Basis Library \cite{basis}\footnote{Despite some incompatible changes between the two, HaMLet sources work with the latest specification of the Basis \cite{basis} as well as the previously available version \cite{basis-old}.}. In addition it uses two functors from the SML/NJ library \cite{njlib}, namely {\tt BinarySetFn} and {\tt BinaryMapFn}, to implement finite sets and maps.

To generate lexer and parser, ML-Lex \cite{mllex} and ML-Yacc \cite{mlyacc} have been used. The distribution contains all generated files, though, so you only have to install those tools if you plan to modify the grammar.

The SML/NJ library as well as ML-Lex and ML-Yacc are freely available as part of the SML of New Jersey distribution. However, the HaMLet distribution contains all necessary files from the SML/NJ library and the ML-Yacc runtime library. They can be found in the {\tt smlnj-lib} subdirectory, respectively.\footnote{The sources of the SML/NJ library are copyrighted \copyright1989-1998 by Lucent Technologies. See \url{http://cm.bell-labs.com/cm/cs/what/smlnj/license.html} for copyright notice, license and disclaimer.}


\subsection{Installation}
\label{installationstandalone}

To build a stand-alone HaMLet program\void{ under Unix-like systems}, go to the HaMLet source directory and invoke one of the following commands:\footnote{Under DOS-based systems, Cygwin is required.}

\begin{quote}
\begin{alltt}
make with-smlnj
make with-mlton
make with-poly
make with-mosml
make with-alice
make with-mlkit
make with-smlsharp
\end{alltt}
\end{quote}

depending on what SML system you want to compile with. This will produce an executable named {\tt hamlet} in the same directory, which can be used as described in Section \ref{usingstandalone}.\footnote{Due to a bug in Moscow ML, which does not parse SML's {\tt where} {\tt type} syntax correctly, you first have to run ``{\tt{make}} {\tt{mosmlize}}'' to patch the sources appropriately. Unfortunately, Hamlet will no longer be able to bootstrap from the patched sources, due to the language change described in Appendix \ref{ext-realisation}. By running ``{\tt{make}} {\tt{unmosmlize}}'' you can convert the sources back to their original form.}

\void{
To compile under DOS-based systems you\void{ can either use the simple-minded {\tt make.bat} batch file that is included in the HaMLet distribution and fakes the commands above, or you} have to install some `make' substitute (e.g.\ via Cygwin) and modify the makefile according to the contained comments. \footnote{This does not properly work for Moscow ML currently.}
}

The above {\tt make} targets use the fastest method to build HaMLet from scratch. Most SML systems allow for incremental compilation that, after changes, only rebuilds those parts of the system that are affected. To perform an incremental built, use the following commands, respectively:\footnote{Currently, this only matters for Moscow ML and Alice ML, which employ batch compilers. The other systems either always build incrementally (SML/NJ, ML Kit), or do not support separate compilation at all (MLton, Poly/ML).}

\begin{quote}
\begin{alltt}
make with-smlnj+
make with-alice+
make with-mosml+
make with-mlkit+
\end{alltt}
\end{quote}

For other SML systems that are not directly supported, the makefile offers a way to build a single file containing all of the HaMLet modules:

\begin{quote}
\begin{alltt}
make hamlet-monolith.sml
\end{alltt}
\end{quote}

In principle, the resulting file should compile on all SML systems. In practice however, some might require additional tweaks to work around omissions or bugs in the provided implementation of the Standard Basis Library \cite{basis}.\footnote{Of the systems supported, SML/NJ, Moscow ML and the ML Kit required such work-arounds, which appear as wrapper files for Standard Basis modules in the {\tt fix} directory of the HaMLet source.}

After HaMLet has been built, you should be able to execute it as described in \ref{usingstandalone}. Under Unixes, you have the option of installing HaMLet first:

\begin{quote}
\begin{alltt}
make INSTALLDIR=mypath install
\end{alltt}
\end{quote}

The default for {\tt mypath} is {\tt /usr/local/hamlet}. You should include your path in the {\tt PATH} environment variable, of course.


\subsection{Using the HaMLet Stand-Alone}
\label{usingstandalone}

After building HaMLet successfully with one of the SML systems, you should be able to start a HaMLet session by simply executing the command

\begin{quote}
\begin{alltt}
hamlet [-{\it{mode}}] [{\it file} ...]
\end{alltt}
\end{quote}

The {\tt\it mode} option you can provide, controls how HaMLet processes its input. It is one of

\begin{itemize}
\setlength{\parskip}{0ex}
\item {\tt -p}: parsing mode (only parse input)
\item {\tt -l}: elaboration mode (parse and elaborate input)
\item {\tt -v}: evaluation mode (parse and evaluate input)
\item {\tt -x}: execution mode (parse, elaborate, and evaluate input)
\end{itemize}

Execution mode is the default behaviour. Parsing mode will output the abstract syntax tree of the program in an intuitive S-expression format that should be suitable for further processing by external tools. Elaboration mode only type-checks the program, without running it.

Evaluation mode does not perform static analysis, so it can actually generate runtime type errors. They will be properly handled and result in corresponding error messages. Evaluation mode also has an unavoidable minor glitch with regard to overloaded constants: since no type information is available in evaluation mode, all constants will be assigned the default type. This can cause different results for some calculations. To see this, consider the following example:

\begin{quote}
\begin{alltt}
0w1 div (0w2 * 0w128)                {\rm and}
0w1 div (0w2 * 0w128) : Word8.word
\end{alltt}
\end{quote}
Although both variants only differ in an added type annotation, the latter will have a completely different result -- namely cause a division by zero and thus a {\tt Div} exception (see also appendix \ref{bugsappendixe}). You can still force calculation to be performed in 8 bit words by performing explicit conversions:
\begin{quote}
\begin{alltt}
val word8 = Word8.fromLarge;
word8 0w1 div (word8 0w2 * word8 0w128);
\end{alltt}
\end{quote}
Note that {\tt LargeWord.word} = {\tt word} in HaMLet.

If no file argument has been given you will enter an interactive session in the requested mode, just like in other SML systems. Input may spread multiple lines and is terminated by either an empty line, or a line whose last character is a semicolon. Aborting the session via Ctrl-D will exit HaMLet (end of file, Ctrl-Z on DOS-based systems).

Otherwise, all files are processed in order of appearance. HaMLet interprets the Definition very strictly and thus requires every source file to be terminated by a semicolon. A file name may be prefixed by {\tt@} in which case it is taken to be an indirection file containing a white space separated list of other file names and expands to that list. Expansion is done recursively, i.e.\ the file may contain {\tt@}-prefixed indirections on its own.

HaMLet currently provides a considerable part, but not yet the complete obligatory subset of the Standard Basis Library \cite{basis}. In particular, support for OS functionality still is weak. Most basic types and corresponding operations are fully implemented, though.

There are several things to note about HaMLet's output:

\begin{itemize}
\item Types and signatures are always fully expanded, in order to closely resemble the underlying semantic objects.
\item Similarly, structure values are shown in full expansion.
\item Signatures are annotated with the set of type names bound (as a comment).
\item Similarly, the type name set of an inferred static basis is printed, though only elaboration mode.
%\item Undetermined types (see \ref{bugsappendixg}) are reported in the form {\tt '2341} or {\tt ''2341}, depending on their inferred equality constraints. The number is a unique identifier for each type.
\end{itemize}

% The output contains more information than usually printed by SML systems:
%
% \begin{itemize}
% \item Type constructors are annotated with their type name.
% \item Signatures show the set of type names bound.
% \item In elaboration mode the set of type names generated by the declarations is displayed.
% \item Exception packages (raised exceptions) are annotated with their exception name.
% \end{itemize}
%
% Type and exception names are represented as numbers.


\subsection{Using HaMLet from within an SML System}
\label{usingembedded}

You can also use HaMLet from within the interactive toplevel of a given SML system. This allows you to access the various modules described in the following sections of this document directly and experiment with them.

In most interactive SML systems -- particularly HaMLet itself, see \ref{bootstrapping} -- you should be able to load the HaMLet modules by evaluating

\begin{quote}
\begin{alltt}
use "hamlet.sml";
\end{alltt}
\end{quote}

As this requires recompiling everything, there are more comfortable ways for some particular systems:

\begin{itemize}

\item Under SML of New Jersey, it suffices to start SML/NJ in the HaMLet directory and evaluate

\begin{quote}
\begin{alltt}
CM.make();
\end{alltt}
\end{quote}

However, under newer versions of SML/NJ (110.20 and later), you need to invoke the function as follows:

\begin{quote}
\begin{alltt}
CM.make "sources.cm";
\end{alltt}
\end{quote}

\item Under Moscow ML, first go to the HaMLet directory and invoke

\begin{quote}
\begin{alltt}
make interactive-mosml
\end{alltt}
\end{quote}

Then start Moscow ML and type

\begin{quote}
\begin{alltt}
load "Sml";
\end{alltt}
\end{quote}

\end{itemize}

Loading HaMLet into an SML session will create (besides others) a structure named {\tt Sml}, providing the following signature:

\begin{quote}
\begin{alltt}
signature SML =
sig
    val parseString :  string -> unit
    val elabString :   string -> unit
    val evalString :   string -> unit
    val execString :   string -> unit

    val parseFile :    string -> unit
    val elabFile :     string -> unit
    val evalFile :     string -> unit
    val execFile :     string -> unit

    val parseFiles :   string list -> unit
    val elabFiles :    string list -> unit
    val evalFiles :    string list -> unit
    val execFiles :    string list -> unit

    val parseSession : unit -> unit
    val elabSession :  unit -> unit
    val evalSession :  unit -> unit
    val execSession :  unit -> unit
end
\end{alltt}
\end{quote}

The functions here come in four obvious groups:

\begin{itemize}
\setlength{\parskip}{0ex}
\item {\tt{\sl x}String} processes a program contained in the string given.
\item {\tt{\sl x}File} processes a program contained in a file whose name is given.
\item {\tt{\sl x}Files} processes a whole set of files in an incremental manner.
\item {\tt{\sl x}Session} starts an interactive session, that can be exited by pressing Ctrl-D (end of file, Ctrl-Z on DOS-based systems).
\end{itemize}

Each call processes the program in the initial basis. For incremental processing, functions from the {\tt{\sl x}Files} or {\tt{\sl x}Session} group have to be used.

In each group there are four functions providing selective phases of execution:

\begin{itemize}
\setlength{\parskip}{0ex}
\item {\tt parse{\sl{X}}} just parses a program.
\item {\tt elab{\sl{X}}} parses and elaborates a program.
\item {\tt eval{\sl{X}}} parses and evaluates a program.
\item {\tt exec{\sl{X}}} parses, elaborates, and evaluates a program.
\end{itemize}

These functions correspond to the different execution modes of the stand-alone HaMLet (see Section \ref{usingstandalone}). They all print the resulting environments on {\tt stdOut}, or a suitable error message on {\tt stdErr} if processing does not succeed (parse functions just print {\tt OK} on success). During processing of a file list or an interactive session, errors cause the current input to be skipped, but not abortion of the session.


\subsection{Bootstrapping}
\label{bootstrapping}

Since HaMLet has been written purely in strict SML'97, it is able to bootstrap itself. The file {\tt hamlet.sml} provided in the source directory allows bootstrapping an interactive HaMLet session by starting the HaMLet stand-alone via

\begin{quote}
\begin{alltt}
hamlet hamlet.sml wrap-hamlet.sml
\end{alltt}
\end{quote}

Alternatively, the file can be {\tt use}'d from within a HaMLet session. It will load all necessary modules enabling interactive use as described in \ref{usingembedded}.

Beware that loading the full Basis Library in the bootstrapped version will require a huge amount of virtual memory. If you are brave and have {\em lots} of memory and patience you can even try a second bootstrapping iteration from within a session on the bootstrapped HaMLet. Then, HaMLet not only type-checks itself but does also execute the type checker and evaluator itself. You should expect at least two orders of magnitude slowdown for each bootstrapping iteration, due to the naive interpretative evaluation\footnote{For example, on a 2 GHz processor with 512 MB memory the second iteration may take about 4 hours.} (see Section \ref{evaluation}).


\subsection{Limitations}
\label{limitations}

In its current version, HaMLet is not completely accurate with respect to some aspects of the SML language. The following list gives an overview of the issues remaining with Successor ML:

\begin{itemize}

\void{
\item Parsing: The grammar in the Definition together with its informal disambiguation rules is rather over-ambitious. It is not possible to parse it with finite look-ahead, as required by conventional parsing technology -- at least not without performing a major nightmare of grammar transformations first. Consequently, all existing SML implementations disallow some phrases that ought to be legal according to the Definition. The most obvious examples are mixtures of $\mathit{fvalbind}$s and {\tt case} expressions like in

\begin{quote}
\begin{alltt}
fun f p1 = case e1 of p2 => e2
  | f p3 = e3
\end{alltt}
\end{quote}

No effort has been made to get this working in HaMLet. However, HaMLet is still more accurate than other SML implementations. For example, it parses the dreaded {\tt where type} ... {\tt and type} derived form for signature expressions correctly (see Section \ref{ambiguities}).
}

\item Exhaustiveness of Patterns: checking of patterns is not fully accurate in the presence of overloaded special constants. Sometimes a match is flagged as non-exhaustive, although it is in the limited range of its actual type.

\item Library: HaMLet does provide a significant portion of the Standard Basis Library, but it is not complete.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview of the Implementation}
\label{implementationoverview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The implementation of HaMLet follows the Definition, ammended by the changes given in Appendix \ref{extensions}, as closely as possible. The idea was to come as close as possible to the ideal of an executable version of the Definition. Where the sources deviate, they usually do so for one of the following reasons:

\begin{itemize}
\setlength{\parskip}{0ex}
\item the non-deterministic nature of some of the rules (e.g.\ guessing the right types in the static semantics of the core),
\item the informal style of some parts (e.g.\ the restrictions in [4.11])
%\item practicality (e.g.\ it is much easier to check the syntactic restrictions in [2.9] and [3.5] during elaboration than during syntax analysis)
\item bugs or omissions in the Definition (see appendix \ref{definitionbugs})
\end{itemize}

We will explain non-trivial deviations from the Definition where appropriate.

The remainder of this document does not try to explain details of the Definition -- the Commentary \cite{commentary} is much better suited for this purpose, despite being based on the SML'90 Definition \cite{definition90}. Neither is this document a tutorial to type inference. The explanations given here merely describe the relation between the HaMLet source code and the formalism of the Definition. The text assumes that you have both at hand side by side. We use section numbers in brackets as above to refer to individual sections of the Definition. Unbracketed section numbers are cross references within this document.

Note that most explanations given here a kept rather terse and cover only general ideas without going into too much detail. The intention is that the source code speaks for itself for most part.


\subsection{Structure of the Definition}
\label{definitionstructure}

The Definition specifies four main aspects of the SML language:

\begin{enumerate}
\setlength{\parskip}{0ex}
\item Syntax
\item Static semantics
\item Dynamic semantics
\item Program Execution
\end{enumerate}

Syntax is the most conventional part of a language definition. The process of recognizing and checking program syntax is usually referred to as {\em parsing}. The static semantics is mainly concerned with the typing rules. The process of checking validity of a program with respect to the static semantics is called {\em elaboration} by the Definition. The dynamic semantics specifies how the actual {\em evaluation} of program phrases has to be performed. The last aspect essentially describes how the interactive toplevel of an SML system should work, i.e.\ how parsing, elaboration, and evaluation are connected. The complete processing of a program, performing all three aforementioned phases, is known as {\em execution}.

The four aspects are covered in separate chapters of the Definition. Further destructuring is done by distinguishing between core language and module language. This factorisation of the language specification is described in more detail in the preface and the first chapter of the Definition.

% Execution of a program is done relative to a so-called _basis_ that describes the context of the execution. Corresponding to the three phases of execution such a basis is divided into three parts:
%
% - infix basis
% - static basis
% - dynamic basis
%
% The static basis is used by the static semantics and contains type information for all identifiers that are predefined (or have been introduced by previous execution steps). The dynamic basis collects the values of all predefined entities, and corresponds to the dynamic semantics, respectively. The infix basis records the all infix directions in scope. It is not made explicit by the Definition, but is required for parsing in analogy to the other parts.


\subsection{Modularisation}
\label{modularisation}

HaMLet resembles the structure of the Definition quite directly. For most chapters of the Definition there is a corresponding module implementing that aspect of the language, namely these are:

\begin{quote}
\begin{tabbing}
Chapter 2 and 3\qquad\= {\tt Lexer}, {\tt Parser}, {\tt SyntacticRestrictions} \\
Chapter 4	\> {\tt ElabCore} \\
Chapter 5	\> {\tt ElabModule} \\
Chapter 6	\> {\tt EvalCore} \\
Chapter 7	\> {\tt EvalModule} \\
Chapter 8	\> {\tt Program} \\
Appendix A	\> {\tt DerivedForms} \\
Appendix B	\> {\tt Parser} \\
Appendix C	\> {\tt InitialStaticBasis} \\
Appendix D	\> {\tt InitialDynamicBasis} \\
Appendix E	\> {\tt OverloadingClass} (roughly)
\end{tabbing}
\end{quote}

Most other modules implement objects and operations defined at the beginning of each of the different chapters, which are used by the main modules. The source of every module cross-references the specific subsections of the Definition relevant for the types, operations, or rule implementations contained in it.

Altogether, it should be quite simple to map particular HaMLet modules to parts or entities of the Definition and vice versa. To make the mapping as obvious as possible, we followed quite strict naming conventions (see \ref{naming}). Each of the following sections of this document will cover implementation of one of the language aspects mentioned in \ref{definitionstructure}. At the beginning of each of those sections we will list all modules relevant to that part of the implementation.

As a rule, each source file contains exactly one signature, structure, or functor. The only exceptions are the files {\tt Ids{\sl{X}}}, {\tt Grammars{\sl{X}}}, each containing a collection of simple functor applications, and the files containing the modules {\tt Addr}, {\tt ExName}, {\tt Lab}, {\tt Stamp}, {\tt TyName}, {\tt TyVar}, which also provide implementations of sets and maps of the corresponding objects.

We tried to keep things simple, so the architecture of HaMLet is quite flat: it does not make heavy use of functors. Functors only appear where the need to generate several instances of an abstract type (e.g.\ {\tt IdFn}) or parameterised types arises. Enthusiasts of the closed functor style may feel free to dislike this approach {\tt ;-)}.


\subsection{Mapping Syntactic and Semantic Objects}
\label{mapping}

The sets representing the different phrase classes of the SML syntax are defined inductively through the BNF grammars in the Definition. These sets are mapped to appropriate SML datatypes in obvious ways, using fields of type {\tt option} for optional phrases.

All sets defining semantic objects in the Definition have been mapped to SML types as directly as possible:

\begin{quote}
\begin{tabbing}
primitive objects (without structure)\qquad\= abstract types \\
products ($A \times B$)			\> tuple types ({\tt A * B}) \\
disjoint unions ($A \cup B$)		\> datatypes ({\tt A of A | B of B}) \\
$k$-ary products ($\cup_{k\geq0} A^k$)	\> list types ({\tt A list}) \\
finite sets ($\mbox{Fin}(A)$)		\> instances of the {\tt FinSet} functor \\
finite maps ($A \stackrel{\mbox{\scriptsize fin}}{\rightarrow} B$)		\> instances of the {\tt FinMap} functor \\
\end{tabbing}
\end{quote}

In some places, we had to relax these conventions somewhat and turn some additional types into datatypes to cope with mutual recursion between definitions. For example, environments are always rendered as datatypes.

Except for the primitive simple objects, no type definitions are abstract. To allow the most direct implementation of rules operating on semantic objects, type definitions representing structured sets are always kept transparent. Be warned: regarding this aspect, the HaMLet sources should not serve as an example for good modularisation practice...


\subsection{Mapping Inference Rules}
\label{mappingrules}

Usually, each group of inference rules in the Definition is implemented by one function. For rules of the form

\begin{displaymath}
A \vdash \mathit{phrase} \Rightarrow A'
\end{displaymath}

the corresponding function has type

\begin{alltt}
\hfill A * phrase -> A' \hfill
\end{alltt}

Each individual rule corresponds to one function clause. More specifically, an inference rule of the form:

\begin{displaymath}
\frac{
A_1 \vdash \mathit{phrase}_1 \Rightarrow A'_1
\qquad
\cdots
\qquad
A_n \vdash \mathit{phrase}_n \Rightarrow A'_n
\qquad
\mbox{side condition}
}{
A \vdash \mathit{phrase} \Rightarrow A'
}
\qquad (k)
\end{displaymath}

maps to a function clause of the form:

\begin{quote}
\begin{alltt}
elabPhraseClass args (A, phrase) =
(* [Rule k] *)
let
    val A1' = elabPhraseClass1(A1, phrase1)
    (* ... *)
    val An' = elabPhraseClassN(An, phraseN)
in
    if side condition then
        A'
    else
        error("message")
end
\end{alltt}
\end{quote}

Here, {\tt args} denotes possible additional arguments that we sometimes need to pass around. There are exceptions to this scheme for rules that are not purely structural, e.g.\ rules 34 and 35 of the static semantics [4.10] are represented by one case only. Moreover, we deal slightly differently with the state and exception conventions in the dynamic semantics (see \ref{evaluationrules}).

If one of a rule's premise is not met, an appropriate message is usually generated and an exception is raised through the {\tt Error} module.


\subsection{Naming Conventions}
\label{naming}

Structures and functors are named after the main type they define, the objects they generate, or the aspects of the Definition they implement (with one exception: the structure containing type {\tt Int} is named {\tt Inter} to avoid conflicts with the structure {\tt Int} of the Standard Basis Library). The corresponding signatures are named accordingly.

Several structures come in groups, representing the separation of core and module language (and even the program layer). Orthogonal grouping happens for aspects similar in the static and dynamic semantics. The structure names reflect those connections in an obvious way, by including the words {\tt -Core-}, {\tt -Module-}, or {\tt -Program-}, and {\tt -Static-} or {\tt -Dynamic-}.

Types representing sets defined in the Definition are always named after that set even if this conflicts with the usual SML conventions with respect to capitalisation. Functions are also named after the corresponding operation if it is defined in the Definition or the Commentary \cite{commentary}. Variables are named as in the Definition, with Greek letters spelled out. Moreover, type definitions usually include a comment indicating how variables of that type will be named.

On all other occasions obvious names have been chosen, following conventions established by the Standard Basis Library \cite{basis} or the SML/NJ library \cite{njlib} where possible.


\subsection{Side Effects}
\label{sideeffects}

SML is not purely functional, and neither is the HaMLet implementation. It uses state whenever that is the most natural thing to do, or if it considerably simplifies code. At the following places state comes into play:

\begin{itemize}
\setlength{\parskip}{0ex}
\item inside the lexer, to handle nested comments,
\item inside the parser, to maintain the infix environment,
\item to generate time stamps, e.g.\ for type and exception names,
\item in the representation of type terms, to allow destructive unification,
\item during elaboration, to collect unresolved overloaded and flexible types,
\item during evaluation, to maintain the program's state,
\item to realise inter-module recursion on one occasion (see Section \ref{matching}).
\end{itemize}

And of course, the code generated by Lex and Yacc uses state internally.

Other side effects are the output of error and warning messages in the Error structure.


\subsection{Module-level Mutual Recursion}
\label{modulerecursion}

The addition of various module extensions (see Appendices \ref{ext-higherfunctors}--\ref{ext-firstclass}) introduces between the implementation of the core and the module language. Since SML does not support recursive modules, we either have to merge many conceptually separate concepts into a single module, or work around it. We chose the latter, using what can best be considered a hack:
\begin{itemize}
\item To break up inter-module type recursion, we abuse the exception type. In one structure, a the proper type is replaced by {\tt exn}, while the other structure defines the actual type and an appropriate exception constructor wrapping it.

\item On the value level inter-module recursion is always between functions. We use references to tie the recursive knot. One structure defines a reference as a placeholder for the actual function, and all calls are performed through the reference. The corresponding structure defining the proper function assigns this reference.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Syntax and Parsing}
\label{parsing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Files}
\label{parsingfiles}

The following modules are related to parsing and representation of the abstract syntax tree:

\begin{quote}
\begin{tabbing}
{\tt SyntacticRestrictionsProgram}\qquad \= \kill

{\tt Source}		\> representation of source regions \\
\\
{\tt IdFn}		\> generic identifier representation \\
{\tt LongIdFn}		\> \\
{\tt IdsCore}		\> instantiated identifier classes \\
{\tt IdsModule}		\> \\
{\tt TyVar}		\> type variable representation \\
{\tt Lab}		\> label representation \\
{\tt SCon}		\> special constants \\
\\
{\tt GrammarCoreFn}	\> abstract syntax tree definition \\
{\tt GrammarModuleFn}	\> \\
{\tt GrammarProgramFn}	\> \\
{\tt Grammars}		\> AST instantiations \\
\\
{\tt Lexer}		\> lexical analysis (via ML-Lex) \\
{\tt LineAwareLexer}	\> wrapper computing line/column information \\
{\tt Parser}		\> syntactical analysis (via ML-Yacc) \\
{\tt Infix}		\> infix parser \\
{\tt Parse}		\> parser plugging \\
\\
{\tt DerivedFormsCore}	\> derived forms transformation \\
{\tt DerivedFormsModule} \> \\
{\tt DerivedFormsProgram} \> \\
\\
{\tt IdStatus}		\> identifier status \\
{\tt BindingObjectsCore} \> objects for binding analysis \\
{\tt BindingObjectsModule} \> \\
{\tt GenericEnvFn}	\> generic environment operations \\
{\tt BindingEnv}	\> operations on binding environment \\
{\tt BindingContext}	\> operations on binding context \\
{\tt BindingBasis}	\> operations on binding basis \\
\\
{\tt ScopeTyVars}	\> scoping analysis for type variables\\
\\
{\tt SyntacticRestrictionsCore}	\> verifying syntactic restrictions \\
{\tt SyntacticRestrictionsModule} \> \\
{\tt SyntacticRestrictionsProgram} \> \\
\\
{\tt PPGrammar}		\> auxiliary functions for printing ASTs \\
{\tt PPCore}		\> printing of core AST \\
{\tt PPModule}		\> printing of module AST \\
{\tt PPProgram}		\> printing of program AST \\
\end{tabbing}
\end{quote}


\subsection{Abstract Syntax Tree}
\label{ast}

The abstract syntax tree (AST) is split into three layers, corresponding to the SML core and module language and the thin program toplevel, respectively (modules {\tt Grammar$X$Fn}). It represents the bare grammar, without derived forms. One notable exception has been made for structure sharing constraints, which are included since they cannot be handled as a purely syntactic derived form (see \ref{bugsappendixa}). Infix stuff has been removed from the core grammar, as it does not appear in the semantic rules of the Definition [2.6]. However, we have to keep occurrences of the {\tt op} keyword in order to do infix resolution (see \ref{infix}).

Each node carries a generic info field, and the grammar modules are functorised to allow different instantiations of this field. However, they are currently only instantiated once, with the info field carrying position information mapping each node to a region of the source text and an optional file name (file {\tt Grammars}).

Each identifier class is represented by its own abstract type. Most of them -- except {\tt TyVar} and {\tt Lab} which require special operations -- are generated from the {\tt IdFn} and {\tt LongIdFn} functors.

Special constants are represented as strings containing the essential part of their lexical appearance -- their actual values cannot be calculated before overloading resolution.


\subsection{Parsing and Lexing}
\label{parser}

Parser and lexer have been generated using ML-Yacc \cite{mlyacc} and ML-Lex \cite{mllex} which are part of the SML/NJ distribution \cite{smlnj}. The parser builds an abstract syntax tree using the grammar types described in Section \ref{ast}.

Most parts of the parser and lexer specifications (files {\tt Parser.grm} and {\tt Lexer.lex}) are straightforward. In particular, we use a rather dumb and direct way to recognize keywords in the lexer. We have to take some care to handle all those overlapping lexical classes correctly, which requires the introduction of some additional token classes (see comments in {\tt Lexer.lex}). Nested comments are treated through a side-effecting counter for nesting depth.

A substantial number of grammar transformations is unavoidable to deal with LALR conflicts in the original SML grammar (see \ref{ambiguities} and comments in {\tt Parser.grm}). Some hacking is necessary to do infix resolution directly during parsing (see \ref{infix}).

Semantic actions of the parser apply the appropriate constructors of the grammar types or a transformation function provided by the modules handling derived forms (see \ref{derived}).

%Note that syntactic restrictions are checked during elaboration. One reason is the fact that the restriction on binding an identifier multiple times in a $\mathit{valbind}$ requires identifier status information which is not available before doing a complete binding analysis (see \ref{bugschapter2}). To be consistent, we uniformingly defer all checks until elaboration.


\subsection{Grammar Ambiguities and Parsing Problems}
\label{ambiguities}

\void{
ML-Yacc is a conventional LALR(1) parser generator. However, the grammar given in the Definition together with its disambiguation rules defines a language that cannot be parsed by such standard parsing technology, as it requires infinite look-ahead. The HaMLet parser is therefore incapable of handling all language constructs that are legal according to a strict reading of the Definition. The most annoying example of a problematic phrase is a {\tt case} expression as right hand side of a function binding (see \ref{bugsappendixb}). Most people consider this a bug on the side of the Definition. Consequently, no attempt is currently made to fix it in HaMLet. It could only be dealt with correctly either by horrendous grammar transformations or by some really nasty and expensive lexer hack \cite{mistakes}. 

Disambiguation of expressions is left to ML-Yacc, we simply specify suitable keyword precedences. This seems to be the most appropriate thing to do, as the disambiguation rules in the Definition are ambiguous by themselves (see \ref{bugsappendixb}).
}

The SML grammar -- even with the changes given in Appendix \ref{ext-syntaxfixes} -- contains several other ambiguities on the declaration level (see \ref{bugschapter2}, \ref{bugschapter3} and \ref{bugschapter8}). We resolve them in the `most natural' ways. In particular, semicolons are simply parsed as declarations or specifications, not as separators (cf.\ \ref{bugschapter2}), and several auxiliary phrase classes have been introduced to implement these disambiguations.
Further grammar transformations are needed to cope with datatype declaration vs.\ datatype replication.


\subsection{Infix Resolution}
\label{infix}

Since ML-Yacc does not support attributes, and we did not want to introduce a separate infix resolution pass, the parser maintains an infix environment $J$ which is initialised and updated via side effects in the semantic actions of several pseudo productions. Applications -- infix or not -- are first parsed as lists of atomic symbols and then transformed by the module {\tt Infix} which is invoked at the appropriate places in the semantic actions. The infix parser in that module is essentially a simple hand-coded LR Parser.

The parser is parameterised over its initial infix environment. After successful parsing it returns the modified infix environment along with the AST.


\subsection{Derived Forms}
\label{derived}

To translate derived forms, three modules corresponding to the three grammar layers provide transformation functions that rewrite the grammatical forms to their equivalent forms, as specified in Appendix A of the Definition (modules {\tt DerivedForms$X$}). These functions are named similar to the constructors in the AST types so that the parser itself does not have to distinguish between constructors of bare syntax forms and pseudo constructors for derived forms.

The Definition describes the $\mathit{fvalbind}$ derived form in a very inaccurate way. The change described in Appendix \ref{ext-syntaxfixes} makes it a bit more precise by introducing several additional phrase classes (see \ref{bugsappendixb}). Most of the parsing happens in the {\tt Infix} module in this case, though.

Note that the structure sharing syntax is not a proper derived form since it requires context information about the involved structures (see \ref{bugsappendixa}). It therefore has been moved to the bare grammar.


\subsection{Syntactic Restrictions}
\label{restrictions}

The BNF grammar given in the Definition actually specifies a superset of all legal programs, which is further restricted by a set of syntactic constraints [Section 2.9, 3.5]. The parser accepts this precise superset, and the syntactic restrictions are verified in a separate pass.

Unfortunately, not all of the restrictions given in the Definition are purely syntactic (see \ref{bugschapter2}). In general, it requires full binding analysis to infer identifier status and type variable scoping.

Checking of syntactic restrictions has hence been implemented as a separate inference pass over the whole program. The pass closely mirrors the static semantics. It computes respective binding environments that record the identifier status of value identifiers. For modules, it has to include structures, functors and signatures as well, because the effect of {\tt open} relies on the environments they produce. Likewise, type environments are needed to reflect the effect of datatype replication. In essence, binding environments are isomorphic to interfaces in the dynamic semantics [Section 7.2]. As an extension, a binding basis includes signatures and functors. For the latter, we only need to maintain the result environment. Last, a binding context includes a set of bound type variables.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Elaboration}
\label{elaboration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Files}
\label{elaborationfiles}

The following modules represent objects of the static semantics and implement elaboration:

\begin{quote}
\begin{tabbing}
{\tt OverloadingClass}\qquad\= overloading classes
\kill

{\tt StaticObjectsCore}	\> definition of semantic objects \\
{\tt StaticObjectsModule} \> \\

{\tt TyVar}		\> type variables \\
{\tt TyName}		\> type names \\
\\
{\tt Type}		\> operations on types \\
{\tt TypeFcn}		\> operations on type functions \\
{\tt TypeScheme}	\> operations on type schemes \\
{\tt OverloadingClass}	\> overloading classes \\
\\
{\tt GenericEnvFn}	\> generic environment operations \\
{\tt StaticEnv}		\> environment instantiation \\
{\tt Sig}		\> operations on signatures \\
{\tt FunSig}		\> operations on functor signatures \\
{\tt StaticBasis}	\> operations on basis \\
\\
{\tt ElabCore}		\> implementation of elaboration rules \\
{\tt ElabModule}	\> \\
{\tt Clos}		\> expansiveness check and closure \\
{\tt CheckPattern}	\> pattern redundancy and exhaustiveness checking \\
\end{tabbing}
\end{quote}


\subsection{Types and Unification}
\label{types}

Types are represented according to the mapping explained in \ref{mapping} (module {\tt Type}). However, since type inference has to do unification (see \ref{typeinference}), which we prefer to do destructively for simplicity, each type node actually is wrapped into a reference. A simple graph algorithm is required to retain sharing when cloning types. All other type operations besides unification have functional semantics.

In order to avoid confusion (cf. \ref{bugsappendixg}) our type representation distinguishes undetermined types (introduced during type inference, see \ref{typeinference}) from explicit type variables. This requires an additional kind of node in our type representation. Moreover, we have another kind of undetermined type node to deal with overloaded types (see \ref{overloading}). Finally, we need a third additional node that replaces undetermined types once they become determined, in order to retain sharing.

All operations on types have been implemented in a very straightforward way. To keep the sources simple and faithful to the Definition we chose not to use any optimisations like variable levels or similar techniques often used in real compilers.


\subsection{Type Names}
\label{tynames}

Type names (module {\tt TyName}) are generated by a global stamp generator (module {\tt Stamp}). As described in the Definition, they carry attributes for arity and equality.

\void{
The equality attribute of type names is used in the Definition to determine whether a type admits equality. Those rules treat {\tt ref} in a special way. To generalise the treatment of {\tt ref} and allow for similar types like {\tt array} (which strictly speaking could not be added to SML without modifying the Definition), equality has not been implemented as a boolean attribute but via a tailor-made datatype allowing a third value of `special', {\tt ref}-like equality that is independent of particular argument types.
}

To simplify the task of checking exhaustiveness of patterns type names have been equipped with an additional attribute denoting the {\em span} of the type, i.e. the number of constructors (see \ref{patterns}). For pretty printing purposes, we also remember the original type constructor of each type name.


\subsection{Environment Representation}
\label{env}

In order to share as much code as possible between the rather similar environments of the static and the dynamic semantics, as well as the interfaces Int in the dynamic semantics of modules, we introduce a functor {\tt GenericEnvFn} that defines the representation and implements the common operations on environments.

Unfortunately, there exists a mutual recursion between environments and their range sets, in the static semantics (via TyStr) as well as in the dynamic semantics (via Val and FcnClosure). This precludes passing the environment range types as functor arguments. Instead, we make all environment types polymorphic over the corresponding range types. The instantiating modules ({\tt{StaticEnv}}, {\tt DynamicEnv}, and {\tt Inter}) tie the knot appropriately.

\void{
The introduction of higher-order modules (see Appendix \ref{ext-higherfunctors}) introduces a mutual recursion between the definition of structure environments StrEnv and modules Mod, which belong to the Core semantics, and functor signatures FunSig, which are part of the semantic objects for Modules. In order to avoid giving up the separation in the implementation, we use the dirty trick of wrapping functor signatures in an exception constructor, which allows hiding the {\tt FunSig} type in the definition of Core semantic objects. The same trick is used for the semantic objects of the dynamic semantics (with FunctorClosure instead of FunSig), and in the definition of binding environments for checking syntactic restrictions (Section \ref{restrictions}).

In the static semantics this also induces a mutual recursion on the value level, see Section \ref{matching}.
}


\subsection{Elaboration Rules}
\label{elaborationrules}

Elaboration implements the inference rules of sections [4.10] and [5.7] (modules {\tt ElabCore} and {\tt ElabModule}). It also checks the further restrictions in [4.11].

The inference rules have been mapped to SML functions as described in \ref{mappingrules}. We only need simple kinds of additional arguments: a flag indicating whether we are currently elaborating a toplevel declaration (in order to implement restriction 3 in [4.11] properly), a list of unresolved types (for overloading resolution and flexible records, see \ref{overloading}), and a list of {\tt fn} $\mathit{match}$es (to defer checking of exhaustiveness until after overloading resolution, see \ref{patterns} and \ref{overloading}). For modules, we pass down the equality attribute of type descriptions (see \ref{moduleelaboration}).

Note that most of the side conditions on type names could be ignored since they are mostly ensured by construction using stamps. We included them anyway, to be consistent and to have an additional sanity check. At some places these checks are not accurate, though, since the types examined can still contain type inference holes which may be filled with type names later. To be faithful, we hence employ time stamps on type names and type holes, such that violations of prior side conditions can be discovered during type inference, as we explain in the next section.


\subsection{Type Inference}
\label{typeinference}

The inference rules for core elaboration are non-deterministic. For example, when entering a new identifier representing a pattern variable into the environment, rule 34 [4.10] essentially guesses its correct type. A deterministic implementation of type inference is the standard algorithm W by Damas/Milner \cite{principal}. Informally, when it has to guess a type non-deterministically it introduces a fresh type variable as a placeholder. We prefer to speak of undetermined types instead, since type variables already exist in a slightly different sense in the semantics of SML (cf. \ref{bugsappendixg}).

Wherever an inference rule imposes an equality constraint on two types because the same meta-variable appears in different premises, the algorithm tries to unify the two types derived. After a value declaration has been checked, one can safely turn remaining undetermined types into type variables and universally quantify the inferred type over them, if they do not appear in the context. SML's value restriction does restrict this closure to non-expansive declarations, however [4.7, 4.8]. Note that (explicit) type variables can only be unified with themselves.

We use an imperative variant of the algorithm where unification happens destructively \cite{typechecking}, so that we do not have to deal with substitutions, and the form of the elaboration functions is kept more in line with the inference rules in the Definition (module {\tt ElabCore}).

Undetermined types are identified by stamps. They carry two additional attributes: an equality constraint, telling whether the type has to admit equality, and a time stamp, which records the relative order in which undetermined types and type names have been introduced. During unification with undetermined types we have to take care to properly enforce and propagate these attributes.

When instantiating type variables to undetermined types [4.10, rule 2], the undetermined type inherits the equality attribute from the variable. An undetermined equality type induces equality on any type it is unified with. In particular, if an undetermined equality type is unified with an undetermined non-equality type, equality is induced on the latter (function {\tt Type.unify}).

Likewise, when a type is unified with an undetermined type, the latter's time stamp is propagated to all subterms of the former. That is, nested undetermined types inherit the time stamp if their own is not older already. Type names must always be older than the time stamp -- unification fails, when a type name is encountered that is newer. This mechanism is used to prevent unification with types which contain type names that have been introduced {\em after} the undetermined type. For example, the snippet
\begin{quote}
\begin{alltt}
let
    val r = ref NONE
    datatype t = C
in
    r := SOME C
end
\end{alltt}
\end{quote}
must not type-check -- the type of {\tt r} may not mention {\tt t} (otherwise the freshness side condition on names for datatypes [4.10, rule 17] would be violated). However, type inference can only find out about this violation at the point of the assignment expression. By comparing the time stamp of the undetermined type introduced when elaborating the declaration of {\tt r}, and the stamp of the type name {\tt t}, our unification algorithm will discover the violation.

More importantly, the mechanism is sufficient to preclude unification of undetermined types with {\em local} type names, as in the following example:
\begin{quote}
\begin{alltt}
val r = ref NONE
functor F(type t; val x : t) =
struct
    val _ = r := SOME C
end
\end{alltt}
\end{quote}
Obviously, allowing this example would be unsound.

Similarly, the time stamp mechanism is used to prevent invalid unification of monomorphic undetermined types remaining due to the value restriction, with type variables, see Section \ref{typeschemes}.

To cope with type inference for records, we have to represent partially determined rows. The yet undetermined part of a row is represented by a special kind of type variable, a {\em row variable}. This variable has to carry the same attributes as an undetermined type, i.e.\ an equality flag and a time stamp, both of which have to be properly propagated on unification. See also Section \ref{overloading}.


\subsection{Type Schemes}
\label{typeschemes}

Type schemes represent polymorphic types, i.e. a type prefixed by a list of quantified type variables. The only non-trivial operation on type schemes is generalisation [4.5].

We implement the generalisation test via unification: in order to test for $\forall\alpha^{(k)}.\tau \succ \tau'$, we instantiate $\alpha^{(k)}$ with undetermined types $\tau^{(k)}$ and test whether $\tau[\tau^{(k)}/\alpha^{(k)}]$ can be unified with $\tau'$.

To test generalisation between type schemes, $\forall\alpha^{(k)}.\tau \succ \forall\alpha^{(k')}.\tau'$, we first skolemise the variables $\alpha^{(k')}$ on the right-hand side by substituting them with fresh type names $t^{(k')}$. Then we proceed by testing for $\forall\alpha^{(k)}.\tau \succ \tau'[t^{(k')}/\alpha^{(k')}]$ as described before.

Note that $\tau$ may contain undetermined types, stemming from expansive declarations. These have to be kept monomorphic, but naive unification might identify them with one of the skolem types $t^{(k')}$ (or a type containing one) -- and hence effectively turn them into polymorphic types! For example, when checking the signature ascription in the following example,
\begin{quote}
\begin{alltt}
signature S = sig val f : 'a -> 'a option end
structure X : S =
struct
    val r = ref NONE
    fun f x = !r before r := SOME x
end
\end{alltt}
\end{quote}
the type inferred for the function {\tt f} contains an undetermined type, the content type of {\tt r}. It must be monomorphic, hence the type of {\tt f} does not generalise the polymorphic type specified in the signature.\footnote{Several SML implementations currently get this wrong, opening a soundness hole in their type checkers.} Comparison of the time stamps of the undetermined type and the newer type name generated during skolemisation of {\tt 'a} makes unification between the two properly fail with our algorithm.


\subsection{Overloading and Flexible Records}
\label{overloading}

Overloading is the least formal part of the Definition (see \ref{bugsappendixe}). It is just described in an appendix, as special case treatment for a handful of given operators and constants. We try to generalise the mechanism indicated in the Definition in order to have something a bit less ad hoc that smoothly integrates with type inference.

To represent type schemes of overloaded identifiers we allow type variables to be constrained with overloading classes in a type scheme, i.e.\ type variables can carry an overloading class as an additional optional attribute. When instantiated, such variables are substituted by overloaded type nodes, constrained by the same overloading class (constructor {\tt Type.Overloaded}). When we unify an overloaded type with another, determined type we have to check whether that other type is a type name contained in the given overloading class. If yes, overloading has been resolved, if no there is a type error (function {\tt Type.unify}).

When unifying two overloaded types, we have to calculate the intersection of the two overloading classes. So far, everything is pretty obvious. The shaky part is how to propagate the default types associated with the classes when we perform intersection.

We formalise an overloading class as a pair of its type name set and the type name being the designated default:

\begin{displaymath}
(T,t) \in \mbox{OverloadingClass} = \mbox{TyNameSet} \times \mbox{TyName}
\end{displaymath}

Now when we have to intersect two overloading classes $(T_1,t_1)$ and $(T_2,t_2)$, there may be several cases. Let $T = T_1 \cap T_2$:

\begin{enumerate}
\item\label{intersectempty} $T = \emptyset$. In this case, the constraints on the types are inconsistent and the program in question is ill-typed.

\item\label{defaultequal} $T \neq \emptyset$ and $t_1 = t_2 \in T$. The overloading has (possibly) been narrowed down and the default types are consistent.

\item\label{uniquedefault} $T \neq \emptyset$ and $t_1 \neq t_2$ and $|\{t_1,t_2\} \cap T| = 1$. The overloading has been narrowed down. The default types differ but only one of them still applies.

\item\label{ambiguousdefault} $T \neq \emptyset$ and $|\{t_1,t_2\} \cap T| \neq 1$. The overloading could be narrowed down, but there is no unambiguous default type.
\end{enumerate}

Case (\ref{uniquedefault}) is a bit subtle. It occurs when checking the following declaration:

\begin{quote}
\begin{alltt}
fun f(x,y) = (x + y)/y
\end{alltt}
\end{quote}

Both, {\tt +} and {\tt /} are overloaded and default to different types, but in this combination only {\tt real} remains as a valid default so that the type of {\tt f} should default to ${\tt real}\times{\tt real}\to{\tt real}$.\footnote{Some SML implementations do not handle this case properly.}

There are two ways to deal with case (\ref{ambiguousdefault}): either rule it out by enforcing suitable well-formedness requirements on the overloading classes in the initial basis, or handle it by generalising overloading classes to contain {\em sets} of default values (an error would be flagged if defaulting actually had to be applied for a non-singular set). We settled for the former alternative as it seems to be more in spirit with the Definition and it turns out that the overloading classes specified in the Definition satisfy the required well-formedness constraints.\footnote{A previous version of HaMLet used the latter alternative. It allows more liberal overloading but may lead to typing errors due to ambiguous overloading, despite the default mechanism. Moreover, in full generality it raises additional issues regarding monotonicity of overloading resolution when extending the library.}

Consequently, we demand the following properties for all pairs of overloading classes $(T,t)$, $(T',t')$ appearing in a basis:

\begin{enumerate}
\item\label{defaultcontained} $t \in T$
\item\label{equalityconsistent} $\mbox{Eq}(T) = \emptyset \quad\vee\quad \mbox{$t$ admits equality}$
\item\label{intersectionunique} $T \cap T' = \emptyset \quad\vee\quad |\{t,t'\} \cap T \cap T'| = 1$
\end{enumerate}

where $\mbox{Eq}(T) = \{ t \in T \;|\; \mbox{$t$ admits equality} \}$.

The reason for (\ref{defaultcontained}) is obvious. (\ref{equalityconsistent}) guarantees that we do not loose the default by inducing equality. (\ref{intersectionunique}) ensures a unique default whenever we have to unify two overloaded types. (\ref{equalityconsistent}) and (\ref{intersectionunique}) also allow the resulting set to become empty which represents a type error.

Defaulting is implemented by collecting a list of all unresolved types -- this includes flexible records -- during elaboration of value declarations (additional argumetn {\tt utaus}). Before closing an environment, we iterate over this list to default remaining overloaded types or discover unresolved flexible records. This implies that the context determining an overloaded type or flexible record type is the smallest enclosing core-level declaration of the corresponding overloaded identifier, special constant, or flexible record, respectively (cf. \ref{bugschapter4} and \ref{bugsappendixe}).

Special constants have to be annotated with corresponding type names by overloading resolution, in order to get the correct dynamic semantics (see \ref{evaluationrules}) and enable proper checking of match exhaustiveness (see \ref{patterns}). For this purpose, the list of unresolved types can carry optional associated special constants. During defaulting we annotate each constant, and do range checking of the constant's value with respect to the resolved type at the same time.


\subsection{Recursive Bindings and Datatype Declarations}
\label{recursive}
\label{datatype}

Value bindings with {\tt rec} and datatype declarations are recursive. The inference rules (15, 17 and 19 after the change from Appendix \ref{ext-recursive}) use the same environment $\mathit{VE}$ or $\mathit{TE}$ on the left hand side of the turnstile that is to be inferred on its right hand side.

To implement this we build a tentative environment in a first iteration that is not complete but already contains enough information to perform the actual inference in the second iteration. For recursive value bindings we insert undetermined types as placeholders for the actual types (and unify later), for datatype bindings we leave the constructor environments empty.

Datatype declarations bring an additional complication because of the side condition that requires $\mathit{TE}$ to maximise equality. This is being dealt with by first assuming equality for all type names introduced and later adjusting all invalid equality attributes in a fixpoint iteration until all type structures respect equality (function {\tt StaticEnv.maximiseEquality}).


\subsection{Module Elaboration}
\label{moduleelaboration}

Like for the core language, the inference rules for modules are non-deterministic. In particular, several rules have to guess type names that have to be consistent with side conditions enforced further down the inference tree. However, most of these side conditions just ensure that type names are unique, i.e.\ fresh type names are chosen where new types are introduced. Since we create type names through a stamp mechanism, most of these side conditions are trivially met. The remaining cases are dealt with by performing suitable renaming of bound type names with fresh ones, as the Definition already suggests in the corresponding comments (module {\tt ElabModule}).

The other remaining bits of non-determinism are guessing the right equality attribute for type descriptions, which is dealt with by simply passing the required attribute down as an additional assumption (function {\tt ElabModule.elabTypDesc}), and for datatype specifications, which require the same fixpoint iteration as datatype declarations in the core (see \ref{datatype}).


\subsection{Signature Matching}
\label{matching}

Signature matching is the most complex operation in the SML semantics. As the Definition describes, it is a combination of realisation and enrichment.

To match a module $E'$ against a signature $\Sigma = (T,E)$ we first calculate an appropriate realisation $\varphi$ by traversing $E$: for all flexible type specifications in $E$ (i.e.\ those whose type functions are equal to type names bound in $T$) we look up the corresponding type in $E'$ and extend $\varphi$ accordingly. Then we apply the resulting realisation to $E$ which gives us the potential $E^-$. For this we just have to check whether it is enriched by $E'$ which can be done by another simple traversal of $E^-$ (functions {\tt Sig.match} and {\tt StaticEnv.enriches}).

The realisation calculated during matching is also used to propagate type information to the result environment of functor applications (rule 54, module {\tt ElabModule}). A functor signature has form $(T_1)(E_1,(T'_1)E'_1)$. To obtain a suitable functor instantiation $(E'',(T')E')$ for rule 54 we simply match the environment $E$ of the argument structure to the signature $(T_1)E_1$ which gives $E''$ and a realisation $\varphi$. We can apply $\varphi$ to the functor's result signature $(T'_1)E'_1$ to get -- after renaming all $t \in T'_1$ to fresh names $t' \in T'$ -- the actual $(T')E'$ appearing in the rule.

So far, the description applies to modules as defined in the Definition. The change in appendix \ref{ext-higherfunctors} generalises matching to higher-order modules. That means that modules $M$ may appear instead of environments $E$ in the above cases. Computing a realisation for matching is not complicated, though, since functors cannot bind any type names, so that $T$ remains empty for functor signatures and only the case $M=E$ has to be considered, as before.

\void{
However, the definition of enrichment becomes now mutually recursive with the additional concept of matching on functor signatures. This induces a mutual recursion between the function {\tt StaticEnv.enriches} checking enrichment and {\tt FunSig.matches} implementing functor signature matching. Short of recursive modules in SML, this recursion is implemented with the well-known trick of using a forwarding reference in module {\tt StaticEnv} that ties the recursive knot via assignment in module {\tt FunSig}.
}

\subsection{Checking Patterns}
\label{patterns}

Section [4.11], items 2 and 3 require checking exhaustiveness and irredundancy of patterns. The algorithm for performing this check is based on \cite{patterns} (module {\tt CheckPattern}). The basic idea of the algorithm is to perform {\em static matching}, i.e.\ to traverse the decision tree corresponding to a match and propagate information about the value to be matched from the context of the current subtree. The knowledge available on a particular subterm is described by the {\tt description} type. Moreover, a {\tt context} specifies the path from the root to the current subtree.

The algorithm is loosely based on \cite{patterns}, where more details can be found. To enable this algorithm, type names carry an additional attribute denoting their {\em span}, i.e.\ the number of constructors the type possesses (see \ref{tynames}). We extend the ideas in the paper to cover records (behave as non-positional tuples), exception constructors (have infinite span), and constants (treated like constructors with appropriate, possibly infinite span). Note that we have to defer checking of patterns until overloading resolution for contained constants has been performed -- otherwise we will not know their span.

A context description is not simply a list of constructor applications to term descriptions as in the paper, but separates constructor application from record aggregation and uses a nested definition. Instead of lists of negative constructors (and constants) we use sets for descriptions. Record descriptions are maps from labels to descriptions.

During traversal we construct two sets that remembers the region of every match we encountered, and every match we reached. In the end we can discover redundant matches by taking the difference of the sets. Non-exhaustiveness is detected by remembering whether we reached a failure leaf in the decision tree.

In the case of exception constructors, equality can only be checked on a syntactic level. Since there may be aliasing this is merely an approximation (see \ref{bugschapter4}).

There is a problem with the semantics of sharing and {\tt where} constraints, which allow inconsistent datatypes to be equalised (see \ref{bugschapter4}). In this case, no meaningful analysis is possible, resulting warnings may not make sense. There is nothing we can do but ignore this problem.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evaluation}
\label{evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Files}
\label{evaluationfiles}

Objects of the dynamic semantics and evaluation rules are implemented by the following modules:

\begin{quote}
\begin{tabbing}
{\tt DynamicObjectsModule}\qquad\= generic environment representation
\kill

{\tt DynamicObjectsCore} \> definition of semantic objects \\
{\tt DynamicObjectsModule} \> \\

{\tt Addr}		\> addresses \\
{\tt ExName}		\> exception names \\
{\tt BasVal}		\> basic values \\
{\tt SVal}		\> special values \\
\\
{\tt Val}		\> operations on values \\
{\tt State}		\> operations on state \\
\\
{\tt GenericEnvFn}	\> generic environment operations \\
{\tt DynamicEnv}	\> operations on environments \\
{\tt Inter}		\> operations on interfaces \\
{\tt DynamicBasis}	\> operations on basis \\
\\
{\tt EvalCore}		\> implementation of evaluation rules \\
{\tt EvalModule}	\> \\
\end{tabbing}
\end{quote}


\subsection{Value Representation}
\label{values}

Values are represented as defined in Section 6.3 of the Definition (module {\tt Val}). Special values are simply represented by the corresponding SML types (module {\tt SVal}). Currently, only the default types and {\tt Word8.word} are implemented, which represents the minimum requirement of the Standard Basis.

Basic values are simply represented by strings (module {\tt BasVal}). However, the only basic value defined in the Definition is the polymorphic equality {\tt =}, everything else is left to the library. Consequently, the implementation of the APPLY function only handles {\tt =}. For all other basic values it dispatches to the {\tt Library} module, which provides an extended, library-specific version of the APPLY function (see Section \ref{lib}).

The special value FAIL, which denotes pattern match failure, is not represented directly but has rather been defined as an exception (see \ref{evaluationrules}).


\subsection{Evaluation Rules}
\label{evaluationrules}

The rules of the dynamic semantics have been translated to SML following similar conventions as for the static semantics (see \ref{mappingrules}). However, to avoid painfully expanding out all occurrences of the state and exception conventions, we deal with state and exceptions in an imperative way. State is not passed around as a functional value but rather as a reference to the actual state map (module {\tt State}) that gets updated on assignments. This avoids threading the state back with the result values. Exception packages (module {\tt Pack}) are not passed back either, but are rather transferred by raising a {\tt Pack} exception. Similarly, FAIL has been implemented as an exception.

So state is implemented by state and exceptions by exceptions -- not really surprising. Consequently, rules of the form

\begin{displaymath}
s,A \vdash \mathit{phrase} \Rightarrow A'/p,s'
\end{displaymath}

become functions of type

\begin{alltt}
\hfill State ref * A * phrase -> A' \hfill
\end{alltt}

which may raise a {\tt Pack} exception -- likewise for rules including FAIL results. We omit passing in the state where it is not needed. This way the code follows the form of rules using the state and exception conventions as close as possible (modules {\tt EvalCore} and {\tt EvalModule}).

Failure with respect to a rule's premise corresponds to a runtime type error. This may actually occur in evaluation mode and is flagged accordingly.% Note however, that some invariants assumed in the dynamic semantics of the Definition are not met in evaluation mode as they are ensured through syntactic restrictions, which we check during elaboration only.

Evaluation of special constant behaves differently in execution and elaboration mode. In the former, constants will have been annotated with a proper type name by overloading resolution (see \ref{overloading}). In evaluation mode this annotation is missing and the function {\tt valSCon} will assume the default type of the corresponding overloading class, respectively. This implies that the semantics may change (see \ref{usingstandalone}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Toplevel}
\label{toplevel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Files}
\label{toplevelfiles}

The remaining modules implement program execution and interactive toplevel:

\begin{quote}
\begin{tabbing}
{\tt InitialDynamicBasis}\qquad\= \kill

{\tt Basis}			\> the combined basis \\
{\tt Program}			\> implementation of rules for programs \\
\\
{\tt InitialInfixEnv}		\> initial environments \\
{\tt InitialStaticEnv}		\> \\
{\tt InitialStaticBasis}	\> \\
{\tt InitialDynamicEnv}		\> \\
{\tt InitialDynamicBasis}	\> \\
\\
{\tt PrettyPrint}		\> pretty printing engine \\
{\tt PPMisc}			\> auxiliary pretty printing functions \\
{\tt PPType}			\> pretty printing of types \\
{\tt PPVal}			\> ... values \\
{\tt PPStaticEnv}		\> ... static environment \\
{\tt PPStaticBasis}		\> ... static basis \\
{\tt PPDynamicEnv}		\> ... dynamic environment \\
{\tt PPDynamicBasis}		\> ... dynamic basis \\
{\tt PPBasis}			\> ... combined basis \\
\\
{\tt Use}			\> the {\tt use} queue \\
{\tt Sml}			\> main HaMLet interface \\
{\tt Main}			\> wrapper for stand-alone version \\
\end{tabbing}
\end{quote}


\subsection{Program Execution}
\label{execution}

The module {\tt Program} implements the rules in Chapter 8 of the Definition. It follows the same conventions as used for the evaluation rules (see \ref{mappingrules} and \ref{evaluationrules}).

In addition to the `proper' implementation of the rules as given in the Definition (function {\tt execProgram}) the module also features two straightforward variations that suppress evaluation and elaboration, respectively ({\tt elabProgram} and {\tt evalProgram}).

Note that a failing elaboration as appearing in rule 187 corresponds to an {\tt Error} exception. However, in evaluation mode, an {\tt Error} exception will originate from a runtime type error.

The remaining task after execution is pretty printing the results. We use an extended version of a generic pretty printer proposed by Wadler \cite{pretty} which features more sophisticated grouping via {\em boxes} (modules {\tt PrettyPrint} and {\tt PP}$xxx$).


\subsection{Plugging}
\label{plugging}

The {\tt Sml} module sets up the standard library (see Section \ref{lib}), does all necessary I/O interaction and invokes the parser and the appropriate function in module {\tt Program}, passing the necessary environments.

After processing the input itself the functions in the {\tt Sml} module process all files that have been entered into the {\tt use} queue during evaluation (see \ref{use}). That may add additional entries to the queue.

The {\tt Main} module is only needed for the stand-alone version of HaMLet. It parses the command line and either starts an appropriate session or reads in the given files.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Library}
\label{lib}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Files}
\label{libfiles}

The library only consists of a hook module and the library implementation files written in the target language:

\begin{quote}
\begin{tabbing}
{\tt Library}\qquad\= \kill

{\tt Library}			\> primitive part of the library \\
{\tt Use}			\> {\tt use} queue \\
{\tt basis/}			\> the actual library modules\\
\end{tabbing}
\end{quote}


\subsection{Language/Library Interaction}
\label{libhooks}

The Definition contains several hooks where it explicitly delegates fleshing out stuff to the library:

\begin{itemize}
\item the set BasVal of basic values and the APPLY function [6.4]
\item the initial static basis $B_0$ and infix status [Appendix C]
\item the initial dynamic basis $B_0$ [Appendix D]
\item the basic overloading classes Int, Real, Word, String, Char [E.1]
\end{itemize}

Realistically, it also would have to allow extending the sets SVal [6.2] and Val [6.3], and enable the APPLY function to modify the program state (cf. \ref{bugschapter6}). HaMLet currently only extends SVal, while other library types are mapped to what is there already (see \ref{primtypes}).

We encapsulate all library extensions into one single module {\tt Library} that defines the parts of these objects that are left open by the Definition. However, we split up implementation of the library into two layers:

\begin{itemize}
\item the {\em primitive} layer that contains everything that cannot be defined within the target language,
\item the {\em surface} layer which defines the actual library.
\end{itemize}

By {\em target language} we mean the language to be implemented. Many library entities are definable within the target language itself, e.g.\ the standard {\tt !} function. There are basically three reasons that can force us to make an entity primitive:

\begin{itemize}
\setlength{\parskip}{0ex}
\item its behaviour cannot be implemented out of nowhere (e.g. I/O operations),
\item it is dependent on system properties (e.g. numeric limits), or
\item it possesses a special type (e.g. overloaded identifiers).
\end{itemize}

The {\tt Library} module defines everything that has to be primitive (see \ref{primitives}), while the rest is implemented within the target language in the modules inside the {\tt basis} directory (see \ref{basis}). These modules have to make assumptions about what is defined by the {\tt Library} module, so that both actually should be seen in conjunction.


\subsection{Primitives}
\label{primitives}

Primitive operations are implemented by means of the APPLY function. Most of them just fall back to the corresponding operations of the host system.\footnote{Unfortunately, most SML implementations lack a lot of the obligatory functionality of the Standard Basis Library. To stay portable among systems we currently restrict ourselves to the common subset.} We only have to unpack and repack the value representation and remap possible exceptions. 
Overloaded primitives have to perform a trivial type dispatch.
% Moreover, in order to approximate typed behaviour as far as possible even in pure evaluation mode, we allow implicit conversions from default types of an overloading class to any other type of the same class (see also \ref{usingstandalone}). Of course, this conversions will never be performed in a typed program.

Despite implementing a large number of primitives, the static and dynamic basis exported does only contain a few things:
\begin{itemize}
\setlength{\parskip}{0ex}
\item the {\tt vector} type,
\item all overloaded functions,
\item the exceptions used by primitives,
\item the function {\tt use}.
\end{itemize}
Everything else can be obtained from these in the target language. Primitive exceptions not available on the toplevel are wrapped into their residuent structures.

To enable the target language to bind the basic values defined by the library, we piggy-back the {\tt use} function. Its dynamic semantics is overloaded and in the static basis exported by the {\tt Library} module it is given type {\tt $\alpha\to\beta$}. Applying it to a record of type $\{{\tt{b}}:{\tt{string}}\}$ will return the basic value denoted by the string {\tt b} -- of course, the library source code should annotate the result type properly to be type-safe. Primitive constants of type $\tau$ are available as functions ${\tt unit}\to\tau$.

The {\tt use} function has been chosen for this purpose since its existence cannot be encapsulated in the library anyway -- the interpreter has to know about it (see \ref{use}). Once all necessary basic values have been bound, the library source code should hide the additional, unsafe functionality of {\tt use} by rebinding it with its properly restricted type ${\tt string}\to{\tt unit}$.


\subsection{Primitive Library Types}
\label{primtypes}

The dynamic semantics of the Definition do not really allow the addition of arbitrary library types -- in general this would require extending the set Val [6.3]. Moreover, the APPLY function might require access to the state (see \ref{bugschapter6}).

But we can at least encode vectors by abusing the record representation. Arrays can then be implemented on top of vectors and references within the target language. However, this has to make their implementation type transparent in order to get the special equality for arrays.\void{\footnote{Although HaMLet already generalises the special equality characteristics of references (see \ref{tynames}) we do not currently use that for arrays because it would require making them primitive.}}

I/O stream types can only be implemented magically as indices into a stateful table that is not captured by the program state defined in [6.3].


\subsection{The {\tt use} Function}
\label{use}

The `real' behaviour of {\tt use} is implemented by putting all argument strings for which it has been called into a queue managed by module {\tt Use}. The {\tt Sml} module looks at this queue after processing its main input (see \ref{plugging}).

The argument strings are interpreted as file paths, relative paths being resolved with respect to the current working directory before putting them into the queue. The function reading source code from a file ({\tt Sml.fromFile}) always sets the working directory to the base path of the corresponding file before processing it. This way, {\tt use} automatically interprets its argument relative to the location of the current file.


\subsection{Library Implementation}
\label{basis}

The surface library is loaded on startup\void{ (or during built in the case of SML/NJ)}. The function {\tt Sml.loadLib} just silently executes the file {\tt basis/all.sml}. This file is the hook for reading the rest of the library, it contains a bunch of calls to {\tt use} that execute all library modules in a suitable order. Note that the library files always have to be {\em executed}, even if HaMLet is just running in parsing or elaboration mode -- otherwise the contained {\tt use} applications would not take effect.

The library modules themselves mostly contain straightforward implementations of the structures specified in the Standard Basis Manual \cite{basis}. Like the implementation of the language, the library implementation is mostly an executable specification with no care for efficiency. All operations not directly implementable and thus represented as primitive basic values are bound via the secret functionality of the {\tt use} function (see \ref{primitives}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\label{conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

HaMLet has been implemented with the idea of transforming the formalism of the Definition into SML source code as directly as possible. Not everything can be translated 1-to-1, though, because of the non-deterministic nature of some aspects of the rules and due to the set of additional informal rules that describe parts of the language.

Still, much care has been taken to get even the obscure details of these parts of the semantics right. For example, HaMLet goes to some length to treat the following correctly:

\begin{itemize}
\setlength{\parskip}{0ex}
%\item not accepting additional syntactic phrases (e.g.\ {\tt as} and {\tt fun}),
%\item parsing of the {\tt where type} ... {\tt and} derived form,
\item checking syntactic restrictions separately,
\item derived forms (e.g.\ {\tt withtype}, definitional type specifications),
%\item {\tt val} {\tt rec} (binding rules, dynamic semantics),
\item distinction of type variables from undetermined types,
\item overloading resolution,
\item flexible records,
\item dynamic semantics.
\end{itemize}

Some more issues present in SML'97 have been removed by the changes described in Appendix \ref{extensions}.

\void{
The {\tt test} directory in the HaMLet distribution contains some contrived examples of these and other code that is rejected by several SML systems despite being correct according to the Definition. HaMLet accepts all but two of them. Consequently, we are positive that HaMLet is more accurate in implementing the SML language specification than most other systems. There still are some deviations, though:

\begin{itemize}
\setlength{\parskip}{0ex}
\item inability to parse some legal SML programs (\ref{ambiguities}),
\item non-principal types for equality polymorphic functions in an {\tt abstype} declaration (see \ref{bugschapter4}),
\item non-principal types for non-generalized declarations in functors (see \ref{bugschapter5}).
\end{itemize}

We consider all of these minor, since no existing SML implementations is able to deal with them. They are arguably mistakes on the side of the Definition, see \ref{bugsappendixa}, \ref{bugschapter2} and \ref{bugschapter4}. Still, we hope to fix these issues in future releases. Moreover, we plan to provide a more complete implementation of the Standard Basis Library.
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}
\label{acknowledgements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Thanks go to the following people who knowingly or unknowingly helped in putting together HaMLet and this special ``Successor ML'' version:

\begin{itemize}
\item Stefan Kahrs, Claudio Russo, Matthias Blume, Derek Dreyer, Stephen Weeks, Bob Harper, Greg Morrisett, John Reppy, John Dias, David Matthews, and other people on the sml-implementers list for discussions about aspects and rough edges of the SML semantics,
\item all people participating in the discussions on the sml-evolution list, the Successor ML wiki, and the SML evolution meeting,
\item the authors of the original ML Kit \cite{kit}, for their great work that initially inspired the work on HaMLet,
\item of course, the designers of ML and authors of the Definition, for the magnificent language.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vfill
\pagebreak
\begin{appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mistakes and Ambiguities in the Definition}
\label{definitionbugs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This appendix lists all bugs, ambiguities and `grey areas' in the Definition that are known to the author. Many of them were already present in the previous SML'90 version of the Definition \cite{definition90} (besides quite a lot that have been corrected in the revision) and are covered by Kahrs \cite{mistakes, addenda} in detail. Bugs new to SML'97 or not covered by Kahrs are marked with * and (*), respectively.

Where appropriate we give a short explanation and rationale of how we fixed or resolved it in HaMLet.


\subsection{Issues in Chapter 2 (Syntax of the Core)}
\label{bugschapter2}

Section 2.4 (Identifiers):

\begin{itemize}
\item The treatment of {\tt =} as an identifier is extremely ad-hoc. The wording suggests that there are in fact two variants of the identifier class VId, one including and the other excluding {\tt =} . The former is used in expressions, the latter everywhere else.
\end{itemize}


Section 2.5 (Lexical analysis):
\nopagebreak

\begin{itemize}
\item In [2.2] the Definition includes only space, tab, newline, and formfeed into the set of obligatory formatting characters that are allowed in source code. However, some major platforms require use of the carriage return character in text files. In order to achieve portability of sources across platforms it should be included as well.

Fixed by change described in Appendix \ref{ext-syntaxfixes}.
\end{itemize}


Section 2.6 (Infixed Operators):

\begin{itemize}

\item The Definition says that ``the only required use of {\tt op} is in prefixing a non-infixed occurrence of an identifier which has infix status''. This is rather vague, since it is not clear whether occurrences in constructor and exception bindings count as non-infixed \cite{mistakes}.

Fixed by change described in Appendix \ref{ext-syntaxfixes}.

\end{itemize}

Section 2.8 (Grammar), Figure 4 (Expressions, Matches, Declarations and Bindings):

\begin{itemize}

\item (*) The syntax rules for $\mathit{dec}$ are highly ambiguous. The productions for empty declarations and sequencing allow the derivation of arbitrary sequences of empty declarations for any input.

HaMLet does not allow empty declarations as part of sequences without a separating semicolon. On the other hand, every single semicolon is parsed as a sequence of two empty declarations. This makes parsing of empty declarations unambiguous.

\item Another ambiguity is that a sequence of the form $\mathit{dec}_1\;\mathit{dec}_2\;\mathit{dec}_3$ can be reduced in two ways to $\mathit{dec}$: either via $\mathit{dec}_{12}\;\mathit{dec}_3$ or via $\mathit{dec}_1\;\mathit{dec}_{23}$ \cite{mistakes}. See also \ref{bugschapter3}.

We choose left associative sequencing, i.e.\ the former parse.

\end{itemize}


Section 2.9 (Syntactic Restrictions):

\begin{itemize}

\item * The restriction that $\mathit{valbind}$s may not bind the same identifier twice (2nd bullet) is not a syntactic restriction as it depends on the identifier status of the $\mathit{vid}$s in the patterns of a $\mathit{valbind}$. Identifier status can be derived by inference rules only. Similarly, the restriction on type variable shadowing (last bullet) is dependent on context and computation of unguarded type variables [Section 4.6].

We implement checks for syntactic restrictions as a separate inference pass over the complete program that closely mirrors the static semantics. Ideally, all syntactic restrictions rather should have been defined as appropriate side conditions in the rules of the static \emph{and} dynamic semantics by the Definition.

\item * An important syntactic restriction is missing:

\begin{quote}
``Any $\mathit{tyvar}$ occurring on the right side of a $\mathit{typbind}$ or $\mathit{datbind}$ of the form $\mathit{tyvarseq}$ $\mathit{tycon}$ {\tt =} $\cdots$ must occur in $\mathit{tyvarseq}$.''
\end{quote}

This restriction is analogous to the one given for $\mathit{tyvar}$s in type specifications [3.5, item 4]. Without it the type system would be unsound. \footnote{Interestingly enough, in the SML'90 Definition the restriction was present, but the corresponding one for specifications was missing \cite{commentary, mistakes}.}

Fixed by change described in Appendix \ref{ext-semanticfixes}.

\end{itemize}


\subsection{Issues in Chapter 3 (Syntax of Modules)}
\label{bugschapter3}

Section 3.4 (Grammar for Modules), Figure 6 (Structure and Signature Expressions):

\begin{itemize}

\item The syntax rules for $\mathit{strdec}$ contain the same ambiguities with respect to sequencing and empty declarations as those for $\mathit{dec}$ (see \ref{bugschapter2}).

Consequently, we use equivalent disambiguation rules.

\item Moreover, there are two different ways to reduce a sequence $\mathit{dec}_1\;\mathit{dec}_2$ of core declarations into a $\mathit{strdec}$: via $\mathit{strdec}_1\;\mathit{strdec}_2$ and via $\mathit{dec}$ \cite{mistakes}. Both parses are not equivalent since they provide different contexts for overloading resolution [Appendix E]. For example, appearing on structure level, the two declarations

\begin{quote}
\begin{alltt}
fun f x = x + x
val a = f 1.0
\end{alltt}
\end{quote}

may be valid if parsed as $\mathit{dec}$, but do not type check if parsed as $\mathit{strdec}_1\;\mathit{strdec}_2$ because overloading of {\tt +} gets defaulted to {\tt int}.

Fixed by change described in Appendix \ref{ext-syntaxfixes}.

\item Similarly, it is possible to parse a structure-level {\tt local} declaration containing only core declarations in two ways: as a $\mathit{dec}$ or as a $\mathit{strdec}$ \cite{mistakes}. This produces the same semantic ambiguity.

Fixed by change described in Appendix \ref{ext-syntaxfixes}.

\end{itemize}


Section 3.4 (Grammar for Modules), Figure 7 (Specifications):

\begin{itemize}

\item Similar as for $\mathit{dec}$ and $\mathit{strdec}$, there exist ambiguities in parsing empty and sequenced $\mathit{spec}$s.

We resolve them consistently.

\item The ambiguity extends to sharing specifications. Consider:

\begin{quote}
\begin{alltt}
type t
type u
sharing type t = u
\end{alltt}
\end{quote}

This snippet can be parsed in at least three ways, with the sharing constraint taking scope over either both, or only one, or neither type specification. Since only the first alternative can be elaborated successfully, the validity of the program depends on how ambiguity is resolved.

Fixed by change described in Appendix \ref{ext-syntaxfixes}.

\end{itemize}


Section 3.4 (Grammar for Modules), Figure 8 (Functors and Top-level Declarations):

\begin{itemize}

\item * Finally, another ambiguity exists for reducing a sequence $\mathit{strdec}_1\;\mathit{strdec}_2$ to a $\mathit{topdec}$: it can be done either by first reducing to $\mathit{strdec}$, or to $\mathit{strdec}_1\;\mathit{topdec}_2$. The latter is more restrictive with respect to free type variables (but see \ref{bugsappendixg} with regard to this).

Fixed by change described in Appendix \ref{ext-syntaxfixes}.

\end{itemize}

Altogether, ignoring the infinite number of derivations involving empty declarations, the grammar in the Definition allows three ambiguous ways to reduce a sequence of two $\mathit{dec}$s to a $\mathit{topdec}$, as shown by the following diagram. All imply different semantics. The corresponding diagram for a sequence of three declarations would merely fit on a page. A further ambiguity arises at the program level (see \ref{bugschapter8}).

\begin{center}
\psset{xunit=12mm,yunit=12mm,nodesep=3pt}
\begin{pspicture}(2,3.5)
  \rput(1,3.5){\rnode{decdec}{$\mathit{dec}_1\;\mathit{dec}_2$}}
  \rput(0,2.5){\rnode{dec}{$\mathit{dec}$}}
  \rput(2,2.5){\rnode{strdecstrdec}{$\mathit{strdec}_1\;\mathit{strdec}_2$}}
  \rput(0,1){\rnode{strdec}{$\mathit{strdec}$}}
  \rput(2,1){\rnode{strdectopdec}{$\mathit{strdec}_1\;\mathit{topdec}_2$}}
  \rput(1,0){\rnode{topdec}{$\mathit{topdec}$}}
  \ncline{-}{decdec}{dec}
  \ncline{-}{decdec}{strdecstrdec}
  \ncline{-}{dec}{strdec}
  \ncline{-}{strdecstrdec}{strdec}
  \ncline{-}{strdecstrdec}{strdectopdec}
  \ncline{-}{strdec}{topdec}
  \ncline{-}{strdectopdec}{topdec}
\end{pspicture}
\end{center}

All parsing ambiguities (except for ones involving empty declarations, which are harmless) are fixed by the changes described in Appendix \ref{ext-syntaxfixes}.


\subsection{Issues in Chapter 4 (Static Semantics for the Core)}
\label{bugschapter4}

Section 4.8 (Non-expansive Expressions):

\begin{itemize}
\item * The definition of non-expansiveness is purely syntactic and does only consider the right hand side of a binding. However, an exception may result from matching against a non-exhaustive pattern on the left hand side. It is rather inconsistent to disallow {\tt raise} expressions in non-expansive bindings but allow implicit exceptions in the disguise of pattern match failure. More seriously, the possibility of exceptions stemming from polymorphic bindings is incompatible with type passing implementations.

Fixed by change described in Appendix \ref{ext-monomorphism}.
\end{itemize}


Section 4.9 (Type Structures and Type Environments):

\begin{itemize}

\item The definition of the Abs operator demands introduction of ``new distinct'' type names. However, type names can only be new relative to a context. To be precise, Abs would thus need an additional argument $C$ \cite{addenda}.

Avoided by the change making {\tt abstype} a derived form, as described in Appendix \ref{ext-abstype}.

\item Values in {\tt abstype} declarations that are potentially polymorphic but require equality types have no principal type \cite{addenda}. For example, in the declaration

\begin{quote}
\begin{alltt}
abstype t = T with
    fun eq(x,y) = x = y
end
\end{alltt}
\end{quote}

the principal type of {\tt eq} {\em inside} the scope of {\tt abstype} clearly is {\tt ''a * ''a -> bool}. However, outside the scope this type is not principal because {\tt ''a} cannot be instantiated by {\tt t}. Neither would {\tt t * t -> bool} be principal, of course. Although not strictly a bug (there is nothing which enforces the presence of principal typings in the revised Definition), this semantics is very hard to implement faithfully, since type inference would have to deal with unresolved type schemes and to cascadingly defer decisions about instantiation and generalisation until the correct choice is determined.

Avoided by the change making {\tt abstype} a derived form, as described in Appendix \ref{ext-abstype}. Abstract types no longer hide equality.

\item A related problem is the fact that the rules for {\tt abstype} may infer type structures that do not respect equality \cite{addenda}:

\begin{quote}
\begin{alltt}
abstype t = T with
    datatype u = U of t
end
\end{alltt}
\end{quote}

Outside the scope of this {\tt abstype} declaration type {\tt u} will still be an equality type. Values of type {\tt t} can thus be compared through the backdoor:

\begin{quote}
\begin{alltt}
fun eqT(x,y) = U x = U y
\end{alltt}
\end{quote}

Avoided by the change making {\tt abstype} a derived form, as described in Appendix \ref{ext-abstype}. Abstract types no longer hide equality.

\end{itemize}


Section 4.10 (Inference Rules):

\begin{itemize}

\item * The comment to rule 26 states that a declaration like

\begin{quote}
\begin{alltt}
datatype t = T
val rec T = fn x => x
\end{alltt}
\end{quote}

is legal since $C+\mathit{VE}$ overwrites identifier status. However, this comment omits an important point: in the corresponding rule 126 of the dynamic semantics recursion is handled differently so that the identifier status is {\em not} overwritten. Consequently, the second declaration will raise a {\tt Bind} exception. It arguably is a serious ill-design to infer inconsistent identifier status in the static and dynamic semantics, but fortunately it does not violate soundness in this case. Most implementations do not implement the `correct' dynamic semantics, though.

Removed by the change described in Appendix \ref{ext-recursive}.

\item * There is an unmatched left parenthesis in the consequent of rule 28.

Fixed by change described in Appendix \ref{ext-semanticfixes}.

\void{
\item As an artefact of the treatment of type name generativity in the inference rules, the following expression is ill-typed according to the Definition \cite{mistakes}:

\begin{quote}
\begin{alltt}
let
    val r = ref NONE
    datatype t = C
in
    r := SOME C
end
\end{alltt}
\end{quote}

This behaviour is very tedious to implement and there is no real argument for forbidding such examples. Consequently, all SML implementation seem to allow it. Fixing this in favour of a more ``natural'' implementation of generativity would require getting rid of $\oplus$ composition and infer type name sets explicitly.

HaMLet deviates from the Definition in the same way.
}
\end{itemize}


Section 4.11 (Further Restrictions):

\begin{itemize}

\item (*) Under item 1 the Definition states that ``the program context'' must determine the exact type of flexible records, but it does not specify any bounds on the size of this context. Unlimited context is clearly infeasible since it is incompatible with {\tt let} polymorphism: at the point of generalisation the structure of a type must be determined precisely enough to know what we have to quantify over.\footnote{Alternatively, there are extensions to Hindley/Milner typing that allow quantification over the structure of records, but polymorphic records are clearly not supported by the Definition.}

Fixed by change described in Appendix \ref{ext-semanticfixes}.

Note that some SML systems implement a slightly more restrictive variant, in which the following program does not type-check:

\begin{quote}
\begin{alltt}
fun f(r as \{...\}) =
    [let fun g() = r in r end, r : \{a:int\}]
\end{alltt}
\end{quote}

while a minor variation of it does:

\begin{quote}
\begin{alltt}
fun f(r as \{...\}) =
    [r : \{a:int\}, let fun g() = r in r end]
\end{alltt}
\end{quote}

The reason is that they simply check for existence of unresolved record types in value environments to be closed, without taking into account that these types might stem from the context (in which case we know that we cannot quantify over the unknown bits anyway). As the above example shows, such an implementation compromises the compositionality of type inference. The Definition should rule it out somehow. A similar clarification is probably in order for overloading resolution (see \ref{bugsappendixe}).

\item Under item 2 the Definition demands that a compiler must give warnings whenever a pattern is redundant or a match is non-exhaustive. However, this requirement is inconsistent for two reasons:

\begin{enumerate}

\item * There is no requirement for consistency of datatype constructors in sharing specifications or type realisations. For example,

\begin{quote}
\begin{alltt}
datatype t = A | B
datatype u = C
sharing type t = u
\end{alltt}
\end{quote}

is a legal specification.  Likewise,

\begin{quote}
\begin{alltt}
sig datatype t = A | B end where type t = bool
\end{alltt}
\end{quote}

is valid. Actually, this may be considered a serious bug on its own, although the Definition argues that inconsistent signatures are ``not very significant in practice'' [Section G.9]. If such an inconsistent signature is used to specify a functor argument it allows a mix of constructors to appear in matches in the functor's body, rendering the terms of irredundancy and exhaustiveness completely meaningless.

There is no simple fix for this. HaMLet makes no attempt to detect this situation, so generation of warnings is completely arbitrary in this case.

\item (*) It is difficult in general to check equality of exception constructors -- they may or may not be aliased. Inside a functor, constructor equality might depend on the actual argument structure the functor is applied to. It is possible to check all this by performing abstract interpretation (such that redundant matches are detected at functor application), but this is clearly infeasible weighed against the benefits, in particular in conjunction with separate compilation.

In HaMLet we only flag exception constructors as redundant when they are denoted by the same syntactic $\mathit{longvid}$. We do not try to derive additional aliasing information.

\end{enumerate}

\end{itemize}


\subsection{Issues in Chapter 5 (Static Semantics for Modules)}
\label{bugschapter5}

Section 5.7 (Inference Rules):

\begin{itemize}
\item * The rules 64 and 78 use the notation $\{t_1\mapsto\theta_1,\cdots,t_n\mapsto\theta_n\}$ to specify realisations. However, this notation is not defined anywhere in the Definition for infinite maps like realisations -- [4.2] only introduces it for finite maps.

This is just a minor oversight, the intended meaning is obvious.

\item * More seriously, both rules lack side conditions to ensure consistent arities for domain and range of the constructed realisation. Because $\varphi$ can hence fail to be well-formed [5.2], the application $\varphi(E)$ is not well-defined. The necessary side conditions are:
\setcounter{equation}{63}
\begin{equation}
t \in \mbox{TyName}^{(k)}
\end{equation}
\setcounter{equation}{77}
\begin{equation}
t_i \in \mbox{TyName}^{(k)}, i = 1..n
\end{equation}

Fixed by change described in Appendix \ref{ext-semanticfixes}.

\item * The presence of functors provides a form of explicit polymorphism which interferes with principal typing in the core language. Consider the following example \cite{principalmodules}:

\begin{quote}
\begin{alltt}
functor F(type t) =
    struct val id = (fn x => x) (fn x => x) end
structure A = F(type t = int)
structure B = F(type t = bool)
val a = A.id 3
val b = B.id true
\end{alltt}
\end{quote}

The declaration of {\tt id} cannot be polymorphic, due to the value restriction. Nevertheless, assigning it type {\tt t -> t} would make the program valid. However,\void{ as Dreyer at al.\ note \cite{typeclasses},} finding this type would require the type inference algorithm to skolemize all undetermined types in a functor body's result signature over the types appearing in its argument signature, and then perform a form of higher-order unification. Consequently, almost all existing implementations reject the program.\footnote{Interestingly, MLton \cite{mlton} accepts the program, thanks to its defunctorization approach. However, it likewise accepts similar programs that are {\it not} valid Standard ML, e.g.:
\begin{quote}
\begin{alltt}
functor F() = struct val id = (fn x => x) (fn x => x) end\\
structure A = F()\\
structure B = F()\\
val a = A.id 3\\
val b = B.id true
\end{alltt}
\end{quote}
}

%It is not easy to change the semantics such that programs like the above are ruled out. This would require speaking about principality and undetermined types, but as we discuss in the next item, the formal framework of the Definition does not enable this.

HaMLet ignores this problem, rejecting the program due to a failure unifying types {\tt int} and {\tt bool}.

\item * The side conditions on free type variables in rules 87 and 89 do not have the effect that obviously was intended, see \ref{bugsappendixg}.

HaMLet not only tests for free type variables, but also for undetermined types (see \ref{typeinference}). This behaviour is not strictly conforming to the \emph{formal} rules of the Definition (which define a more liberal regime), but meets the actual intention explicitly stated in [G.8] and is consistent with HaMLet's goal to always implement the most restrictive reading.
\end{itemize}


\subsection{Issues in Chapter 6 (Dynamic Semantics for the Core)}
\label{bugschapter6}

Section 6.4 (Basic Values):

\begin{itemize}
\item The APPLY function has no access to program state. This suggests that library primitives may not be stateful, implying that a lot of interesting primitives could not be added to the language without extending the Definition itself \cite{mistakes}.

On the other hand, any non-trivial library type (e.g.\ arrays or I/O streams) requires extension of the definition of values or state anyway (and equality types -- consider {\tt array}). The Definition should probably contain a comment in this regard.

HaMLet implements stateful library types by either mapping them to references in the target language (e.g.\ arrays) or by maintaining the necessary state outside the semantic objects (see \ref{primtypes}).
\end{itemize}


\subsection{Issues in Chapter 7 (Dynamic Semantics for Modules)}
\label{bugschapter7}

Section 7.2 (Compound Objects):

\begin{itemize}

\item * In the definition of the operator $\downarrow:\mbox{Env}\times\mbox{Int}\to\mbox{Env}$, the triple ``$(\mathit{SI},\mathit{TE},\mathit{VI})$'' should read ``$(\mathit{SI},\mathit{TI},\mathit{VI})$''.

Fixed by change given in Appendix \ref{ext-semanticfixes}.

\end{itemize}


Section 7.3 (Inference Rules):

\begin{itemize}

\item * Rule 182 contains a typo: both occurrences of $\mathit{IB}$ have to be replaced by $B$.

Fixed by change described in Appendix \ref{ext-semanticfixes}.

\item * The rules for toplevel declarations are wrong: in the conclusions, the result right of the arrow must be $B' \langle+ B''\rangle$ instead of $B'\langle'\rangle$ in all three rules.

Fixed by change described in Appendix \ref{ext-semanticfixes}.

\end{itemize}


\subsection{Issues in Chapter 8 (Programs)}
\label{bugschapter8}

\begin{itemize}
\item (*) The comment to rule 187 states that a failing elaboration has no effect. However, it is not clear what infix status is in scope after a failing elaboration of a program that contains top-level infix directives.

HaMLet keeps the updated infix status.

\item * There is another syntactic ambiguity for programs. A note in [3.4, Figure 8] restricts the parsing of $\mathit{topdec}$s:

\begin{quote}
``No $\mathit{topdec}$ may contain, as an initial segment, a $\mathit{strdec}$ followed by a semicolon.''
\end{quote}

The intention obviously is to make parsing of toplevel semicolons unambiguous so that they always terminate a program. As a consequence of the parsing ambiguities for declaration sequences (see \ref{bugschapter3}) the rule is not sufficient, however: a sequence $\mathit{dec}_1\mbox{\tt;}\;\mathit{dec}_2\mbox{\tt;}$ of core level declarations with a terminating semicolon can be first reduced to $\mathit{dec}\mbox{\tt;}$, then to $\mathit{strdec}\mbox{\tt;}$, and finally $\mathit{program}$. This derivation does not exhibit an ``initial $\mathit{strdec}$ followed by a semicolon.'' Consequently, this is a valid parse, which results in quite different behaviour with respect to program execution.

Fixed by change described in Appendix \ref{ext-syntaxfixes}.

\item (*) The negative premise in rule 187 has unfortunate implications: interpreted strictly it precludes any conforming implementation from providing any sort of conservative semantic extension to the language. Any extension that allows declarations to elaborate that would be illegal according to the Definition (e.g.\ consider polymorphic records) can be observed through this rule and change the behaviour of consecutive declarations. Consider for example:

\begin{quote}
\begin{alltt}
val s = "no";
\(\mathit{strdec}\)
val s = "yes";
print s;
\end{alltt}
\end{quote}

where the $\mathit{strdec}$ only elaborates if some extension is supported. In that case the program will print {\tt yes}, otherwise {\tt no}.

This probably indicates that formalising an interactive toplevel is not worth the trouble.
\end{itemize}


\subsection{Issues in Appendix A (Derived Forms)}
\label{bugsappendixa}

Text:

\begin{itemize}
\item (*) The paragraph explaining rewriting of the $\mathit{fvalbind}$ form rules out mixtures of $\mathit{fvalbind}$s and ordinary $\mathit{valbind}$s. However, the way it is formulated it does not rule out all combinations. It should rather say that all value bindings of the form $\mathit{pat}\;\mbox{\tt=}\;\mathit{exp}\;{\tt and}\;\mathit{fvalbind}$ or ${\tt rec}\;\mathit{fvalbind}$ are disallowed.

HaMLet assumes this meaning.
\end{itemize}

Figure 15 (Derived forms of Expressions):

\begin{itemize}
\item The Definition is somewhat inaccurate about several of the derived forms of expressions and patterns. It does not make a proper distinction between atomic and non-atomic phrases. Some of the equivalent forms are not in the same syntactic class \cite{commentary, mistakes}.

We assume the necessary parentheses in the equivalent forms.
\end{itemize}


Figure 17 (Derived forms of Function-value Bindings and Declarations):

\begin{itemize}
\item The syntax of $\mathit{fvalbind}$s as given in the Definition enforces that all type annotations are syntactically equal, if given. This is unnecessarily restrictive and almost impossible to implement \cite{mistakes}.

Fixed by change described in Appendix \ref{ext-syntaxfixes}.
\end{itemize}


Figure 19 (Derived forms of Specifications and Signature Expressions):

\begin{itemize}
\item * The derived form that allows several definitional type specifications to be connected via {\tt and} is defined in a way that makes its scoping rules inconsistent with all other occurences of {\tt and} in the language. In the example

\begin{quote}
\begin{alltt}
type t = int
signature S =
sig
    type t = bool
    and  u = t
end
\end{alltt}
\end{quote}

type {\tt u} will be equal to {\tt bool}, not {\tt int} like in equivalent declarations.

Made consistent with the rest of the language by change described in Appendix \ref{ext-manifest}.

\item * The Definition defines the phrase

\begin{quote}
$\mathit{spec}$ {\tt sharing} $\mathit{longstrid}_1$ {\tt =} $\cdots$ {\tt =} $\mathit{longstrid}_n$
\end{quote}

as a derived form. However, this form technically is not a derived form, since it cannot be rewritten in a purely syntactic manner -- its expansion depends on the static environment.

HaMLet thus treats this form as part of the bare grammar. Unfortunately, it is surprisingly difficult to formulate a proper inference rule describing the intended static semantics of structure sharing constraints -- probably one of the reasons why it has been laxly defined as a derived form in the first place. The implementation simply collects all expanded type equations and calculates a suitable realisation incrementally. At least there is no need for a corresponding rule for the dynamic semantics, since sharing qualifications are omitted at that point.

\item * The derived form for type realisations connected by {\tt and} is not only completely redundant and alien to the rest of the language ({\tt and} is nowhere else followed by a second reserved word), it also is extremely tedious to parse, since this part of the grammar is LALR(2) as it stands. It can be turned into LALR(1) only by a bunch of really heavy transformations. Consequently, almost no SML system seems to be implementing it correctly. Even worse, several systems implement it in a way that leads to rejection of programs {\em not} using the derived form. For example,

\begin{quote}
\begin{alltt}
signature A = S where type t = u where type v = w
\end{alltt}
\end{quote}

or

\begin{quote}
\begin{alltt}
signature A = S where type t = u
and       B = T
\end{alltt}
\end{quote}

Removed by change described in Appendix \ref{ext-realisation}.

\item * For complex type declarations the {\tt withtype} derived form is important. With the introduction of equational type specifications in SML'97 it would have been natural to introduce an equivalent derived form for signatures. This is an oversight that most SML systems `correct'.

Added by the extension described in Appendix \ref{ext-withtype}.
\end{itemize}


\subsection{Issues in Appendix B (Full Grammar)}
\label{bugsappendixb}

Text:

\begin{itemize}
\item (*) The first sentence is not true since there is a derived form for programs [Appendix A, Figure 18]. Moreover, it is not obvious why the appendix refrains from also providing a full version of the module and program grammar. It contains quite a lot of derived forms as well, and the section title leads the reader to expect it.

First issue fixed by change described in Appendix \ref{ext-syntaxfixes}.

\item The Definition gives precedence rules for disambiguating expressions, stating that ``the use of precedence does not increase the class of admissible phrases''. However, the rules are not sufficient to disambiguate all possible phrases. Moreover, for some phrases they actually rule out {\em any} possible parse, e.g.

\begin{quote}
\begin{alltt}
a andalso if b then c else d orelse e
\end{alltt}
\end{quote}

has no valid parse according to these rules. So the above statement is rather inconsistent \cite{mistakes}.

Fixed by change described in Appendix \ref{ext-syntaxfixes}.

\item There is no comment on how to deal with the most annoying problem in the full grammar, the infinite look-ahead required to parse combinations of function clauses and {\tt case} expressions, like in:

\begin{quote}
\begin{alltt}
fun f x = case e1 of z => e2
  | f y = e3
\end{alltt}
\end{quote}

According to the grammar this ought to be legal. However, parsing this would either require horrendous grammar transformations, backtracking, or some nasty and expensive lexer hack \cite{mistakes}. Consequently, there is no SML implementation being able to parse the above fragment.

Ruled out by change described in Appendix \ref{ext-syntaxfixes}.
\end{itemize}


Figure 21 (Grammar: Declarations and Bindings):

\begin{itemize}
\item The syntax given for $\mathit{fvalbind}$ is incomplete as pointed out by the corresponding note. This is not really a bug but annoyingly sloppy enough to cause some divergence among implementations.

Fixed by change described in Appendix \ref{ext-syntaxfixes}.
\end{itemize}


Figure 22 (Grammar: Patterns):

\begin{itemize}
\item While there are additional non-terminals $\mathit{infexp}$ and $\mathit{appexp}$ to disambiguate parsing of infix expressions, there is no such disambiguation for patterns. This implies that a pattern like {\tt x:t ++ y} can be parsed if {\tt ++} is an appropriate infix constructor \cite{addenda}. Of course, this would result in heavy grammar conflicts.

Disambiguated by change described in Appendix \ref{ext-syntaxfixes}.
\end{itemize}


\subsection{Issues in Appendix D (The Initial Dynamic Basis)}
\label{bugsappendixd}

\begin{itemize}

\item (*) The Definition does specify the minimal initial basis but it does not specify what the initial state has to contain. Of course, it should at least contain the exception names {\tt Match} and {\tt Bind}.

Fixed by change described in Appendix \ref{ext-semanticfixes}.

\item The Definition does nowhere demand that the basis a library provides has to be consistent in any way. Nor does it require consistency between initial basis and initial state.

The HaMLet library is consistent, of course.
\end{itemize}


\subsection{Issues in Appendix E (Overloading)}
\label{bugsappendixe}

Overloading is the most hand-waving part of the otherwise pleasantly accurate Definition. Due to the lack of formalism and specific rules, overloading resolution does not work consistently among SML systems. For example, type-checking of the following declaration does not succeed on all systems:

\begin{quote}
\begin{alltt}
fun f(x,y) = (x + y)/y
\end{alltt}
\end{quote}

The existence of overloading destroys an important property of the language, namely the independence of static and dynamic semantics, as is assumed in the main body of the Definition. For example, the expressions

\begin{quote}
\begin{alltt}
2 * 100    {\rm and}    2 * 100 : Int8.int
\end{alltt}
\end{quote}

will have very different dynamic behaviour, although they only differ in an added type annotation.

The Definition defines the overloading mechanism by enumerating all overloaded entities the library provides. This is rather unfortunate. It would be desirable if the rules would be a bit more generic, avoiding hardcoding overloading classes and the set of overloaded library identifiers on one hand, and allowing libraries to extend it in systematic ways on the other. More generic rules could also serve as a better guidance for implementing overloading (see \ref{overloading} for a suitable approach).

% A suitable approach might be the following. An overloading class can be formalised as a pair of its type name set and the type name being the designated default:
%
%\begin{displaymath}
%(T,t) \in \mbox{OverloadingClass} = \mbox{Fin}(\mbox{TyName}^{(0)}) \times \mbox{TyName}^{(0)}
%\end{displaymath}
%
% The following properties then must hold for all pairs of basic or composite overloading classes $(T,t)$, $(T',t')$ appearing in an initial basis:
%
%\begin{enumerate}
%\item $t \in T$
%\item $\mbox{Eq}(T) = \emptyset \quad\vee\quad \mbox{$t$ admits equality}$
%\item $T \cap T' = \emptyset \quad\vee\quad |\{t,t'\} \cap T \cap T'| = 1$
%\end{enumerate}
%
%where $\mbox{Eq}(T) = \{ t \in T \;|\; \mbox{$t$ admits equality} \}$.
%
%These restrictions guarantuee that intersection of overloading classes is reflexive, associative and commutative with respect to the default and that there always is a unique default. We assert that these properties are important to make defaulting unambiguous and enable a feasible type inference algorithm (see \ref{overloading} for details). A library can provide arbitrary overloading classes, as long as they adhere to these restrictions. These properties hold for the minimal initial basis given in the Definition.

The canonical way to deal with overloaded constants and value identifiers is to uniformingly assign an extended notion of type scheme that allows quantification to be constrained by an overloading class. Constraints would have to be verified at instantiation. This is more or less what has been implemented in HaMLet (see \ref{overloading} for a suitable approach).

There are some more specific issues as well:

\begin{itemize}

\item * The Definition forgets to demand that any extension of a basic overloading class is consistent with respect to equality.

Fixed by change described in Appendix \ref{ext-semanticfixes}.

Our formalisation includes such a restriction (see \ref{overloading}).

\item * That the Definition specifies an {\em upper} bound on the context a compiler may consider to resolve overloading is quite odd -- of course, implementations cannot be prohibited to conservatively extend the language by making more programs elaborate. On the other hand, much more important would have been to specify a {\em lower} bound on what implementations {\em have to} support -- it is clearly not feasible to force the programmer to annotate every individual occurence of an overloaded identifier or special constant.

Fixed by change described in Appendix \ref{ext-semanticfixes}.


\end{itemize}

Figure 27 (Overloaded Identifiers):

\begin{itemize}
\item * The types for the comparison operators {\tt<}, {\tt>}, {\tt<=}, and {\tt>=} must correctly be ${\tt numtxt} \times {\tt numtxt} \to {\tt bool}$.

Fixed by change described in Appendix \ref{ext-semanticfixes}.
\end{itemize}



\subsection{Issues in Appendix G (What's New?)}
\label{bugsappendixg}

Section G.8 (Principal Environments):

* At the end of the section the authors explain that the intent of the restrictions on free type variables at the toplevel (side-conditions in rules 87 and 89 [5.7]) is to avoid reporting free type variables to the user. However, judging from the rest of the paragraph, this reasoning confuses two notions of type variable: type variables as semantic objects, as appearing in the formal rules of the Definition, and the yet undetermined types during Hindley/Milner type inference, which are also represented by type variables. However, both kinds are variables on completely different levels: the former are part of the formal framework of the Definition, while the latter are an `implementation aspect' that lies outside the scope of the Definition's formalism. Let us distinguish both by referring to the former as {\em semantic type variables} and to the latter as {\em undetermined types} (the HaMLet implementation makes the same distinction, in order to avoid exactly this confusion, see \ref{types}).

The primary purpose of the aforementioned restrictions obviously is to avoid reporting {\em undetermined types} to the user. However, they fail to achieve that. In fact, it is impossible to enforce such behaviour within the formal framework of the Definition, since it essentially would require formalising type inference (the current formalism has no notion of undetermined type). Consequently, the comment in Section G.8 about the possibility of relaxing the restrictions by substituting arbitrary monotypes misses the point as well.

In fact, the formal rules of the Definition actually imply the exact opposite, namely that an implementation may {\em never} reject a program that results in undetermined types at the toplevel, and is thus compelled to report them. The reason is explicitly given in the same section: ``implementations should not reject programs for which successful elaboration is possible''. Consider the following program:

\begin{quote}
\begin{alltt}
val r = ref nil;
r := [true];
\end{alltt}
\end{quote}

Rule 2 has to non-deterministically choose some type $\tau\;{\tt list}$ for the occurrence of {\tt nil}. The choice of $\tau$ is not determined by the declaration itself: it is not used, nor can it be generalised, due to the value restriction. However, {\tt bool} is a perfectly valid choice for $\tau$, and this choice will allow the entire program to elaborate. So according to the quote above, an implementation has to make exactly that choice. Now, if both declarations are entered separately into an interactive toplevel the implementation obviously has to defer commitment to that choice until it has actually seen the second declaration. Consequently, it can do nothing else but reporting an undetermined type for the first declaration. The only effect the side conditions in rules 87 and 89 have on this is that the types committed to later may not contain free semantic type variables -- but considering the way such variables are introduced during type inference (mainly by generalisation), the only possibility for this is through a toplevel exception declaration containing a type variable.\footnote{(*) Note that this observation gives rise to the question whether the claim about the existence of principal environments in Section 4.12 of the SML'90 Definition \cite{definition90} was valid in the first place. It most likely was not: a declaration like the one of {\tt r} has no principal environment that would be expressible within the formalism of the Definition, despite allowing different choices of free imperative type variables. The reasoning that this relaxation was sufficient to regain principality is based on the same mix-up of semantic type variables and undetermined types as above. The relaxation does not solve the problem with expansive declarations, since semantic type variables are rather unrelated to it -- choosing a semantic type variable for an undetermined type is no more principal than choosing any particular monotype.}

There are two possibilities of dealing with this matter: (1) take the formal rules as they are and ignore the comment in the appendix, or (2) view the comment as an informal ``further restriction'' and fix its actual formulation to match the obvious intent.
Since version 1.1.1 of HaMLet, we implement the intended meaning and disallow undetermined types on the toplevel, although this technically is a violation of the formal rules.
%Since the comments in appendix G are not supposed to be a normative part of the Definition but merely explanatory, and moreover are somewhat inconsistent, we give the formal rules priority and go for option (1).\footnote{Unfortunately, this interpretation is incompatible with implementation strategies relying on type passing, where all types must be determined prior to execution.} To report undetermined types to the user, we use a notation that is slightly different from the one denoting real type variables (see \ref{usingstandalone}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Language Changes}
\label{extensions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this appendix we describe all modifications and extensions to the Definition that are implemented in this version of HaMLet. Most of them have already been proposed for Successor ML and are taken from the discussion Wiki~\cite{successorml}. These can be put in two groups:

Fixes and simplifications:
\begin{itemize}
\setlength{\itemsep}{0em}
\item Syntax fixes
\item Semantic fixes
\item Monomorphic non-exhaustive bindings
\item Simplified recursive value bindings
\item Abstype as derived form
\item Fixed manifest type specifications
\item Abolish sequenced type realisations
\end{itemize}

Extensions:
\begin{itemize}
\setlength{\itemsep}{0em}
\item Line comments
\item Extended literal syntax
%\item Vector syntax?
\item Record punning
\item Record extension
\item Record update
\item Conjunctive patterns
\item Disjunctive patterns
\item Nested matches
\item Pattern guards
\item Transformation patterns
%\item Finally
%\item Exceptional syntax
\item Optional bars and semicolons
\item Optional else branch
%\item Optional op keywords?
\item Views
\item Do declarations
%\item Declarations in sequential expressions?
%\item Monad syntax?
%\item Extensional datatypes?
\item Withtype in signatures
%\item Manifest structures ("structure strid : sigexp = longstrid", "sigexp where longstrid = strexp")
%\item Local specifications? ("let dec in sigexp end", "local dec in spec end")
%\item Fixity specifications?
\item Higher-order functors
\item Nested signatures
\item Local modules
\item First-class modules
\end{itemize}

Examples demonstrating some of the more involved extensions in detail can be found in the {\tt doc/examples} directory of the distribution.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Syntax Fixes}
\label{ext-syntaxfixes}

The syntax specification in the Definition is somewhat sloppy, leaving a number of ambiguities and minor issues. We provide the details to resolve the relevant ones. Mostly, these just blesses existing practice in SML implementations. See Appendix \ref{definitionbugs} for a motivation and detailed discussion of the issues.

\subsubsection*{Changes to the Definition}

Section 2.2 (Special constants):
\begin{itemize}
\item In the paragraph defining formatting characters, add carriage return and vertical tab to the list of non-printable characters included.
\end{itemize}

Section 2.6 (Infixed operators):
\begin{itemize}
\item In the 1st paragraph, extend the sentence starting with ``The only required use of {\tt op}...'' by inserting the following before the semicolon:
  \begin{quote}
 [...] in an expression or pattern;
  \end{quote}
\end{itemize}

\void{
Section 2.9 (Syntactic Restrictions):
\begin{itemize}
\item Add the following bullet: 
  \begin{quote}
  Any $\mathit{tyvar}$ occurring on the right side of a $\mathit{typbind}$ or $\mathit{datbind}$ of the form ``$\mathit{tyvarseq}$ $\mathit{tycon}$ {\tt=} \dots'' must occur in $\mathit{tyvarseq}$.
  \end{quote}
\end{itemize}
}

Section 3.4 (Grammar for Modules):
\begin{itemize}
\item In Figure 6, add the following note:
  \begin{quote}
  Restriction: A declaration $\mathit{dec}$ appearing in a structure declaration may not be a sequential or local declaration.
  \end{quote}

\item In Figure 7, add the following note:
  \begin{quote}
  Restriction: In a sequential specification, $\mathit{spec}_2$ may not contain a sharing specification.
  \end{quote}

\item In Figure 8, extend the restriction with the following sentence:
  \begin{quote}
  Furthermore, the $\mathit{strdec}$ may not be a sequential declaration $\mathit{strdec}_1~\langle\mbox{\tt;}\rangle~\mathit{strdec}_2$.
  \end{quote}
\end{itemize}

Section 8 (Programs):
\begin{itemize}
\item Extend the comment on rule 187:
  \begin{quote}
 [...], except for possible fixity directives contained in the $\mathit{topdec}$.
  \end{quote}
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 17, add respective indices $1..m$ to the $\mathit{ty}$ annotations appearing on both sides of the definition of the function value binding form.
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item Extend the first sentence as follows: 
  \begin{quote}
 [...], together with the derived form of Figure 18 in Appendix A.
  \end{quote}

\item Add the following to the third paragraph:
  \begin{quote}
  The same applies to patterns, where the extra classes AppPat and InfPat are introduced, yielding
  $$
  \mbox{AtPat} \subset \mbox{AppPat} \subset \mbox{InfPat} \subset \mbox{Pat}
  $$
  \end{quote}

\item In the third bullet, replace the paragraph starting with ``Note particularly that...'' with:
  \begin{quote}
  Note that the use of precedence does not prevent a phrase, which is an instance of a form with higher precedence, having a constitutent which is an instance of a form
  with lower precendence, as long as they can be resolved unambiguously. Thus for example
  \begin{quote}
  \begin{alltt}
  if \(\dots\) then while \(\dots\) do \(\dots\) else while \(\dots\) do \(\dots\)
  \end{alltt}
  \end{quote}
  is quite admissible and parses as
  \begin{quote}
  \begin{alltt}
  if \(\dots\) then (while \(\dots\) do \(\dots\)) else (while \(\dots\) do \(\dots\))
  \end{alltt}
  \end{quote}
  However, precedence rules out phrases which cannot be disambiguated without violating precedence, such as
  \begin{quote}
  \begin{alltt}
  a andalso if b then c else d orelse e
  \end{alltt}
  \end{quote}
  \end{quote}
This change should allow the use of simple precedence rules as provided by Yacc to disambiguate parsing.

\item In Figure 21,\void{ in the production for $\mathit{fvalbind}$, add indices $1..m$ to the optional $\mathit{ty}$ annotations.} replace the production for $\mathit{fvalbind}$ with the following productions:
\begin{displaymath}
\begin{array}{lcll}
\mathit{fvalbind} &::=& \mathit{fmatch} \;
	\langle{\tt{and}} \; \mathit{fvalbind}\rangle \\
\mathit{fmatch} &::=& \mathit{fmrule} \;
	\langle\mbox{\tt|} \; \mathit{fmatch}\rangle \\
\mathit{fmrule} &::=& \mathit{fpat} \;
	\langle\mbox{\tt:} \; \mathit{ty}\rangle \; \mbox{\tt=} \; \mathit{exp} \\
\mathit{fpat} &::=& \langle{\tt{op}}\rangle \mathit{vid} \;
	\mathit{atpat}_1 \; \cdots \; \mathit{atpat}_n & n\geq1 \\
&& \mbox{\tt(}\mathit{atpat}_1 \; \mathit{vid} \; \mathit{atpat}_2\mbox{\tt)} \;
	\mathit{atpat}_3 \; \cdots \; \mathit{atpat}_n & n\geq3 \\
&& \mathit{atpat}_1 \; \mathit{vid} \; \mathit{atpat}_2
\end{array}
\end{displaymath}
Furthermore, add the following note:
  \begin{quote}
  Restriction: The expressions $\mathit{exp}_1,\dots,\mathit{exp}_{m-1}$ in a $\mathit{fvalbind}$ may not terminate in a match.
  \end{quote}

\item In Figure 22, replace the productions for pat with the following: 
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l@{\qquad}l}
  \mathit{apppat} & ::= & \mathit{atpat} \\
  && \langle{\tt{op}}\rangle\mathit{longvid}~\mathit{atpat} & \textrm{constructed value} \\
  \\
  \mathit{infpat} & ::= & \mathit{apppat} \\
  && \mathit{infpat}_1~\mathit{vid}~\mathit{infpat}_2 & \textrm{constructed value (infix)} \\
  \\
  \mathit{pat} & ::= & \mathit{infpat} \\
  && \mathit{pat}~\mbox{\tt:}~\mathit{ty} & \textrm{typed} \\
  && \langle{\tt{op}}\mathit{vid}~\langle\mbox{\tt:}~\mathit{ty}\rangle~{\tt{as}}~\mathit{pat} & \textrm{layered}
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

These are merely fixes, they do not change the language beyond resolving ambiguities. The only exception is the restriction on nesting matches in a $\mathit{fvalbind}$, which is what all SML systems implement anyway.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Semantic Fixes}
\label{ext-semanticfixes}

The Definition contains a number of bugs in inference rules and other parts of the formal semantics. Some of them undermine soundness, some are just plain typos. The changes we propose merely plug these holes and bless existing practice, they should not have any further effect on the defined language. See Appendix \ref{definitionbugs} for motivation and detailed discussion of the issues.

Note: Along with the changes described in the following sections, the only known (non-pedantic) issue remaining is the lack of a requirement for type sharing to be consistent with respect to the involved constructor environments, which makes exhaustiveness and irredundancy of patterns an ill-defined concept. No straightforward fix seems to exist within the Definition's formal framework, short of introducing a global consistency requirement similar to SML'90.

\subsubsection*{Changes to the Definition}

Section 2.9 (Syntactic Restrictions):
\begin{itemize}
\item Add the following bullet:
  \begin{quote}
  Any $\mathit{tyvar}$ occurring on the right side of a $\mathit{typbind}$ or $\mathit{datbind}$ of the form ``$\mathit{tyvarseq}$ $\mathit{tycon}$ {\tt=} \dots'' must occur in $\mathit{tyvarseq}$.
  \end{quote}
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item Add a closing parenthesis to the conclusion of Rule 28.
\end{itemize}

Section 4.11 (Further Restrictions):
\begin{itemize}
\item In the first bullet, in the first sentence change ``the program context'' to 
  \begin{quote}
 [...] the program context consisting of the smallest enclosing declaration
  \end{quote}
\end{itemize}

Section 5.7 (Inference Rules):
\begin{itemize}
\item Add the following side condition to rule 64:
  $$
  t \in \mbox{TyName}^{(k)}
  $$

\item Add the following side condition to rule 78:
  $$
  t_i \in \mbox{TyName}^{(k)}, i = 1..n
  $$
\end{itemize}

Section 7.2 (Compound Objects):
\begin{itemize}
% not in Wiki yet!
\item In the definition of the operator $\downarrow:\mbox{Env}\times\mbox{Int}\to\mbox{Env}$, replace the triple ``$(\mathit{SI},\mathit{TE},\mathit{VI})$'' with ``$(\mathit{SI},\mathit{TI},\mathit{VI})$''.
\end{itemize}

Section 7.3 (Inference Rules):
\begin{itemize}
\item In rule 182, replace both occurences of $\mathit{IB}$ with $B$.

\item In the conclusion of rules 184--186, replace $B'\langle'\rangle$ with $B' \langle+ B\rangle$.
\end{itemize}

Appendix D (The Initial Dynamic Basis):
\begin{itemize}
\item Add the following paragraph:
  \begin{quote}
  Furthermore, the initial state is defined by
  $$
  s_0 = (\{\}, \{{\tt Match}, {\tt Bind}\})
  $$
  \end{quote}
\end{itemize}

Appendix E (Overloading):
\begin{itemize}
\item In the last paragraph of the introduction, change the last sentence to: 
  \begin{quote}
  For this purpose, the surrounding text is the smallest enclosing declaration.
  \end{quote}
\end{itemize}

Appendix E.1 (Overloaded special constants):
\begin{itemize}
\item Before the sentence starting with ``Special constants...'', insert the following sentence:
  \begin{quote}
  The class Real may not contain type names that admit equality.
  \end{quote}
\end{itemize}

Appendix E.2 (Overloaded value identifiers):
\begin{itemize}
\item In Figure 27, change the types of {\tt<}, {\tt>}, {\tt<=}, {\tt>=} to:
  \begin{quote}
  \begin{alltt}
  numtxt * numtxt -> bool
  \end{alltt}
  \end{quote}
\end{itemize}

\subsubsection*{Compatibility}

These are merely fixes, they do not change the language beyond plugging holes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Monomorphic Non-exhaustive Bindings}
\label{ext-monomorphism}

In order maintain to soundness of polymorphic typing in the presence of effects, polymorphism is restricted to non-expansive bindings. Non-expansiveness is a syntactic condition on expressions that is sufficient to guarantee absence of effects (including exceptions) during their evaluation.

However, an exception may still occur if the pattern in the binding is not exhaustive. That behaviour is somewhat inconsistent, and more importantly, unnecessarily complicates typed compilation schemes, like used by several SML compilers (see Appendix~\ref{bugschapter4}).

Non-exhaustive patterns are ruled out in polymorphic bindings. That is, pathological programs like
\begin{quote}
\begin{alltt}
val x::xs = []
\end{alltt}
\end{quote}
but also
\begin{quote}
\begin{alltt}
val x::xs = [NONE, NONE]
\end{alltt}
\end{quote}
are no longer valid. Such declarations are rather useless, and can easily be rewritten.

\subsubsection*{Changes to the Definition}

Section 4.8 (Non-expansive Expressions):
\begin{itemize}
\item Change the rules for obtaining $\alpha^{(k)}$ to:
  $$
  \alpha^{(k)} = \left\{
    \begin{array}{ll}
    \mbox{tyvars}\, \tau \setminus \mbox{tyvars}\, C,  & \textrm{if $\mathit{pat}$ exhaustive and $\mathit{exp}$ non-expansive in $C$;} \\
    (), & \textrm{otherwise.}
    \end{array} \right.
  $$

\item Add the following sentence:
  \begin{quote}
  A pattern is \emph{exhaustive} if it matches all values (of the right type, cf. Section 4.11).
  \end{quote}
\end{itemize}

\subsubsection*{Compatibility}

This is not a conservative change, but very unlikely to break any practical program. It is already implemented in SML/NJ and TILT.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simplified Recursive Value Bindings}
\label{ext-recursive}

The current syntax for recursive value declarations allows many phrases that are either useless or confusing. For example,
\begin{quote}
\begin{alltt}
val rec rec rec f = fn x => x
val f = fn x => x and rec g = fn x => f x
\end{alltt}
\end{quote}
Note that in the latter declaration, the right-hand side of {\tt g} does not refer to the {\tt f} of the same declaration.

The syntax can be simplified by only allowing {\tt rec} directly after the {\tt val} keyword.

Furthermore, the Definition currently allows recursive value declarations to overwrite identifier status. This is inconsistent with the rules of the dynamic semantics, and hence arguably a bug (see Appendix~\ref{bugschapter6}). It also is counter-intuitive and a nuisance to implement (no implementation does it "correctly"). This possibility is removed.
The change is simplified by reversing the order of the {\tt rec} keyword and an eventual type variable sequence in a value declaration.

\subsubsection*{Changes to the Definition}

Section 2.8 (Grammar):
\begin{itemize}
\item In Figure 4, replace the production for value declarations with:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{dec} ::=] & {\tt{val}}~\langle{\tt{rec}}\rangle~\mathit{tyvarseq}~\mathit{valbind} & \textrm{value declaration}
  \end{array}
  $$

\item Remove the second production for $\mathit{valbind}$.
\end{itemize}

Section 2.9 (Syntactic Restrictions):
\begin{itemize}
\item In the 4th bullet, replace the start of the sentence with:
  \begin{quote}
  For each value binding $\mathit{pat}$ {\tt=} $\mathit{exp}$ in a value declaration with {\tt rec}, [\dots]
  \end{quote}
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item Change rule 15 to: 
%   U = tyvars(tyvarseq)    <tynames VE \subseteq T of C>
%   <forall vid in Dom VE, vid notin Dom C or is of C(vid) = v>
%   C + U <+ VE> |- valbind => VE    VE' = Clos_C,valbind VE    U \cap tyvars VE' = 0
%   ---------------------------------------------------------------------------------   (15)
%                   C |- val <rec> tyvarseq valbind => VE' in Env
  \begin{equation}
  \tag{15}
  \frac{
  \begin{array}{@{}l@{}}
  U = \mbox{tyvars}(\mathit{tyvarseq})
  \qquad
  \langle \mbox{tynames}\,\mathit{VE} \subseteq \mbox{$T$ of $C$} \rangle
  \\
  \langle \forall\mathit{vid} \in \mbox{Dom}\;\mathit{VE},~\mathit{vid} \notin \mbox{Dom}\;C~\mbox{or $\mathit{is}$ of $C(\mathit{vid}) = {\tt v}$}\rangle
  \\
  C+U\langle+\mathit{VE}\rangle \vdash \mathit{valbind} \Rightarrow \mathit{VE}
  \qquad
  \mathit{VE}' = \mbox{Clos}_{C,\mathit{valbind}}\mathit{VE}
  \qquad
  U \cap \mbox{tyvars}\,\mathit{VE}' = \emptyset
  \end{array}
  }{
  C \vdash {\tt{val}}~\langle{\tt{rec}}\rangle~\mathit{tyvarseq}~\mathit{valbind} \Rightarrow \mbox{$\mathit{VE}'$ in Env}
  }
  \end{equation}

\item Remove rule 26. Add the respective comment to the comment on rule 15, but replace the last two sentences with the following: 
  \begin{quote}
  The side condition on the value identifiers in $C$ ensures that $C + \mathit{VE}$ does not overwrite identifier status in the recursive case. For example, the program
  ``{\tt{datatype t = f; val rec f = fn x => x;}}'' is not legal.
  \end{quote}
\end{itemize}

Section 6.6 (Function Closure):
\begin{itemize}
\item In the second paragraph, replace ``recursive value bindings of the form {\tt rec} $\mathit{valbind}$'' with ``recursive value declarations of the form {\tt val} {\tt rec} $\mathit{valbind}$''.
\end{itemize}

Section 6.7 (Inference Rules):
\begin{itemize}
\item Change rule 114 to: 
%                 E |- valbind => VE
% -------------------------------------------------    (114)
% E |- val <rec> tyvarseq valbind => <Rec>VE in Env
  \begin{equation}
  \tag{114}
  \frac{
  E \vdash \mathit{valbind} \Rightarrow \mathit{VE}
  }{
  E \vdash {\tt{val}}~\langle{\tt{rec}}\rangle~\mathit{tyvarseq}~\mathit{valbind} \Rightarrow \mbox{$\langle\mbox{Rec}\rangle\mathit{VE}$ in Env}
  }
  \end{equation}

\item Remove rule 126.
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In the third paragraph, replace ``{\tt{val}} $\mathit{tyvarseq}$ {\tt rec} $\mathit{valbind}$'' with ``{\tt{val}} {\tt rec} $\mathit{tyvarseq}$ $\mathit{valbind}$''.

\item In Figure 17, the box for declarations, replace the transformed form of function declarations with:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{fun}}~\mathit{tyvarseq}~\mathit{fvalbind}~~~
  & {\tt{val}}~{\tt{rec}}~\mathit{tyvarseq}~\mathit{fvalbind} \\
  \hline
  \end{array}$
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 21, replace the production for value declarations with:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{dec} ::=] & {\tt{val}}~\langle{\tt{rec}}\rangle~\mathit{tyvarseq}~\mathit{valbind} & \textrm{value declaration}
  \end{array}
  $$

\item Remove the second production for $\mathit{valbind}$.
\end{itemize}

\subsubsection*{Compatibility}

The change intentionally rules out some previously legal programs and reverses the order in which the {\tt rec} keyword and the optional type variable sequence may appear in a value declaration. However, at least one major SML implementation - namely SML/NJ - always implemented the revised syntax, so the change is unlikely to affect existing programs.

No current implementation follows the Definition with respect to overwriting of identifier status (although they deviate in different ways). Consequently, this part of the change is even less likely to affect existing programs.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Abstype as Derived Form}
\label{ext-abstype}

Abstype is a leftover from SML's pre-module days and is now fully subsumed by structures and sealing. Besides being redundant, the current specification of abstype is incoherent with respect to equality (see Appendix \ref{bugschapter4}), an issue for which no obvious fix exists.

Although abstype is practically unused in modern code, it cannot be removed without breaking backwards compatibility. Turning it into a derived form avoids this problem, while still simplifying the bare language and resolving the coherence issues.

\subsubsection*{Changes to the Definition}

Section 2.8 (Grammar):
\begin{itemize}
\item In Figure 4, remove the production for {\tt abstype}.
\end{itemize}

Section 4.9 (Type Structures and Type Environments):
\begin{itemize}
\item Remove the last paragraph.
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item Remove Rule 19 and the corresponding comments.
\end{itemize}

Section 6.7 (Inference Rules):
\begin{itemize}
\item Remove Rule 118.
\end{itemize}

Appendix A (Dervied Forms):
\begin{itemize}
\item In Figure 17, add the following rewriting rule before the existing one for {\tt abstype}:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{abstype}}~\mathit{datbind}~{\tt{with}}~\mathit{dec}~{\tt{end}}~~~~
  & {\tt{local}}~{\tt{datatype}}~\mathit{datbind}~{\tt{in}}~~ \\
  & ~~~~~{\tt{type}}~\mathit{typbind}'~\mbox{\tt;}~\mathit{dec} \\
  & {\tt{end}} \\
  \hline
  \end{array}$
  \end{quote}
  and extend the note to 
  \begin{quote}
  (see note in text concerning $\mathit{datbind}'$ and $\mathit{typbind}'$)
  \end{quote}

\item In the bullet list in the text referring to Figure 17, add the following item: 
  \begin{quote}
  In the abstype form, $\mathit{typbind}'$ is obtained from $\mathit{datbind}$ by replacing all right-hand sides by the corresponding left-hand side, i.e.\ ``$\mathit{tyvarseq}$ $\mathit{tycon}$ {\tt=} $\mathit{conbind}$ $\langle${\tt|} $\mathit{datbind}\rangle$'' becomes ``$\mathit{tyvarseq}$ $\mathit{tycon}$ {\tt=} $\mathit{tyvarseq}$ $\mathit{tycon}$ $\langle${\tt|} $\mathit{typbind}'\rangle$'' 
  \end{quote}

\end{itemize}

\subsubsection*{Compatibility}

This is a conservative change. The new specification is slightly more permissive than the original static semantics of {\tt abstype}, because the equality attribute of the defined type is no longer hidden. However, this is precisely what is necessary to fix the aforementioned coherence issues.

While the change may marginally affect the abstraction properties of code still using abstype, it can be argued that the obsolete nature of {\tt abstype} makes this neglectable in practice.

The change simplifies implementations, because it enables them to isolate their treatment of {\tt abstype} in the parser.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Fixed Manifest Type Specifications}
\label{ext-manifest}

For technical reasons, manifest type specifications are defined as a derived form. However, the definition of this form results in scoping rules that are at odds with the rest of the language (see Appendix \ref{bugsappendixa}). The definition of the derived form is changed to eliminate the singularity.

\subsubsection*{Changes to the Definition}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 19, replace the first two rules with the following one:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{type}}~\mathit{tyvarseq}_1~\mathit{tycon}_1~\mbox{\tt=}~\mathit{ty}_1
  & {\tt{include}} \\
  ~~{\tt{and}}~\dots
  & ~~~{\tt{sig}}~{\tt{type}}~\mathit{tyvarseq}_1~\mathit{tycon}_1 \\
  ~~\dots
  & ~~~~~~~~~~~~{\tt{and}}~\dots \\
  ~~{\tt{and}}~\mathit{tyvarseq}_n~\mathit{tycon}_n~\mbox{\tt=}~\mathit{ty}_n
  & ~~~~~~~~~~~~\dots \\
  & ~~~~~~~~~~~~{\tt{and}}~\mathit{tyvarseq}_n~\mathit{tycon}_n \\
  & ~~~{\tt{end}}~{\tt{where}}~{\tt{type}}~\mathit{tyvarseq}_1~\mathit{tycon}_1~\mbox{\tt=}~\mathit{ty}_1 \\
  & ~~~~~~~~~~{\tt{where}}~{\tt{type}}~\dots \\
  & ~~~~~~~~~~\dots \\
  & ~~~~~~~~~~{\tt{where}}~{\tt{type}}~\mathit{tyvarseq}_n~\mathit{tycon}_n~\mbox{\tt=}~\mathit{ty}_n \\
  \hline
  \end{array}$
  \end{quote}
\end{itemize}

\subsubsection*{Compatibility}

This change breaks programs relying on the current scoping rules. However, since these rules are rather counter-intuitive, not implemented by all SML implementations (Moscow ML and Poly/ML deviate), and they make using {\tt and} in type specifications pointless anyway, we expect those programs to be rare. It is trivial to adapt them to the change.

Only few SML implementations actually implement manifest type specifications as a derived form. The change hence should be a simplification for the majority of implementations, as it removes an annoying singularity in the language rules.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Abolish Sequenced Type Realisations}
\label{ext-realisation}

The SML syntax allows several type constraints on a signature to be connected with {\tt and}, as in
\begin{quote}
\begin{alltt}
S where type t1 = ty1
    and type t2 = ty2
\end{alltt}
\end{quote}
This syntax is hard to parse and only few implementations bother to do it correctly, it is at odds with the rest of the language, and it is useless, because writing another {\tt where} instead of {\tt and} has the very same effect (see Appendix \ref{bugsappendixa}). The syntax does not seem to be widely used either, it is hence abolished.

\subsubsection*{Changes to the Definition}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 19, remove the box for signature expressions.
\end{itemize}

\subsubsection*{Compatibility}

The change breaks all programs using the derived form. Adapting affected programs is trivial.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Line Comments}
\label{ext-linecomments}

Under most circumstances, line comments are more convenient to write and to layout than block comments. SML lacks line comments.

The comment marker {\tt (*)} introduces a comment that stretches to the end of the line:

\begin{quote}
\begin{alltt}
fun f x = bla    (*) my function
fun g x = blo    (*) my second function
\end{alltt}
\end{quote}

Line comments properly nest into conventional block comments, so the following is one single comment, even though the inner line comment contains a closing comment bracket:

\begin{quote}
\begin{alltt}
(*
fun f x = bla    (*) my function *)
*)
\end{alltt}
\end{quote}

\subsubsection*{Changes to the Definition}

Section 2.3 (Comments):
\begin{itemize}
\item Reformulate whole section as follows:
\begin{quote}
A \emph{comment} is either \emph{line comment} or a \emph{block comment}.
A line comment is any character sequence between the comment delimiter {\tt (*)} and the following end of line.
A block comment is any character sequence within comment brackets {\tt (* *)} in which other comments are properly nested.
No space is allowed between the characters that make up a comment bracket {\tt (*)} or {\tt (*} or {\tt *)}.
An unmatched {\tt (*} should be detected by the compiler.
\end{quote}
\end{itemize}

\subsubsection*{Compatibility}

This extension breaks SML programs containing block comments that have a closing parenthesis {\tt )} as the first character after the opening bracket. Such comments are expected to be extremely rare in existing code, and can easily be modified.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Extended Literal Syntax}
\label{ext-literals}

SML currently provides no way to group digits in numeric literals, which makes long numbers hard to read.
Underscores are allowed within literals to group digits and increase readability. For example,
\begin{quote}
\begin{alltt}
val pi = 3.141_592_653_596
val billion = 1_000_000_000
val nibbles = 0wx_f300_4588
\end{alltt}
\end{quote}

Moreover, SML lacks a notation for binary literals and hence requires fallback to hexadecimal.
A C-style notation with a "0b" prefix enables writing binary literals:
\begin{quote}
\begin{alltt}
val ten = 0b1010
val bits = 0wb1101_0010_1111_0010
\end{alltt}
\end{quote}
Note that binary literals particularly benefit from the ability to group digits.

Last, in SML it is a pointless hurdle to remember the order of the different parts in literal prefixes.
The order of the different parts in literal prefixes is made arbitrary, allowing {\tt 0xw} and {\tt 0bw} as synonyms for {\tt 0wx} and {\tt 0wb}.

\subsubsection*{Changes to the Definition}

Section 2.2 (Special constants):
\begin{itemize}
\item Extend the first sentence as follows:
  \begin{quote}
  [\dots] and the underscore ({\tt \_}) that neither starts nor ends with an underscore.
  \end{quote}

\item Extend the second sentence:
  \begin{quote}
  [\dots] and the underscore that does not end with an underscore.
  \end{quote}

\item Add the following sentence to the end of the paragraph:
  \begin{quote}
  An integer constant (in binary notation) is an optional negation symbol followed by a non-empty sequence of binary digits {\tt 0}, {\tt 1} and the underscore that does not end with an underscore.
  \end{quote}

\item Extend the first sentence of the second paragraph as follows:
  \begin{quote}
  [\dots] and the underscore not ending with an underscore.
  \end{quote}

\item In the second sentence, replace ``is {\tt 0wx}'' with ``is {\tt 0wx} or {\tt 0xw}''.

\item Extend the second sentence as follows:
  \begin{quote}
  [\dots] and the underscore not ending with an underscore. 
  \end{quote}

\item After the second sentence, add:
  \begin{quote}
  A word constant (in binary notation) is {\tt 0wb} or {\tt 0bw} followed by a non-empty sequence of binary digits {\tt 0},{\tt 1} and the underscore not ending with an underscore.
  \end{quote}

\item Modify the next sentence by replacing ``and one or more decimal digits'' with: 
  \begin{quote}
   and a sequence of one or more decimal digits and underscores that contains at least one digit 
  \end{quote}

\item Add to the the list of examples in the next sentence:
  \begin{quote}
  {\tt 3.141\_592\_653  3.\_678\_098\_\_E20}
  \end{quote}

\item Add to the list of non-examples:
  \begin{quote}
  {\tt 1\_.5  1.\_E2}
  \end{quote}
\end{itemize}

\subsubsection*{Compatibility}

This extension is not conservative, as it may change the meaning of programs that contain literals and wildcards without separating spaces, as in
\begin{quote}
\begin{alltt}
fun f 3_4 = 0
\end{alltt}
\end{quote}
or, likewise, programs that put a literal next to an identifier {\tt xw}, {\tt b}, {\tt wb}, or {\tt bw}. However, such programs are highly unlikely to exist in practice. 

The scanning functions from the Basis library should be extended to reflect the change by supporting underscores in their input.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Record Punning}
\label{ext-recordpunning}

SML allows record patterns of the form {\tt \{a=a, b=b\}} to be abbreviated conveniently as {\tt \{a, b\}} -- sometimes called ``punning''. The same abbreviation is not currently provided for record expressions. Such an abbreviation can be equally convenient, e.g. for constructing records from local variables:
\begin{quote}
\begin{alltt}
fun circle(x,y,r) =
    let
        val x = ref x and y = ref y and r = ref r
        fun pos() = (!x,!y)
        fun radius() = !r
        fun move(dx,dy) = (x := !x+dx, y := !y+dy)
        fun scale s = (r := !r*s)
    in
        \{pos, radius, move, scale\}
    end
\end{alltt}
\end{quote}

\subsubsection*{Changes to the Definition}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 15, add the following box:
  \begin{quote}
  {\bf Expression Rows} $\mathit{exprow}$ \\
  $\begin{array}{|l|l|}
  \hline
  \mathit{vid}~\langle\mbox{\tt:}~\mathit{ty}\rangle~\langle\mbox{\tt,}~\mathit{exprow}\rangle~~~
  & \mathit{vid}~\mbox{\tt=}~\mathit{vid}~\langle\mbox{\tt:}~\mathit{ty}\rangle~\langle\mbox{\tt,}~\mathit{exprow}\rangle~ \\
  \hline
  \end{array}$
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 20, add the following production:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{exprow} ::=] & \mathit{vid}~\langle\mbox{\tt:}~\mathit{ty}\rangle~\langle\mbox{\tt,}~\mathit{exprow}\rangle & \textrm{label as variable}
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Record Extension}
\label{ext-recordextension}

When using records, it is sometimes necessary to construct new records from existing ones, by adding only a small number of fields. Similarly, it can be convenient to be able to construct a new record by removing a small number of fields. Currently, SML provides no convenient way of expressing this.

\paragraph{Row capture}

Row capture is supported by raising the status of the ellipsis {\tt...} in record patterns to make it analogous to a normal field name. The ellipsis refers to all the other fields that have not been named explicitly.

Example:
\begin{quote}
\begin{alltt}
val \{d=x, p=y, ...=r\} = e
\end{alltt}
\end{quote}
This value binding takes the result of expression {\tt e}, which must be some record that has at least fields {\tt d} and {\tt p}, and takes it apart. As usual, it binds the values of the {\tt d} and {\tt p} fields to {\tt x} and {\tt y}, respectively. But in addition it also binds r to a freshly constructed record value that consists of all the fields of {\tt e} except {\tt d} and {\tt p}.

Example:
\begin{quote}
\begin{alltt}
val \{d=x, p=y, ...=r\} =
    \{a=1, c=3.0, d=nil, f=[1], p="hello", z=NONE\}
\end{alltt}
\end{quote}
binds {\tt x} to {\tt nil}, {\tt y} to {\tt "hello"}, and {\tt r} to {\tt\{a=1, c=3.0, f=[1], z=NONE\}}.

\paragraph{Record extension}

Functional record extension is supported by allowing ellipses in record expressions. This restores a sense of ``perfect symmetry'' between record patterns and record expressions.

Example:
\begin{quote}
\begin{alltt}
\{d=e1, p=e2, ...=e3\}
\end{alltt}
\end{quote}
Here {\tt e3} is required to be of record type without fields {\tt d} and {\tt p}. The result of the above expression is a record which consists of all the fields that were present in the result of {\tt e3} as well as a field {\tt d} whose type and value are determined by {\tt e1} and a field {\tt p} whose type and value are determined by {\tt e2}.

Example:
\begin{quote}
\begin{alltt}
let val r = \{a=1, c=3.0, f=[1], z=NONE\}
in \{d=nil, p="hello", ...=r\}
end
\end{alltt}
\end{quote}
This expression yields
\begin{quote}
\begin{alltt}
\{a=1, c=3.0, d=nil, f=[1], p="hello", z=NONE\}
\end{alltt}
\end{quote}

\paragraph{Record type extension}

Like record values, record types can be constructed by extension.

Example:
\begin{quote}
\begin{alltt}
type 'a t = \{a : 'a, b : bool\}
type 'a u = \{c : char, d : 'a list, ... : 'a t\}
\end{alltt}
\end{quote}
Again, ellipses denote the type that is to be extended. It must be a record type. The result is a record type which consists of the combined fields. The example yields
\begin{quote}
\begin{alltt}
type 'a u = \{a : 'a, b : bool, c : char, d : 'a list\}
\end{alltt}
\end{quote}

\void{
\paragraph{Functional record update}

Functional record update can be expressed by a combination of row capture and record extension, as can be observed in the following example:

\begin{quote}
\begin{alltt}
let val r = \{a = 1, c = 3.0, d = "not a list", f = [1], p = ["not a string"], z = NONE\}
in \{r where d = nil, p = "hello"\}
end
\end{alltt}
\end{quote}
can be rewritten as:
\begin{quote}
\begin{alltt}
let val r = \{a = 1, c = 3.0, d = "not a list", f = [1], p = ["not a string"], z = NONE\}
    val \{d = _, p = _, ... = tmp\} = r
in \{... = tmp, d = nil, p = "hello"\}
end
\end{alltt}
\end{quote}
where {\tt tmp} is a fresh variable.
}

\subsubsection*{Changes to the Definition}

Section 2.8 (Grammar):
\begin{itemize}
\item In Figure 3, change the production for pattern row wildcards to: 
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{patrow} ::=] & \mbox{\tt...}~\mbox{\tt=}~\mathit{pat} & \textrm{ellipses}
  \end{array}
  $$
  Add the following production for type-expression rows: 
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{tyrow} ::=] & \mbox{\tt...}~\mbox{\tt:}~\mathit{ty} & \textrm{ellipses}
  \end{array}
  $$

\item In Figure 4, add the following production for expression rows: 
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{exprow} ::=] & \mbox{\tt...}~\mbox{\tt=}~\mathit{exp} & \textrm{ellipses}
  \end{array}
  $$
\end{itemize}

Section 2.9 (Syntactic Restrictions):
\begin{itemize}
\item Remove the first bullet ruling out repeated labels.
\end{itemize}

Section 4.2 (Compound Objects):
\begin{itemize}
\item Add the following definition after the paragraph defining modification of maps:
  \begin{quote}
  The restriction of a map f by a set S, written $f\setminus S$, is defined as
  $$
  f\setminus S = \{ x \mapsto f(x) ; x \in \mbox{Dom}\; f \setminus S \}
  $$
  \end{quote}
\end{itemize}

Section 4.7 (Non-expansive Expressions):
\begin{itemize}
\item Add the following production for non-expansive expression rows:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{nexprow} ::=] & \mbox{\tt...}~\mbox{\tt=}~\mathit{nexp}
  \end{array}
  $$
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item Change Rule 6 to: 
% C |- exp => tau    <C |- exprow => rho    lab notin Dom rho>
% ------------------------------------------------------------   (6)
%     C |- lab = exp <, exprow> => {lab |-> tau} <+ rho>
  \begin{equation}
  \tag{6}
  \frac{
  C \vdash \mathit{exp} \Rightarrow \tau
  \qquad
  \langle C \vdash \mathit{exprow} \Rightarrow \varrho
  \qquad
  \mathit{lab} \notin \mbox{Dom}\; \varrho \rangle
  }{
  C \vdash \mathit{lab}~\mbox{\tt=}~\mathit{exp}~\langle\mbox{\tt,}~\mathit{exprow}\rangle
    \Rightarrow \{\mathit{lab} \mapsto \tau \} \langle+ \varrho\rangle
  }
  \end{equation}

\item Add the following rule: 
%  C |- exp => rho in Type
%  -----------------------   (6a)
%   C |- ... = exp => rho
  \begin{equation}
  \tag{6a}
  \frac{
  C \vdash \mathit{exp} \Rightarrow \mbox{$\varrho$ in Type}
  }{
  C \vdash \mbox{\tt...}~\mbox{\tt=}~\mathit{exp} \Rightarrow \varrho
  }
  \end{equation}

\item Change Rules 38 and 39 as follows: 
%  C |- pat => (VE, rho in Type)
%  -----------------------------   (38)
%   C |- ... = pat => (VE,rho)
  \begin{equation}
  \tag{38}
  \frac{
  C \vdash \mathit{pat} \Rightarrow (\mathit{VE}, \mbox{$\varrho$ in Type})
  }{
  C \vdash \mbox{\tt...}~\mbox{\tt=}~\mathit{pat} \Rightarrow (\mathit{VE}, \varrho)
  }
  \end{equation}

%  C |- pat => (VE,tau)
%  <C |- patrow => (VE',rho)    Dom VE cap Dom VE' = 0    lab notin Dom rho>
%  -------------------------------------------------------------------------   (39)
%      C |- lab = pat <, patrow> => (VE <+ VE'>, {lab |-> tau} <+ rho>)
  \begin{equation}
  \tag{39}
  \frac{
  \begin{array}{@{}c@{}}
  C \vdash \mathit{pat} \Rightarrow (\mathit{VE}, \tau)
  \\
  \langle C \vdash \mathit{patrow} \Rightarrow (\mathit{VE}', \varrho)
  \qquad
  \mbox{Dom}\; \mathit{VE} \cap \mbox{Dom}\; \mathit{VE}' = \emptyset
  \qquad
  \mathit{lab} \notin \mbox{Dom}\; \varrho \rangle
  \end{array}
  }{
  C \vdash \mathit{lab}~\mbox{\tt=}~\mathit{pat}~\langle\mbox{\tt,}~\mathit{patrow}\rangle
    \Rightarrow (\mathit{VE} \langle+ \mathit{VE}'\rangle, \{\mathit{lab} \mapsto \tau \} \langle+ \varrho\rangle)
  }
  \end{equation}
  Remove the comment regarding Rule 39.

\item Change Rule 49 to: 
%  C |- ty => tau    <C |- tyrow => rho    lab notin Dom rho>
%  ----------------------------------------------------------   (49)
%      C |- lab : ty <, tyrow> => {lab |-> tau} <+ rho>
  \begin{equation}
  \tag{49}
  \frac{
  C \vdash \mathit{ty} \Rightarrow \tau
  \qquad
  \langle C \vdash \mathit{tyrow} \Rightarrow \varrho
  \qquad
  \mathit{lab} \notin \mbox{Dom}\; \varrho \rangle
  }{
  C \vdash \mathit{lab}~\mbox{\tt:}~\mathit{ty}~\langle\mbox{\tt,}~\mathit{tyrow}\rangle
    \Rightarrow \{\mathit{lab} \mapsto \tau \} \langle+ \varrho\rangle
  }
  \end{equation}
  Remove the respective comment. 

\item Add the following rule: 
%  C |- ty => rho in Type
%  ----------------------   (49a)
%   C |- ... : ty => rho
  \begin{equation}
  \tag{49a}
  \frac{
  C \vdash \mathit{ty} \Rightarrow \mbox{$\varrho$ in Type}
  }{
  C \vdash \mbox{\tt...}~\mbox{\tt:}~\mathit{ty} \Rightarrow \varrho
  }
  \end{equation}
\end{itemize}

Section 4.11 (Further Restrictions):
\begin{itemize}
\item Change the first item to: 
  \begin{quote}
  For each occurence of a record expression containing ellipses, i.e. of the form {\tt\{$\mathit{lab}_1$=$\mathit{exp}_1$,$\dots$,$\mathit{lab}_m$=$\mathit{exp}_m$, ...=$\mathit{exp}_0$\}} the program context must determine uniquely the domain $\{\mathit{lab}_1,\dots,\mathit{lab}_n\}$ of its row type, where $m \leq n$; thus, the context must determine the labels $\{\mathit{lab}_{m+1},\dots,\mathit{lab}_n\}$ of the fields of $\mathit{exp}_0$.  Likewise for record patterns containing ellipses. For these purposes, explicit type constraints may be needed.
  \end{quote}
\end{itemize}

Section 6.7 (Inference Rules):
\begin{itemize}
\item Add the following rule:
%  E |- exp => r in Val
%  --------------------   (95a)
%  E |- ... = exp => r
  \begin{equation}
  \tag{95a}
  \frac{
  E \vdash \mathit{exp} \Rightarrow \mbox{$r$ in Val}
  }{
  E \vdash \mbox{\tt...}~\mbox{\tt=}~\mathit{exp} \Rightarrow r
  }
  \end{equation}

\item Change Rule 140 to:
%  E,r in Val |- pat => VE/FAIL
%  ----------------------------   (140)
%   E,r |- ... = pat => VE/FAIL
  \begin{equation}
  \tag{140}
  \frac{
  E,\mbox{$r$ in Val} \vdash \mathit{pat} \Rightarrow \mathit{VE}/\mathrm{FAIL}
  }{
  E,r \vdash \mbox{\tt...}~\mbox{\tt=}~\mathit{pat} \Rightarrow \mathit{VE}/\mathrm{FAIL}
  }
  \end{equation}

\item Change Rule 142 to:
%  E,r(lab) |- pat => VE    <E,r\{lab} |- patrow => VE'/FAIL>
%  ----------------------------------------------------------   (142)
%        E,r |- lab = pat <, patrow> => VE<+VE'/FAIL>
  \begin{equation}
  \tag{142}
  \frac{
  E,r(\mathit{lab}) \vdash \mathit{pat} \Rightarrow \mathit{VE}
  \qquad
  \langle E,r\setminus\{\mathit{lab}\} \vdash \mathit{patrow} \Rightarrow \mathit{VE}'/\mathrm{FAIL}\rangle
  }{
  E,r \vdash \mathit{lab}~\mbox{\tt=}~\mathit{pat}~\langle\mbox{\tt,}~\mathit{patrow}\rangle \Rightarrow \mathit{VE}\langle+\mathit{VE}'/\mathrm{FAIL}\rangle
  }
  \end{equation}
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 15, add a box for expression rows: 
  \begin{quote}
  {\bf Expression Rows} $\mathit{exprow}$ \\
  $\begin{array}{|l|l|}
  \hline
  \mbox{\tt...}~\mbox{\tt=}~\mathit{exp}\mbox{\tt,}~\mathit{exprow}~~~
  & {\tt{let}}~{\tt{val}}~\mathit{vid}~\mbox{\tt=}~\mathit{exp}~{\tt{in}}~\mbox{\tt\{}\mathit{exprow}\mbox{\tt,}~\mbox{\tt...}~\mbox{\tt=}~\mathit{vid}\mbox{\tt\}}~{\tt{end}}~ \\
  \hline
  \end{array}$ \\
  (see note in text concerning $\mathit{exprow}$; $\mathit{vid}$ new)
  \end{quote}

\item In Figure 16, extend the box for pattern rows as follows: 
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  \mbox{\tt...}
  & \mbox{\tt...}~\mbox{\tt=}~\mbox{\tt\_} \\
  \hline
  \mbox{\tt...}~\langle\mbox{\tt=}~\mathit{pat}\rangle\mbox{\tt,}~\mathit{patrow}~~~
  & \mathit{patrow}\mbox{\tt,}~\mbox{\tt...}~\langle\mbox{\tt=}~\mathit{pat}\rangle~ \\
  \hline
  \end{array}$ \\
  (see note in text concerning $\mathit{patrow}$)
  \end{quote}
  Add a box for type-expression rows: 
  \begin{quote}
  {\bf Type-expression Rows} $\mathit{tyrow}$ \\
  $\begin{array}{|l|l|}
  \hline
  \mbox{\tt...}~\mbox{\tt:}~\mathit{ty}\mbox{\tt,}~\mathit{tyrow}~~~
  & \mathit{tyrow}\mbox{\tt,}~\mbox{\tt...}~\mbox{\tt:}~\mathit{ty}~ \\
  \hline
  \end{array}$ \\
  (see note in text concerning $\mathit{tyrow}$)
  \end{quote}

\item Add the following paragraph: 
  \begin{quote}
  Note that the derived forms for ellipses in the middle of expression rows, pattern rows or
  type-expression rows are only valid if they can be transformed to bare syntax. This implies
  that the remaining rows may not again contain ellipses.
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 20, add the following production for expression rows:%
\void{
\footnote{
Note that we define ellipses in arbitrary position as a derived form, since pattern matching for mid-row ellipses is more complicated to describe in a direct style within the current rules (we would have to thread back the information about what further fields to remove from the row).
}}
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{exprow} ::=] & \mbox{\tt...}~\mbox{\tt=}~\mathit{exp}~\langle\mbox{\tt,}~\mathit{exprow}\rangle & \textrm{ellipses}
  \end{array}
  $$

\item In Figure 22, change the production for pattern row wildcards to: 
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{patrow} ::=] & \mbox{\tt...}~\langle\mbox{\tt=}~\mathit{pat}\rangle~\langle\mbox{\tt,}~\mathit{patrow}\rangle & \textrm{ellipses}
  \end{array}
  $$

\item In Figure 23, add the following production for type-expression rows: 
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{tyrow} ::=] & \mbox{\tt...}~\mbox{\tt:}~\mathit{ty}~\langle\mbox{\tt,}~\mathit{tyrow}\rangle & \textrm{ellipses}
  \end{array}
  $$
\end{itemize}


\subsubsection*{Compatibility}

This is a conservative extension. Type inference is not entirely straightforward in the given form, but the issues are only slightly harder than those already caused by the existing ellipsis mechanism (unresolved row variables become shared between different record types and hence require additional propagation). Type inference actually becomes simpler in the presence of SML\#-style record polymorphism, but an efficient implementation of the dynamic semantics becomes somewhat trickier.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Record Update}
\label{ext-recordupdate}

When using records, it is often necessary to construct new records from existing ones, by changing only a small number of fields. For example, this happens when using records to express functional objects, or in the use of records to encode default arguments. Currently, SML provides no convenient way to express this.

Record update is supported with a new derived form
{\tt\{$\mathit{atexp}$ where $\mathit{exprow}$\}}. The keyword {\tt where} is chosen such that it plays a similar role as it does in the signature language.
The syntax is designed such that it adheres to the principle of least surprise, is economic, and convenient.

\void{
Alternative choices of syntax include {\tt $\mathit{exp}$ where \{$\mathit{exprow}$\}}. However, the current proposal has several minor advantages:
\begin{enumerate}
\item It adheres to the principle of least surprise. The alternative choice is likely to make users believe that they can actually write {\tt $\mathit{exp}_1$ where $\mathit{exp}_2$}, for arbitrary record concatenation, and hence may lead to to confusion and complaints, particularly among novices. On the other hand, the proposal does not preclude adding such a general record concatenation construct later (at which point update could be redefined as a derived form).
\item It is more economic, since it does not require addition of a new syntactic form, only simple extension of the existing record expression syntax.
\item It is more convenient, because it requires less parentheses. In particular, it nicely generalises the use of records to emulate keyword arguments, as in
\begin{quote}
\begin{alltt}
f \{a=2, b=3, c=4, d=1\}
\end{alltt}
\end{quote}
to default/optional arguments: 
\begin{quote}
\begin{alltt}
f \{defaults where b=3, d=1\}
\end{alltt}
\end{quote}
With the alternative syntax above, the latter would become: 
\begin{quote}
\begin{alltt}
f (defaults where \{b=3, d=1\})
\end{alltt}
\end{quote}
\item An analogous syntax has already been established in Objective Caml (albeit using the {\tt with} keyword instead of {\tt where}).
\end{enumerate}
A minor disadvantage of the syntax is that it requires the nested expression to be restricted to an atomic expression, unless one is willing to give up LR(1) parsing. That forces (probably unexpectedly) use of parentheses in case the expression is an application.
}

\subsubsection*{Changes to the Definition}

Appendix A (Derived Forms):
\begin{itemize}
\item Extend the box for expressions as follows: 
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  \mbox{\tt\{}\mathit{atexp}~{\tt{where}}~\langle\mathit{exprow}\rangle\mbox{\tt\}}~~~
  & {\tt let}~{\tt val}~\mbox{\tt\{}\langle\mathit{patrow}\mbox{\tt,}\rangle~\mbox{\tt...}~\mbox{\tt=}~\mathit{vid}\mbox{\tt\}}~\mbox{\tt=}~\mathit{atexp} \\
  & {\tt in}~\mbox{\tt\{}\langle\mathit{exprow}\mbox{\tt,}\rangle~\mbox{\tt...}~\mbox{\tt=}~\mathit{vid}\mbox{\tt\}}~{\tt end} \\
  \hline
  \end{array}$ \\
  (see note in text concerning $\mathit{patrow}$; $\mathit{vid}$ new)
  \end{quote}

\item Add the following paragraph after the second of the section:
  \begin{quote}
  In the derived forms for record update, $\mathit{patrow}$ is obtained from $\mathit{exprow}$ by replacing all right-hand sides by wildcards. Note that $\mathit{exprow}$ may not contain ellipses.
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item  In Figure 20, change the production for record expressions to: 
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{exp} ::=] & \mbox{\tt\{}~\langle\mathit{atexp}~{\tt where}\rangle~\langle\mathit{exprow}\rangle~\mbox{\tt\}} & \textrm{record}
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension. Its specification relies on record extension, as defined in the previous section.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Conjunctive Patterns}
\label{ext-conjunctivepatterns}

SML provides layered patterns {\tt $\mathit{vid}$ as $\mathit{pat}$} to allow naming a value and simultaneously matching its structure. The name must be put first. However, depending on the situation, it often is more convenient to put the name last.

Instead of adding a second syntactic form, we propose generalizing layered patterns to arbitrary conjunctive patterns {\tt $\mathit{pat}_1$ as $\mathit{pat}_2$}, which trivially supports both forms, while also eliminating grammar problems that exist with the current syntax (it is not LR(1)).

Conjunctive patterns are particularly useful in combination with nested matches (see Appendix \ref{ext-nestedpatterns}).

\subsubsection*{Changes to the Definition}

Section 2.8 (Grammar):
\begin{itemize}
\item In Figure 3, replace the production for layered patterns with: 
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{pat} ::=] & \mathit{pat}_1~{\tt as}~\mathit{pat}_2 & \textrm{conjunctive}
  \end{array}
  $$
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item Replace rule 43 with: 
%   C |- pat_1 => (VE_1,tau)    C |- pat_2 => (VE_2,tau)    Dom VE_1 \cap Dom VE_2 = 0
%   ----------------------------------------------------------------------------------   (43)
%                       C |- pat_1 as pat_2 => (VE_1 + VE_2,tau)
  \begin{equation}
  \tag{43}
  \frac{
  C \vdash \mathit{pat}_1 \Rightarrow (\mathit{VE}_1,\tau)
  \qquad
  C \vdash \mathit{pat}_2 \Rightarrow (\mathit{VE}_2,\tau)
  \qquad
  \mbox{Dom}\; \mathit{VE}_1 \cap \mbox{Dom}\; \mathit{VE}_2 = \emptyset
  }{
  C \vdash \mathit{pat}_1~{\tt as}~\mathit{pat}_2 \Rightarrow (\mathit{VE}_1+\mathit{VE}_2,\tau)
  }
  \end{equation}
\end{itemize}

Section 4.11 (Further Restrictions):
\begin{itemize}
\item Add the following bullet: 
  \begin{quote}
  Every pattern of the form {\tt $\mathit{pat}_1$ as $\mathit{pat}_2$} must be consistent, i.e., there must exist at least one value that is matched by both patterns.
  \end{quote}
\end{itemize}

Section 6.7 (Inference Rules):
\begin{itemize}
\item Replace rule 149 with:
%   E,v |- pat_1 => VE_1    E,v |- pat_2 => VE_2/FAIL
%   -------------------------------------------------   (149)
%      E,v |- pat_1 as pat_2 => (VE_1 + VE_2)/FAIL
  \begin{equation}
  \tag{149}
  \frac{
  E,v \vdash \mathit{pat}_1 \Rightarrow \mathit{VE}_1
  \qquad
  E,v \vdash \mathit{pat}_2 \Rightarrow \mathit{VE}_2/\mathrm{FAIL}
  }{
  E,v \vdash \mathit{pat}_1~{\tt as}~\mathit{pat}_2 \Rightarrow (\mathit{VE}_1+\mathit{VE}_2)/\mathrm{FAIL}
  }
  \end{equation}

\item Add the following rule:
%       E,v |- pat_1 => FAIL
%   -----------------------------   (149a)
%   E,v |- pat_1 as pat_2 => FAIL
  \begin{equation}
  \tag{149a}
  \frac{
  E,v \vdash \mathit{pat}_1 \Rightarrow \mathrm{FAIL}
  }{
  E,v \vdash \mathit{pat}_1~{\tt as}~\mathit{pat}_2 \Rightarrow \mathrm{FAIL}
  }
  \end{equation}
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 16, remove the box for pattern rows.
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 22, replace the production for layered patterns with:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{pat} ::=] & \mathit{pat}_1~{\tt as}~\mathit{pat}_2 & \textrm{conjunctive}
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension.
Pattern matching is not complicated significantly by the change. It actually simplifies parsing.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Disjunctive Patterns}
\label{ext-disjunctivepatterns}

Disjunctive patterns {\tt $\mathit{pat}_1$ | $\mathit{pat}_2$} avoid the need for repeating the same right-hand side in a match several times, by allowing to fold multiple left-hand side patterns into one. In certain cases this can significantly reduce code size, as well as the temptation to write fragile catch-all clauses to get around the code duplication.

Note that the syntax immediately supports writing multiple alternatives {\tt $\mathit{pat}_1$ | $\dots$ | $\mathit{pat}_n$}, as well as "multiple" matches:
\begin{quote}
\begin{alltt}
case exp of
    A | B | C => 1
  | D | E => 2
\end{alltt}
\end{quote}

\subsubsection*{Changes to the Definition}

Section 2.8 (Grammar):
\begin{itemize}
\item In Figure 3, add the following production:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{pat} ::=] & \mathit{pat}_1~\mbox{\tt|}~\mathit{pat}_2 & \textrm{disjunctive}
  \end{array}
  $$
\end{itemize}

Section 2.9 (Syntactic Restrictions):
\begin{itemize}
\item Add the following comment to the 2nd bullet:
  \begin{quote}
  [...] (identifiers appearing in both branches of a disjunctive pattern are bound only once) 
  \end{quote}
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item Add the following rule for patterns:
%   C |- pat_1 => (VE,tau)    C |- pat_2 => (VE,tau)
%   ------------------------------------------------  (43a)
%          C |- pat_1 | pat_2 => (VE,tau)
  \begin{equation}
  \tag{43a}
  \frac{
  C \vdash \mathit{pat}_1 \Rightarrow (\mathit{VE},\tau)
  \qquad
  C \vdash \mathit{pat}_2 \Rightarrow (\mathit{VE},\tau)
  }{
  C \vdash \mathit{pat}_1~\mbox{\tt|}~\mathit{pat}_2 \Rightarrow (\mathit{VE},\tau)
  }
  \end{equation}
\end{itemize}

Section 4.11 (Further Restrictions):
\begin{itemize}
\item In item 2, insert the following sentence after the first one:
  \begin{quote}
  Similarly, in a disjunctive pattern of the form {\tt $\mathit{pat}_1$ | $\mathit{pat}_2$}, the second pattern must match some value not matched by the first one. Moreover, either of them must match some value that is not matched by the surrounding pattern or match rule.
  \end{quote}
\end{itemize}
The wording regarding irredundancy does require compilers to warn about cases like {\tt fn \_|3 => ()}, but not {\tt fn 3|\_ => ()}, although the latter is redundant as well. None of the compilers currently supporting disjunctive patterns seems to detect the latter, and it is not obvious how to extend the usual algorithm appropriately.

Section 6.7 (Inference Rules):
\begin{itemize}
\item Add the following rules for patterns:
%       E,v |- pat_1 => VE
%   --------------------------   (149b)
%   E,v |- pat_1 | pat_2 => VE
  \begin{equation}
  \tag{149b}
  \frac{
  E,v \vdash \mathit{pat}_1 \Rightarrow \mathit{VE}
  }{
  E,v \vdash \mathit{pat}_1~\mbox{\tt|}~\mathit{pat}_2 \Rightarrow \mathit{VE}
  }
  \end{equation}

%   E,v |- pat_1 => FAIL    E,v |- pat_2 => VE/FAIL
%   -----------------------------------------------   (149c)
%          E,v |- pat_1 | pat_2 => VE/FAIL
  \begin{equation}
  \tag{149c}
  \frac{
  E,v \vdash \mathit{pat}_1 \Rightarrow \mathrm{FAIL}
  \qquad
  E,v \vdash \mathit{pat}_2 \Rightarrow \mathit{VE}/\mathrm{FAIL}
  }{
  E,v \vdash \mathit{pat}_1~\mbox{\tt|}~\mathit{pat}_2 \Rightarrow \mathit{VE}/\mathrm{FAIL}
  }
  \end{equation}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 21, add the following production (as the last one, giving least precedence):
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{pat} ::=] & \mathit{pat}_1~\mbox{\tt|}~\mathit{pat}_2 & \textrm{disjunctive}
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Nested Matches}
\label{ext-nestedpatterns}

Patterns may contain nested matching constructs of the form
$$
\mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp}
$$
Such a \emph{nested match} is matched by first matching $\mathit{pat}_1$, then evaluating $\mathit{exp}$, and matching its result against $\mathit{pat}_2$. Variables bound in $\mathit{pat}_1$ may occur in $\mathit{exp}$. The pattern fails when either pattern does not match. The pattern binds the combined set of variables occuring in $\mathit{pat}_1$ and $\mathit{pat}_2$. For instance, consider:
\begin{quote}
\begin{alltt}
case xs of [x,y] with SOME z = f(x,y) => x+y+z | _ => 0
\end{alltt}
\end{quote}
If {\tt xs} is a two-element list {\tt[x,y]} such that {\tt f(x,y)} returns {\tt SOME} {\tt z}, then the whole expression evaluates to {\tt x+y+z}, otherwise to {\tt0}.

Nested matches are a very general construct. They can be useful in combination with disjunctive patterns,
\begin{quote}
\begin{alltt}
case args of x::_ | (nil with x = 0) => ...
\end{alltt}
\end{quote}
or with guards (see Appendix \ref{ext-guards}):
\begin{quote}
\begin{alltt}
fun escape #"\(\backslash\)"" = "\(\backslash\)\(\backslash\)\(\backslash\)""
  | escape #"\(\backslash\)\(\backslash\)" = "\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"
  | escape (c with n=ord c) if (n < 32) = "\(\backslash\)\(\backslash\)^" ^ str(chr(n+64))
  | escape c = str c
\end{alltt}
\end{quote}

The main importance of nested matches, however, is that they form the basis to uniformly define pattern guards (Appendix {ext-guards}) as well as a simple form of ``views'' (Appendix \ref{ext-transformation}) as syntactic sugar.

In patterns with multiple subpatterns, nested matches to the right may refer to variables bound by patterns to the left. See Appendix \ref{ext-transformation} for examples.

\subsubsection*{Changes to the Definition}

Section 2.8 (Grammar):
\begin{itemize}
\item In Figure 3, add the following production for patterns:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{pat} ::=] & \mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp} & \textrm{nested match}
  \end{array}
  $$
  and the note
  \begin{quote}
  {\it Restriction:} The pattern $\mathit{pat}_1$ in a nested match $\mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp}$ may not itself be a nested match, unless enclosed by parentheses.
  \end{quote}

\item In Figure 4, add the following note:
  \begin{quote}
  {\it Restriction:} The pattern $\mathit{pat}$ in a $\mathit{valbind}$ may not be of the form $\mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp}$, unless enclosed by parentheses.
  \end{quote}
\end{itemize}

Section 4.7 (Non-expansive Patterns):
\begin{itemize}
\item Add the following paragraph:
  \begin{quote}
  A pattern is \emph{non-expansive} if it does not contain a nested match of the form $\mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp}$.
  \end{quote}
\end{itemize}

Section 4.8 (Closure):
\begin{itemize}
\item Add the following additional side condition to the first case defining $\mbox{Clos}_{C,\mathit{valbind}}\mathit{VE}(\mathit{vid})$:
  \begin{quote}
  if $\mathit{pat}$ is non-expansive, \dots
  \end{quote}
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item In rule 39, change the premise ``$C \vdash \mathit{patrow} \Rightarrow (\mathit{VE}',\varrho)$'' to ``$C+\mathit{VE} \vdash \mathit{patrow} \Rightarrow (\mathit{VE}',\varrho)$''.

\item Likewise, in rule 43 (as given in Appendix \ref{ext-conjunctivepatterns}), change the premise ``$C \vdash \mathit{pat}_2 \Rightarrow (\mathit{VE}_2,\varrho)$'' to ``$C+\mathit{VE}_1 \vdash \mathit{pat}_2 \Rightarrow (\mathit{VE}_2,\varrho)$''.

\item Add the following rule for patterns:
%   C |- pat1 => (VE1,tau)    C+VE1 |- pat2 => (VE2,tau')
%   C+VE1 |- exp => tau'    Dom VE1 \cap Dom VE2 = 0
%   ------------------------------------------------------   (43b)
%   C |- pat_1 with pat_2 = exp => (VE1+VE2,tau)
  \begin{equation}
  \tag{43b}
  \frac{
  \begin{array}{c}
  C \vdash \mathit{pat}_1 \Rightarrow (\mathit{VE}_1,\tau)
  \qquad
  C+\mathit{VE}_1 \vdash \mathit{pat}_2 \Rightarrow (\mathit{VE}_2,\tau')
  \\
  C+\mathit{VE}_1 \vdash \mathit{exp} \Rightarrow \tau'
  \qquad
  \mbox{Dom}\,\mathit{VE}_1 \cap \mbox{Dom}\,\mathit{VE}_2 = \emptyset
  \end{array}
  }{
  C \vdash \mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp} \Rightarrow (\mathit{VE}_1+\mathit{VE}_2,\tau)
  }
  \end{equation}
\end{itemize}

Section 4.11 (Further Restrictions):
\begin{itemize}
\item Add the following sentence to the 2nd bullet:
  \begin{quote}
 For the purpose of checking exhaustiveness, any contained nested match, $\mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp}$ may be assumed to fail, regardless of the form of $\mathit{exp}$, except if $\mathit{pat}_2$ is exhaustive itself. Further note that $\mathit{exp}$ may contain side effects and hence change the content of references that have already been matched.
  \end{quote}
\end{itemize}

Section 6.7 (Inference Rules):
\begin{itemize}
\item In rule 142, change the premise ``$E,r \vdash \mathit{patrow} \Rightarrow \mathit{VE}'/\mbox{FAIL}$'' to ``$E+\mathit{VE},r \vdash \mathit{patrow} \Rightarrow \mathit{VE}'/\mbox{FAIL}$''.

\item Likewise, in rule 43 (as given in Appendix \ref{ext-conjunctivepatterns}), change the premise ``$E,v \vdash \mathit{pat}_2 \Rightarrow \mathit{VE}_2/\mbox{FAIL}$'' to ``$E+\mathit{VE}_1,v \vdash \mathit{pat}_2 \Rightarrow \mathit{VE}_2/\mbox{FAIL}$''.

\item Add the following rules for patterns:
%   E,v |- pat1 => FAIL
%   --------------------------------------   (149d)
%   E,v |- pat_1 with pat_2 = exp => FAIL
  \begin{equation}
  \tag{149d}
  \frac{
  E,v \vdash \mathit{pat}_1 \Rightarrow \mbox{FAIL}
  }{
  E,v \vdash \mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp} \Rightarrow \mbox{FAIL}
  }
  \end{equation}

%   E,v |- pat1 => VE1    E+VE1 |- atexp => v'    E+VE1,v' |- pat2 => VE2/FAIL
%   ------------------------------------------------------------------------------   (149e)
%   E,v |- pat_1 with pat_2 = exp => VE1+VE2/FAIL
  \begin{equation}
  \tag{149e}
  \frac{
  \begin{array}{c}
  E,v \vdash \mathit{pat}_1 \Rightarrow \mathit{VE}_1
  \qquad
  E+\mathit{VE}_1 \vdash \mathit{exp} \Rightarrow v'
  \qquad
  E+\mathit{VE}_1,v' \vdash \mathit{pat}_2 \Rightarrow \mathit{VE}_2/\mbox{FAIL}
  \end{array}
  }{
  E,v \vdash \mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp} \Rightarrow \mathit{VE}_1+\mathit{VE}_2/\mbox{FAIL}
  }
  \end{equation}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 21, add the following note:
  \begin{quote}
  {\it Restriction:} The pattern $\mathit{pat}$ in a $\mathit{valbind}$ may not be of the form $\mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp}$, unless enclosed by parentheses.
  \end{quote}

\item Add the following production for patterns:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{pat} ::=] & \mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp} & \textrm{nested match}
  \end{array}
  $$
  and the note
  \begin{quote}
  {\it Restriction:} The pattern $\mathit{pat}$ in a $\mathit{valbind}$ may not be of the form $\mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp}$, unless enclosed by parentheses.
  \end{quote}
\end{itemize}

\subsubsection*{Compatibility}

Except for the new reserved word {\tt?}, this is a mostly conservative extension.
Due to potential side effects in guard conditions, it renders pattern matching impure. This has a particular consequence on patterns of the form {\tt ref} $\mathit{atpat}$, whose behaviour may depend on the evaluation of previous nested matches. In particular, the following case expression,
\begin{quote}
\begin{alltt}
case (i, r) of
    (\_, ref true) => 1
  | (2, \_) with _ = f() => 2
  | (\_, ref false) => 3
\end{alltt}
\end{quote}
is not an exhaustive match, since {\tt r} may be {\tt false}, but could get set to {\tt true} during evaluation of {\tt f()}.

Note that conjunctive patterns ``$\mathit{pat}_1~{\tt{as}}~\mathit{pat}_2$'' could also be defined as a derived form for
$$
\mathit{vid}~{\tt{with}}~\mathit{pat}_1~\mbox{\tt=}~\mathit{vid}~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{vid}
$$
but that would alter the meaning of exhaustiveness.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pattern Guards}
\label{ext-guards}

Pattern guards avoid code duplication by letting pattern matching fall through if a particular condition is not met. This is not possible by merely using conditionals on the right-hand side.

Pattern guards are introduced as a simple derived form for nested matches:
\begin{quote}
$\mathit{pat}~{\tt{if}}~\mathit{exp}$
\end{quote}
They are also allowed with function-value bindings:
\begin{quote}
\begin{alltt}
fun min x y if (x < y) = x
  | min x y            = y
\end{alltt}
\end{quote}
\void{
\begin{quote}
$\langle{\tt{op}}\rangle\mathit{vid}~\mathit{atpat}_1\cdots\mathit{atpat}_n~{\tt{if}}~\mathit{atexp}~\mbox{\tt=}~\mathit{exp}$
\end{quote}
}Note that in this case the guard condition needs to be an atomic expression, in order to avoid syntactic ambiguity.

\subsubsection*{Changes to the Definition}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 16, add the following boxes for patterns $\mathit{pat}$:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  \mathit{pat}~{\tt{if}}~\mathit{exp}~~
  & \mathit{pat}~{\tt{with}}~{\tt{true}}~\mbox{\tt=}~\mathit{exp}~~~ \\
  \hline
  \end{array}$
  \end{quote}

\item In Figure 17, extend the box for Function-value Bindings by adding
  \begin{quote}
  $\langle{\tt{if}}~\mathit{atexp}_i\rangle$
  \end{quote}
  (with $i = 1..m$) to each equation in the left box, as the last component of the left-hand sides, and likewise to each match in the right box, as the last component before {\tt=>}.
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 21, extend the production for $\mathit{fmrule}$ (as defined in Appendix \ref{ext-syntaxfixes}) as follows:
  \begin{eqnarray*}
  \mathit{fmrule} &::=& \mathit{fpat}~\langle\mbox{\tt:}~\mathit{ty}\rangle~\langle{\tt{if}}~\mathit{atexp}\rangle~\mbox{\tt=}~\mathit{exp} \\
  \end{eqnarray*}

\item Extend the restriction note added by the change from Appendix \ref{ext-nestedpatterns} by inserting the following before ``unless enclosed by parentheses'':
  \begin{quote}
  [\dots] or $\mathit{pat}~{\tt{if}}~\mathit{exp}$ [\dots]
  \end{quote}

\item In Figure 22, add the following production for patterns:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{pat} ::=] & \mathit{pat}~{\tt{if}}~\mathit{exp} & \textrm{guard}
  \end{array}
  $$
  and extend the restriction note added by the change from Appendix \ref{ext-nestedpatterns} by inserting the following before ``unless enclosed by parentheses'':
  \begin{quote}
  [\dots] or $\mathit{pat}~{\tt{if}}~\mathit{exp}$ [\dots]
  \end{quote}
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension over nested matches. It is mostly conservative over plain SML (see Appendix \ref{ext-nestedpatterns}).

\void{
\subsubsection*{Changes to the Definition}

Section 4.11 (Further Restrictions):
\begin{itemize}
\item Add the following sentence to the 2nd bullet:
  \begin{quote}
  In the case of the derived form for guarded matches, $\mathit{pat}~{\tt{if}}~\mathit{exp}_1~\mbox{\tt=>}~\mathit{exp}_2$, exhaustiveness and irredundancy need to be checked with respect to the original form, since the rewriting rule does not maintain those properties. For the purpose of these checks, the guard condition can always be false. Further note that guards may contain side effects and hence change the content of references that have already been matched.
  \end{quote}
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 15, add the following box:
  \begin{quote}
  {\bf Matches} $\mathit{match}$ \\
  $\begin{array}{|l|l|}
  \hline
  \mathit{pat}~{\tt{if}}~\mathit{exp}_1~\mbox{\tt=>}~\mathit{exp}_2~\langle\mbox{\tt|}~\mathit{match}\rangle~~~
  & \mathit{vid}~\mbox{\tt=>}~{\tt{case}}~\mathit{vid}~{\tt{of}}~\mathit{pat}~\mbox{\tt=>} \\
  & ~~~~{\tt{case}}~\mathit{exp}_1~{\tt{of}}~{\tt{true}}~\mbox{\tt=>}~\mathit{exp}_2 \\
  & ~~~~~~~~~~~~~~~~~~~~~~\langle\mbox{\tt|}~{\tt{false}}~\mbox{\tt=>}~{\tt{case}}~\mathit{vid}~{\tt{of}}~\mathit{match}\rangle \\
  \hline
  \end{array}$
  \end{quote}

\item In Figure 17, extend the box for Function-value Bindings by adding
  \begin{quote}
  $\langle{\tt{if}}~\mathit{atexp}_i\rangle$
  \end{quote}
  (with $i = 1..m$) to each equation in the left box, as the last component of the left-hand sides, and likewise to each match in the right box, as the last component before {\tt=>}.
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 20, change the production for mrule as follows: 
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   \mathit{mrule} &::= & \mathit{pat}~\langle{\tt{if}}~\mathit{exp}_1\rangle~\mbox{\tt=>}~\mathit{exp}_2
  \end{array}
  $$

\item In Figure 21, extend the production for $\mathit{fmrule}$ (as defined in Appendix \ref{ext-syntaxfixes}) as follows:
  \begin{eqnarray*}
  \mathit{fmrule} &::=& \mathit{fpat} \; \langle\mbox{\tt:} \; \mathit{ty}\rangle \; \langle{\tt{if}}~\mathit{atexp}\rangle \mbox{\tt=} \; \mathit{exp}
  \end{eqnarray*}
\end{itemize}

\subsubsection*{Compatibility}

This is a mostly conservative extension.
Due to potential side effects in guard conditions, it renders pattern matching impure. This has a particular consequence on patterns of the form {\tt ref} $\mathit{atpat}$, whose behaviour may depend on the evaluation of previous guards. In particular, the following case expression,
\begin{quote}
\begin{alltt}
case (i, r) of
    (\_, ref true) => 1
  | (2, \_) if f() => 2
  | (\_, ref false) => 3
\end{alltt}
\end{quote}
is not an exhaustive match, since {\tt r} may be {\tt false}, but could get set to {\tt true} during evaluation of {\tt f()}.
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transformation Patterns}
\label{ext-transformation}

The main importance of nested matches, is that they form the basis to uniformly define a simple form of ``poor man's views'' as syntactic sugar, which we refer to as \emph{transformation patterns}:
\begin{quote}
\begin{alltt}
?\(\mathit{exp}\)
?\(\mathit{exp}\) \(\mathit{pat}\)
\end{alltt}
\end{quote}
The first form provides boolean ``views'':
\begin{quote}
\begin{alltt}
fun skipSpace(?isSpace :: cs) = skipSpace cs
  | skipSpace cs = cs
\end{alltt}
\end{quote}
The parameterised form allows actual matching. Consider an ADT for queues:
\begin{quote}
\begin{alltt}
type 'a queue
val empty : 'a queue
val enqueue : 'a * 'a queue -> 'a queue
val dequeue : 'a queue -> ('a * 'a queue) option
\end{alltt}
\end{quote}
With such patterns, queues can be pattern matched as follows:
\begin{quote}
\begin{alltt}
fun process (?dequeue(x,q)) = (digest x; process q)
  | process _ = terminate()
\end{alltt}
\end{quote}
A transformation may be denoted by an arbitrary expression, giving rise to \emph{dynamic transformations}. Consider a simple set ADT:
\begin{quote}
\begin{alltt}
type set
val empty : set
val insert : int -> set -> set
val isempty : set -> bool
val has : int -> set -> bool
\end{alltt}
\end{quote}
The following is possible:
\begin{quote}
\begin{alltt}
fun f n ?isempty = f1 ()
  | f n ?(has n) = f2 ()
  | f n _ = f3 ()
\end{alltt}
\end{quote}
Or another example, with a parameterised dynamic transformation:
\begin{quote}
\begin{alltt}
(*) val split : char -> string -> (string * string) option

fun manExp(?(split #"E")(m,e)) = (m,e)
  | manExp s = (s,"1")
\end{alltt}
\end{quote}

As a minor subtelety, in patterns with multiple subpatterns, nested matches and transformation patterns to the right may refer to variables bound by patterns to the left. For example,
\begin{quote}
\begin{alltt}
(x, ?(equals x))
x as ?(notOccurs x)(T(x1,x2))
\end{alltt}
\end{quote}
In particular, this allows the function {\tt f} above to be expressed more without a separate {\tt case} expression.

Note that, in addition to transformation patterns, HaMLet-S also features proper views (Appendix \ref{ext-views}). While it is probably undesirable to have both features in a finalised language, simultaneous support in an experimental system like ours allows evaluating the merits of each approach.

\subsubsection*{Changes to the Definition}

Section 2.1 (Reserved Words):
\begin{itemize}
\item Add {\tt?} to the list of reserved words.
\end{itemize}

Section 2.9 (Syntactic Restrictions):
\begin{itemize}
\item Add {\tt NONE} and {\tt SOME} to the list of value identifiers that may not be re-bound.
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 16, add the following boxes for patterns $\mathit{pat}$:
  \begin{quote}
  $\begin{array}{|l|l|l}
  \cline{1-2}
  \mbox{\tt?}\mathit{atexp}~~~~\strut
  & \mathit{vid}~{\tt{with}}~{\tt{true}}~\mbox{\tt=}~\mathit{atexp}~\mathit{vid}
  & \mbox{($\mathit{vid}$ new)} \\
  \cline{1-2}
  \mbox{\tt?}\mathit{atexp}~\mathit{atpat}~~~\strut
  & \mathit{vid}~{\tt{with}}~{\tt{SOME}}~\mathit{atpat}~\mbox{\tt=}~\mathit{atexp}~\mathit{vid}~~
  & \mbox{($\mathit{vid}$ new)} \\
  \cline{1-2}
  \end{array}$
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 22, add the following production for atomic patterns:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{atpat} ::=] & \mbox{\tt?}~\mathit{atexp} & \textrm{transformation}
  \end{array}
  $$

\item Add the following production for application patterns (as introduced by the changes described in Appendix \ref{ext-syntaxfixes}):
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
   [\mathit{apppat} ::=] & \mbox{\tt?}~\mathit{atexp}~\mathit{atpat} & \textrm{constructed transformation}
  \end{array}
  $$
\end{itemize}

Appendix C (The Initial Static Basis):
\begin{itemize}
\item Add {\tt option} to the definition of $T_0$.

\item In Figure 24, add the following entry:
  \begin{eqnarray*}
  {\tt{option}} &\mapsto& (~{\tt{option}},~
  \begin{array}[t]{l}
  \{{\tt{NONE}}\mapsto(\forall\,{\tt'a}\,.\,{\tt'a~option},{\tt{c}}),\\
  ~~{\tt{SOME}}\mapsto(\forall\,{\tt'a}\,.\,{\tt'a}\to{\tt'a~option},{\tt{c}})\})
  \end{array}
  \end{eqnarray*}

\item In Figure 25, add the following entries to the left column:
  \begin{eqnarray*}
  {\tt{NONE}} &\mapsto& (\forall\,{\tt'a}\,.\,{\tt'a~option},{\tt{c}}) \\
  {\tt{SOME}} &\mapsto& (\forall\,{\tt'a}\,.\,{\tt'a}\to{\tt'a~option},{\tt{c}})
  \end{eqnarray*}
\end{itemize}

Appendix D (The Initial Dynamic Basis):
\begin{itemize}
\item Add ``${\tt{NONE}}\mapsto({\tt{NONE}},{\tt{c}})$'' and ``${\tt{SOME}}\mapsto({\tt{SOME}},{\tt{c}})$'' to the definition of $\mathit{VE}_0$.

\item In Figure 26, add the following entry:
  \begin{eqnarray*}
  {\tt{option}} &\mapsto& \{{\tt{NONE}}\mapsto({\tt{NONE}},{\tt{c}}),~{\tt{SOME}}\mapsto({\tt{SOME}},{\tt{c}})\}
  \end{eqnarray*}
\end{itemize}

\subsubsection*{Compatibility}

Except for the new reserved word {\tt?}, this is a mostly conservative extension (see Appendix \ref{ext-nestedpatterns}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Optional Bars and Semicolons}
\label{ext-bars}

SML syntax separates match clauses with a bar {\tt|}. The usual coding convention is to lay out matches such that the bar comes before each clause. However, the first clause is an unpleasant special case:
\begin{quote}
\begin{alltt}
case exp0 of
    pat1 => exp1
  | pat2 => exp2
  | pat3 => exp3
\end{alltt}
\end{quote}
Taking aesthethic considerations aside, the assymmetry between the cases is a nuisance for editing, because clauses cannot be reordered by a simple cut \& paste operation.

An additional bar is allowed to optionally appear before the first clause, such that the above can be written as:
\begin{quote}
\begin{alltt}
case exp0 of
  | pat1 => exp1
  | pat2 => exp2
  | pat3 => exp3
\end{alltt}
\end{quote}
For consistency, the same extension is made for function value bindings, and for datatype declarations. For instance,
\begin{quote}
\begin{alltt}
datatype 'a exp =
  | Const  of 'a
  | Var    of string
  | Lambda of string * 'a exp
  | App    of 'a exp * 'a exp
\end{alltt}
\end{quote}

In a similar vein, optional terminating semicolons are allowed for expression sequences. For example, in a let expression:
\begin{quote}
\begin{alltt}
fun myfunc2(x, y) =
    let
      val z = x + y
    in
      f x;
      g y;
      h z;
    end
\end{alltt}
\end{quote}
The same applies to parenthesised expressions and sequences.


\subsubsection*{Changes to the Definition}

Section 2.8 (Grammar):
\begin{itemize}
\item In Figure 4, change the productions for exception handling and functions to, respectively:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{exp} ::=] & \mathit{exp}~{\tt{handle}}~\langle\mbox{\tt|}\rangle~\mathit{match} & \textrm{handle exception} \\
  & {\tt{fn}}~\langle\mbox{\tt|}\rangle~\mathit{match} & \textrm{function}
  \end{array}
  $$

\item Change the production for datatype bindings to:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  \mathit{datbind} &::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\langle\mbox{\tt|}\rangle~\mathit{conbind}~\langle{\tt{and}}~\mathit{datbind}\rangle
  \end{array}
  $$
\end{itemize}

Section 3.4 (Grammar for Modules):
\begin{itemize}
\item In Figure 7, change the productions for datatype descriptions to:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  \mathit{datdesc} &::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\langle\mbox{\tt|}\rangle~\mathit{condesc}~\langle{\tt{and}}~\mathit{datdesc}\rangle
  \end{array}
  $$
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item Adapt the syntax in the conclusion of rules 10, 12 and 28 appropriately.
\end{itemize}

Section 5.7 (Inference Rules):
\begin{itemize}
\item Adapt the syntax in the conclusion of rule 81 appropriately.
\end{itemize}

Section 6.7 (Inference Rules):
\begin{itemize}
\item Adapt the syntax in the conclusion of rules 104--106, 108 and 128 appropriately.
\end{itemize}

Section 7.3 (Inference Rules):
\begin{itemize}
\item Adapt the syntax in the conclusion of rule 178 appropriately.
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 15, change the rule for case expressions to
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{case}}~\mathit{exp}~{\tt{of}}~\langle\mbox{\tt|}\rangle~\mathit{match}~~~
  & \mbox{\tt(}{\tt{fn}}~\langle\mbox{\tt|}\rangle~\mathit{match}~\mbox{\tt)(}\mathit{exp}\mbox{\tt)} \\
  \hline
  \end{array}$
  \end{quote}

\item Change the left-hand side of the rule for sequential expressions to:
  \begin{quote}
  $\begin{array}{|l|}
  \hline
  \mbox{\tt(}\mathit{exp}_1~\mbox{\tt;}~\cdots~\mbox{\tt;}~\mathit{exp}_n~\mbox{\tt;}~\mathit{exp}~\langle\mbox{\tt;}\rangle\mbox{\tt)}~~\\
  \hline
  \end{array}$
  \end{quote}

\item Add a box as follows:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  \mbox{\tt(}\mathit{exp}~\mbox{\tt;}~\mbox{\tt)}~~~~
  & \mbox{\tt(}\mathit{exp}~\mbox{\tt)}~~~~ \\
  \hline
  \end{array}$
  \end{quote}

\item Change the left-hand side of the rule for let expressions to:
  \begin{quote}
  $\begin{array}{|l|}
  \hline
  {\tt{let}}~\mathit{dec}~{\tt{in}} \\
  ~~~~~~~~\mathit{exp}_1~\mbox{\tt;}~\cdots~\mbox{\tt;}~\mathit{exp}_n~\langle\mbox{\tt;}\rangle~{\tt{end}}~~\\
  \hline
  \end{array}$
  \end{quote}

\item In Figure 17, change the first line in the definition of function clauses to:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  & [\dots] \\
  \langle\mbox{\tt|}\rangle~\langle{\tt{op}}\rangle\mathit{vid}~\mathit{atpat}_{11}\cdots\mathit{atpat}_{1n}~\langle\mbox{\tt:}~\mathit{ty}_1\rangle~\mbox{\tt=}~\mathit{exp}_1~~
  & ~~\langle\mbox{\tt|}\rangle~\mbox{\tt(}\mathit{atpat}_{11}\mbox{\tt,}\dots\mbox{\tt,}\mathit{atpat}_{1n}\mbox{\tt)}~\mbox{\tt=>}~\mathit{exp}_1~\langle\mbox{\tt:}~\mathit{ty}_1\rangle \\
  {}[\dots] & [\dots] \\
  \hline
  \end{array}$
  \end{quote}

\item In Figure 21, change the production for datatype bindings to:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  \mathit{datbind} &::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\langle\mbox{\tt|}\rangle~\mathit{conbind}~\langle{\tt{and}}~\mathit{datbind}\rangle
  \end{array}
  $$
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 20, change the productions for sequences and let expressions to:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{atexp} ::=] & \mbox{\tt(}\mathit{exp}_1~\mbox{\tt;}~\cdots~\mbox{\tt;}~\mathit{exp}_n~\langle\mbox{\tt;}\rangle\mbox{\tt)} & \textrm{sequence, $n\geq1$} \\
  & ~{\tt{let}}~\mathit{dec}~{\tt{in}}~\mathit{exp}_1~\mbox{\tt;}~\cdots~\mbox{\tt;}~\mathit{exp}_n~\langle\mbox{\tt;}\rangle~{\tt{end}} & \textrm{local declaration, $n\geq1$}
%  & \mbox{\tt(}~\mathit{exp}~\langle\mbox{\tt;}\rangle~\mbox{\tt)} \\
  \end{array}
  $$

\item Remove the production for parenthesised expressions.

\item Change the productions for exception handling, functions, and case expressions to, respectively:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{exp} ::=] & \mathit{exp}~{\tt{handle}}~\langle\mbox{\tt|}\rangle~\mathit{match} & \textrm{handle exception} \\
  & {\tt{fn}}~\langle\mbox{\tt|}\rangle~\mathit{match} & \textrm{function} \\
  & {\tt{case}}~\mathit{exp}~{\tt{of}}~\langle\mbox{\tt|}\rangle~\mathit{match} & \textrm{case analysis}
  \end{array}
  $$

\item In Figure 21, change the production for datatype bindings to:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  \mathit{datbind} &::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\langle\mbox{\tt|}\rangle~\mathit{conbind}~\langle{\tt{and}}~\mathit{datbind}\rangle
  \end{array}
  $$

\item In Figure 21, change the production for $\mathit{fvalbind}$ (as defined in Appendix \ref{ext-syntaxfixes}) to:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{fvalbind} ::=] & \langle\mbox{\tt|}\rangle~\mathit{fmatch}~\langle{\tt{and}}~\mathit{fvalbind}\rangle \\
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Optional {\tt else} Branch}
\label{ext-else}

With imperative code it is often convenient to be allowed to omit the {\tt else} branch of a conditional:
\begin{quote}
\begin{alltt}
if \(\mathit{exp}\sb1\) then \(\mathit{exp}\sb2\)
\end{alltt}
\end{quote}
This is a simple derived form. The type of $\mathit{exp}_2$ has to be {\tt unit} if the {\tt else} branch is omitted. As usual, dangling {\tt else} phrases associate to the innermost {\tt if}.


\subsubsection*{Changes to the Definition}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 15, add a second rule for conditionals:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{if}}~\mathit{exp}_1~{\tt{then}}~\mathit{exp}_2~~~
  &
  {\tt{if}}~\mathit{exp}_1~{\tt{then}}~\mathit{exp}_2~{\tt{else}}~()~~ \\
  \hline
  \end{array}$
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item Append the following bullet:
  \begin{quote}
  Likewise, a conditional {\tt if}~$\mathit{exp}_1${\tt then}~\dots extends as far right as possible; thus, optional {\tt else} branches group with the innermost conditional.
  \end{quote}
  
\item In Figure 20, change the productions for conditionals to:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{exp} ::=] & {\tt{if}}~\mathit{exp}_1~{\tt{then}}~\mathit{exp}_2~\langle{\tt{else}}~\mathit{exp}_3\rangle & \textrm{conditional}
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Views}
\label{ext-views}

One of the most wanted features for SML (and other functional languages) are \emph{views}. Views enable the definition of abstract constructors for arbitrary types that can be used in patterns as if they were ordinary datatype constructors.

A view primarily defines a set of constructors and two functions for converting between these and the actual type the view is defined for. For example, consider a simple view allowing (positive) integers to be viewed as inductive numbers:

\begin{quote}
\begin{alltt}
viewtype peano = int as Zero | Succ of int
with
   fun from Zero     = 0
     | from (Succ n) = n+1
   fun to 0          = Zero
     | to n if (n>0) = Succ(n-1)
     | to n          = raise Domain
end
\end{alltt}
\end{quote}

This defines a view for type {\tt int}. The type constructor {\tt peano} provides a name for this view. Views may be defined for arbitrary types, and there may be arbitrarily many views for a given type.

Given the viewtype definition above, we can construct integers using the constructors it introduces:

\begin{quote}
\begin{alltt}
val n = Succ(Succ(Succ Zero))   (*) binds n to 3
val n = Succ 2                  (*) likewise
\end{alltt}
\end{quote}

The function {\tt from} given with the view declaration defines how a view constructor is converted to the underlying type, and is applied implicitly for every occurrence of a view constructor in an expression.

The inverse function {\tt to} defines how a value of the underlying type is interpreted in terms of the view constructors. It is applied implicitly whenever a value of the underlying type is matched against a pattern using one of the view's constructors:

\begin{quote}
\begin{alltt}
fun fac Zero    = 1
  | fac(Succ n) = Succ n * fac n
\end{alltt}
\end{quote}

This defines a factorial function on integers. When {\tt fac} is applied to an integer $i$, the function {\tt to} is implicitly applied to $i$ first and its result is matched against the constructors appearing in the definition of {\tt fac}.

The body of a view declaration may contain arbitrary (auxiliary) declarations, but must feature the two functions {\tt from} and {\tt to} with the appropriate types. None of the declarations is visible outside the view declaration.
\void{Note that it is legal, although rather pointless, for the injection function {\tt to} to be represented directly by a view constructor:

\begin{quote}
\begin{alltt}
viewtype t = int as to of int
with
   datatype t = datatype t   (*) replicates binding for `to'
   fun from (to x) = x
end
\end{alltt}
\end{quote}
}

Views must be used {\em consistently}, that is, a match may not use different views, or a view and concrete constants of the underlying type, {\em for the same position} in a pattern. For instance, the following is illegal:

\begin{quote}
\begin{alltt}
fun fac (0 | 1)  = 1
  | fac (Succ n) = Succ n * fac n
\end{alltt}
\end{quote}

Thanks to this restriction, the compiler is still able to check exhaustiveness and irredundancy of patterns, even in the presence of views.

Views are particularly interesting in conjunction with abstract types. For that purpose, it is possible to specify views in signatures:

\begin{quote}
\begin{alltt}
signature COMPLEX =
sig
   type complex
   viewtype cart = complex as Cart of real * real
   viewtype pole = complex as Pole of real * real
end
\end{alltt}
\end{quote}

A view specification can either be matched by a corresponding view declaration, or by an appropriate datatype definition:

\begin{quote}
\begin{alltt}
structure Complex :> COMPLEX =
struct
   datatype cart = Cart of real * real
   type complex = cart
   viewtype pole = complex as Pole of real * real
   with
      open Math
      fun to(Cart(x,y)) = Pole(sqrt(x*x + y*y), atan2(x,y))
      fun from(Pole(r,t)) = Cart(r*cos(t), r*sin(t))
   end
end
\end{alltt}
\end{quote}

The implementation of a viewtype is kept abstract, and both of the above views can be used uniformly where appropriate:

\begin{quote}
\begin{alltt}
open Complex
fun add(Cart(x1,y1), Cart(x2,y2)) = Cart(x1+x2, y1+y2)
fun mul(Pole(r1,t1), Pole(r2,t2)) = Pole(r1*r2, t1+t2)
\end{alltt}
\end{quote}

Instead of opening the structure, a view can also be pulled into scope (and thus enable unqualified use of its constructors) by a viewtype replication declaration, analogous to SML's datatype replication:

\begin{quote}
\begin{alltt}
viewtype cart = viewtype Complex.cart
\end{alltt}
\end{quote}

Apart from viewtype replication, the name of a view acts as a synonym for the underlying representation type -- except inside the view definition itself, where it used to denote the (otherwise anonymous) datatype representing the view.

More extensive examples can be found in {\tt doc/examples/views.sml}.

The design of views was inspired mainly by the papers of Wadler \cite{views} and Okasaki \cite{sml-views}. The main differences are the following:

\begin{itemize}
\item Views are named, to enable proper interplay with the module system, particularly view replication.
\item Unlike Okasaki's proposal, views are bidirectional, that is, they can be used to symmetrically construct {\em and} deconstruct values.
\item Unlike both proposals, views may not be mixed, thus still enabling standard pattern checks.
\item Unlike both proposals, view definitions are not recursive. In particular, the view constructors cannot be used as a view within its own definition.
\item Unlike Okasaki's proposal, the formal definition below does not support memoization. This could probably be added by means of informal comments.
\end{itemize}


\subsubsection*{Changes to the Definition}

Section 2.1 (Reserved Words):
\begin{itemize}
\item Add {\tt viewtype} to the list of reserved words.
\end{itemize}

Section 2.8 (Grammar):
\begin{itemize}
\item In Figure 4, add the following production for declarations:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{dec} ::=] & {\tt{viewtype}}~\mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~{\tt{as}}~\langle\mbox{\tt|}\rangle~\mathit{conbind} & \textrm{viewtype} \\
  & ~~~~~~~~{\tt{with}}~\mathit{dec}~{\tt{end}}
  \end{array}
  $$
\end{itemize}

Section 2.9 (Syntactic Restrictions):
\begin{itemize}
\item Extend the second bullet with:
  \begin{quote}
  [\dots] or the $\mathit{conbind}$ of a {\tt viewtype} declaration.
  \end{quote}

\item Extend the bullet added by the changes described in Appendix \ref{ext-semanticfixes} as follows:
  \begin{quote}
  [\dots]; similarly, in a declaration of the form ``{\tt{viewtype}} $\mathit{tyvarseq}$ $\mathit{tycon}$ {\tt=} $\mathit{ty}$ {\tt as} $\mathit{conbind}$ {\tt with} $\mathit{dec}$ {\tt end}'', any $\mathit{tyvar}$ occuring in $\mathit{ty}$ or $\mathit{conbind}$ must occur in $\mathit{tyvarseq}$.
  \end{quote}
\end{itemize}

Section 3.4 (Grammar for Modules):
\begin{itemize}
\item In Figure 7, add the following production for specifications:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{spec} ::=] & {\tt{viewtype}}~\mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~{\tt{as}}~\langle\mbox{\tt|}\rangle~\mathit{condesc} & \textrm{viewtype}
  \end{array}
  $$
\end{itemize}

Section 3.5 (Syntactic Restrictions):
\begin{itemize}
\item Extend the second bullet with:
  \begin{quote}
  [\dots] or the $\mathit{condesc}$ of a {\tt viewtype} spcification.
  \end{quote}

\item Replace the latter half of the fourth bullet with:
  \begin{quote}
  [\dots]; similarly, in a specification of the form ``{\tt{viewtype}} $\mathit{tyvarseq}$ $\mathit{tycon}$ {\tt=} $\mathit{ty}$ {\tt as} $\mathit{condesc}$'' or a signature expression of the form ``$\mathit{sigexp}$ {\tt where} {\tt type} $\mathit{tyvarseq}$ $\mathit{longtycon}$ {\tt=} $\mathit{ty}$'', any $\mathit{tyvar}$ occuring in $\mathit{ty}$ or $\mathit{condesc}$ must occur in $\mathit{tyvarseq}$.
  \end{quote}
\end{itemize}

Section 4.2 (Compound Objects):
\begin{itemize}
\item In Figure 10, Change the definition of value environments to:
  \begin{eqnarray*}
  \mathit{VE} &\in& \mbox{ValEnv} = \mbox{VId} \finto \mbox{TypeScheme} \times \mbox{ValStatus} \\
  \mathit{vs} &\in& \mbox{ValStatus} = \mbox{IdStatus} \cup \mbox{TyName}
  \end{eqnarray*}

\item In the last paragraph of the text, replace ``an identifier status'' with ``a value status'' and all occurrences of $\mathit{is}$ with $\mathit{vs}$.

\item In the last sentence, replace ``or an \emph{exception constructor}'' with ``an \emph{exception constructor} or a \emph{view constructor}'' and replace ``{\tt{v}}, {\tt c} or {\tt e}'' with ``{\tt{v}}, {\tt c}, {\tt e} or a type name $t$''.
\end{itemize}

Section 4.7 (Non-expansive Expressions):
\begin{itemize}
\item In the \emph{Restriction}, replace ``$\mathit{is}~\mbox{of}~C(\mathit{longvid}) \in \{{\tt{c}},{\tt{e}}\}$'' with ``$\mathit{vs}~\mbox{of}~C(\mathit{longvid}) \neq {\tt{v}}$''.
\end{itemize}

Section 4.8 (Closure):
\begin{itemize}
\item Replace all occurrences of $\mathit{is}$ with $\mathit{vs}$.
\end{itemize}

Section 4.9 (Type Structures and Type Environments):
\begin{itemize}
\item Extend the first sentence with:
  \begin{quote}
  [\dots], or there is a type name $t$ such that for all $(\sigma,\mathit{vs}) \in \mbox{Ran}\,\mathit{VE}$, $\mathit{vs} = t$.
  \end{quote}
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item In rule 2, 15 (as modified by change described in Appendix \ref{ext-recursive}), 34 and 35, replace occurrences of $\mathit{is}$ with $\mathit{vs}$.

\item Add the following rule for declarations:
% t notin T of C    arity t = k    t does not admit equality
% tyvarseq = a^(k)    C |- ty => tau    C,a^(k)t |- conbind => VE
% C oplus (Clos VE,{tycon|->(t,Clos VE)}) |- dec => E
% sigma of E(from) > !a^(k).a^(k)t->tau    sigma of E(to) > !a^(k).tau->a^(k)t
% VE' = {vid|->(sigma{/\a^(k).tau/t},t) ; (Clos VE)(vid) = (sigma,c)}
% TE = {tycon|->(/\a^(k).tau,VE')}
% ----------------------------------------------------------------------- (17a)
% C |- viewtype tyvarseq tycon = ty as conbind with dec end => (VE',TE) in Env

  \begin{equation}
  \tag{17a}
  \frac{
  \begin{array}{@{}c@{}}
  t \notin T\,\mbox{of}\,C
  \qquad
  \mbox{arity}\,t = k
  \qquad
  \mbox{$t$ does not admit equality}
  \\
  \mathit{tyvarseq} = \alpha^{(k)}
  \qquad
  C \vdash \mathit{ty} \Rightarrow \tau
  \qquad
  C,\alpha^{(k)}t \vdash \mathit{conbind} \Rightarrow \mathit{VE}
  \\
  C \oplus (\mbox{Clos}\mathit{VE},\{\mathit{tycon}\mapsto(t,\mbox{Clos}\mathit{VE})\}) \vdash \mathit{dec} \Rightarrow E
  \\
  \sigma~\mbox{of}~E({\tt{from}}) \succ \forall\alpha^{(k)}.\alpha^{(k)}t\to\tau
  \qquad
  \sigma~\mbox{of}~E({\tt{to}}) \succ \forall\alpha^{(k)}.\tau\to\alpha^{(k)}t
  \\
  \mathit{VE}' = \{\mathit{vid}\mapsto(\sigma\{\Lambda\alpha^{(k)}.\tau/t\}, t)\;;\;(\mbox{Clos}\mathit{VE})(\mathit{vid}) = (\sigma,{\tt c})\}
  \\
  \mathit{TE} = \{\mathit{tycon}\mapsto(\Lambda\alpha^{(k)}.\tau,\mathit{VE}')\}
  \end{array}
  }{
  \begin{array}{@{}l@{}}
  C \vdash {\tt viewtype}~\mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~{\tt as}~\mathit{conbind}~{\tt with}~\mathit{dec}~{\tt end} \Rightarrow \mbox{$(\mathit{VE}',\mathit{TE})$ in Env}
  \end{array}
  }
  \end{equation}

  and add a comment:
  \begin{itemize}
  \item[(17a)] Unlike a datatype, a viewtype is not recursive.
  \emph{Comment:}
  \end{itemize}
\end{itemize}

Section 4.11 (Further Restrictions):
\begin{itemize}
\item Add a fourth point:
  \begin{enumerate}
  \item[4.] The compiler must issue an error if a match or a pattern in a value binding makes inconsistent use of view constructors, such that there might exist a value that, in a single matching operation, has to be matched against view constructors of different view types, or against a view constructor and a pattern that is not a view. For example, if {\tt C} and {\tt D} are view constructors of different views for type {\tt int}, then the patterns ``{\tt{C | D}}'' or ``{\tt{2 as C}}'' are invalid, likewise the match ``{\tt(\_,C) =>} \dots {\tt| (\_,D) =>} \dots''. This restriction ensures that the checks described in the previous points are always possible.
  \end{enumerate}
\end{itemize}

Section 5.5 (Enrichment):
\begin{itemize}
\item In the third point defining $E_1 \succ E_2$, replace all occurrences of $\mathit{is}$ with $\mathit{vs}$ and replace the line defining enrichment on identifier status with:
  \begin{quote}
  $\mathit{vs}_1 = \mathit{vs}_2$ ~~~ or ~~~
  $\mathit{vs}_2 = {\tt v}$ ~~~ or ~~~
  $\mathit{vs}_1 = {\tt c}$ and $\mathit{vs}_2 = t$
  \end{quote}

\item Replace the second point defining $(\theta_1,\mathit{VE}_1) \succ (\theta_2,\mathit{VE}_2)$ with:
  \begin{enumerate}
  \item[2.] Either $\mathit{VE}_2 = \{\}$, or $\mathit{VE}_1 = \mathit{VE}_2$, or $\mathit{VE}_1 = \{\mathit{vid}\mapsto(\sigma,{\tt{c}}) \;;\; \mathit{VE}_2(\mathit{vid}) = (\sigma,\mathit{vs})\}$
  \end{enumerate}
\end{itemize}

Section 5.7 (Inference Rules):
\begin{itemize}
\item In rule 2, 34 and 35, replace all occurrences of $\mathit{is}$ with $\mathit{vs}$.

\item Add the following rule for specifications:
% t notin T of B    arity t = k    t does not admit equality
% tyvarseq = a^(k)    C of B |- ty => tau    C of B,a^(k)t |- condesc => VE
% VE' = {vid|->(sigma{/\a^(k).tau/t},t) ; (Clos VE)(vid) = (sigma,c)}
% TE = {tycon|->(/\a^(k).tau,VE')}
% --------------------------------------------------------------------------- (71a)
% B |- viewtype tyvarseq tycon = ty as condesc => (VE',TE) in Env

  \begin{equation}
  \tag{71a}
  \frac{
  \begin{array}{@{}c@{}}
  t \notin T\,\mbox{of}\,B
  \qquad
  \mbox{arity}\,t = k
  \qquad
  \mbox{$t$ does not admit equality}
  \\
  \mathit{tyvarseq} = \alpha^{(k)}
  \qquad
  C\,\mbox{of}\,B \vdash \mathit{ty} \Rightarrow \tau
  \qquad
  C\,\mbox{of}\,B,\alpha^{(k)}t \vdash \mathit{condesc} \Rightarrow \mathit{VE}
  \\
  \mathit{VE}' = \{\mathit{vid}\mapsto(\sigma\{\Lambda\alpha^{(k)}.\tau/t\}, t)\;;\;(\mbox{Clos}\mathit{VE})(\mathit{vid}) = (\sigma,{\tt c})\}
  \\
  \mathit{TE} = \{\mathit{tycon}\mapsto(\Lambda\alpha^{(k)}.\tau,\mathit{VE}')\}
  \end{array}
  }{
  \begin{array}{@{}l@{}}
  B \vdash {\tt viewtype}~\mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~{\tt as}~\mathit{condesc} \Rightarrow \mbox{$(\mathit{VE}',\mathit{TE})$ in Env}
  \end{array}
  }
  \end{equation}
\end{itemize}

Section 6.1 (Reduced Syntax):
\begin{itemize}
\item In the first bullet, remove ``constructor and''.

\item Replace the second bullet with:
   \begin{quote}
   All equations ``{\tt=} $\mathit{ty}$'' are omitted from {\tt viewtype} declarations.
   \end{quote}
\end{itemize}

Section 6.3 (Compound Objects):
\begin{itemize}
\item In Figure 13, change the definition of value environments to:
  \begin{eqnarray*}
  \mathit{VE} &\in& \mbox{ValEnv} = \mbox{VId} \finto \mbox{Val} \times \mbox{ValStatus} \\
  \mathit{vs} &\in& \mbox{ValStatus} = \mbox{IdStatus} \cup (\mbox{Val} \times \mbox{VId})
  \end{eqnarray*}
\end{itemize}

Section 6.7 (Inference Rules):
\begin{itemize}
\item In rule 91, replace $\mathit{is}$ with $\mathit{vs}$.

\item Add the following rule for declarations:
% |- conbind => VE    C+(VE,{tycon|->VE}) |- dec => E'
% v of E'(from), v of E'(to) |- conbind => VE'    TE = {tycon|->VE'}
% ----------------------------------------------------------------------- (116a)
% E |- viewtype tyvarseq tycon as conbind with dec end => (VE',TE) in Env

  \begin{equation}
  \tag{116a}
  \frac{
  \begin{array}{@{}c@{}}
  \vdash \mathit{conbind} \Rightarrow \mathit{VE}
  \qquad
  E + (\mathit{VE},\{\mathit{tycon}\mapsto\mathit{VE}\}) \vdash \mathit{dec} \Rightarrow E'
  \\
  v~\mbox{of}~E'({\tt{from}}), v~\mbox{of}~E'({\tt{to}}) \vdash \mathit{conbind} \Rightarrow \mathit{VE}'
  \qquad
  \mathit{TE} = \{\mathit{tycon}\mapsto\mathit{VE}'\}
  \end{array}
  }{
  \begin{array}{@{}l@{}}
  E \vdash {\tt viewtype}~\mathit{tyvarseq}~\mathit{tycon}~{\tt as}~\mathit{conbind}~{\tt with}~\mathit{dec}~{\tt end} \Rightarrow \mbox{$(\mathit{VE}',\mathit{TE})$ in Env}
  \end{array}
  }
  \end{equation}

\item In rule 129, add ``$\langle{\tt{of}}~\mathit{ty}\rangle$'' to the phrase in the conclusion, and replace existing single brackets ``$\langle\dots\rangle$'' with double brackets  ``$\langle\langle\dots\rangle\rangle$''.

\item Add the following rules for constructor bindings:
% {from|->(v_from,v), vid'|->(vid,v)} in Env |- from vid' => v    vid' neq from
% <v_from,v_to |- conbind => VE>
% ---------------------------------------------------------------------- (129a)
% v_from,v_to |- vid <| conbind> => {vid|->(v,(v_to,vid))}<+VE> in Env

  \begin{equation}
  \tag{129a}
  \frac{
  \begin{array}{@{}c@{}}
  \mbox{$\{{\tt{from}}\mapsto(v_{\tt{from}},{\tt{v}}), \mathit{vid}'\mapsto(\mathit{vid},{\tt{v}})\}$ in Env} \vdash {\tt{from}}~\mathit{vid}' \Rightarrow v
  \qquad
  \mathit{vid}' \neq {\tt{from}}
  \\
  \langle v_{\tt{from}},v_{\tt{to}} \vdash \mathit{conbind} \Rightarrow \mathit{VE} \rangle
  \end{array}
  }{
  v_{\tt{from}},v_{\tt{to}} \vdash \mathit{vid}~\langle\mbox{\tt|}~\mathit{conbind}\rangle \Rightarrow \mbox{$\{\mathit{vid}\mapsto(v,(v_{\tt{to}},\mathit{vid}))\}\langle+\mathit{VE}\rangle$ in Env}
  }
  \end{equation}

% v = (vid'' => from (vid' vid''), E, {}) in Val
% from neq vid' neq vid'' neq from    E = {from|->(v_from,v), vid'|->(vid,v)} in Env
% <v_from,v_to |- conbind => VE>
% ---------------------------------------------------------------------- (129b)
% v_from,v_to |- vid of <| conbind> => {vid|->(v,(v_to,vid))}<+VE> in Env

  \begin{equation}
  \tag{129b}
  \frac{
  \begin{array}{@{}c@{}}
  v = \mbox{$(\mathit{vid}''~\mbox{\tt=>}~{\tt{from}}~\mbox{\tt(}\mathit{vid}'~\mathit{vid}''\mbox{\tt)}, E, \{\})$ in Val}
  \\
  {\tt{from}} \neq \mathit{vid}' \neq \mathit{vid}'' \neq {\tt{from}}
  \qquad
  E = \mbox{$\{{\tt{from}}\mapsto(v_{\tt{from}},{\tt{v}}), \mathit{vid}'\mapsto(\mathit{vid},{\tt{v}})\}$ in Env}
  \\
  \langle v_{\tt{from}},v_{\tt{to}} \vdash \mathit{conbind} \Rightarrow \mathit{VE} \rangle
  \end{array}
  }{
  v_{\tt{from}},v_{\tt{to}} \vdash \mathit{vid}~{\tt{of}}~\mathit{ty}~\langle\mbox{\tt|}~\mathit{conbind}\rangle \Rightarrow \mbox{$\{\mathit{vid}\mapsto(v,(v_{\tt{to}},\mathit{vid}))\}\langle+\mathit{VE}\rangle$ in Env}
  }
  \end{equation}

  and add a comment:
  \begin{itemize}
  \item[(129a),(129b)] In these and the rules 137a, 137b and 147a, 147b the choice of $\mathit{vid}'$ and $\mathit{vid}''$ is arbitrary, up to the side conditions stated in the rules.
  \emph{Comment:}
  \end{itemize}

\item In rule 135, replace $\mathit{is}$ with $\mathit{vs}$.

\item Add the following rules for atomic patterns:
% E(longvid) = (v',(v_to,vid))    vid' neq to
% {to|->(v_to,v), vid'|->(v,v)} in Env |- to vid' => vid
% ------------------------------------------------------- (137a)
% E,v |- longvid => {}

  \begin{equation}
  \tag{137a}
  \frac{
  \begin{array}{@{}c@{}}
  E(\mathit{longvid}) = (v', (v_{\tt{to}},\mathit{vid}))
  \qquad
  \mathit{vid'} \neq {\tt{to}}
  \\
  \mbox{$\{{\tt{to}}\mapsto(v_{\tt{to}},{\tt{v}}), \mathit{vid'}\mapsto(v,{\tt{v}})\}$ in Env} \vdash {\tt{to}}~\mathit{vid'} \Rightarrow \mathit{vid}
  \end{array}
  }{
  E,v \vdash \mathit{longvid} \Rightarrow \{\}
  }
  \end{equation}

% E(longvid) = (v',(v_to,vid))    vid' neq to
% {to|->(v_to,v), vid'|->(v,v)} in Env |- to vid' => v''    v'' neq vid
% ------------------------------------------------------- (137b)
% E,v |- longvid => FAIL

  \begin{equation}
  \tag{137b}
  \frac{
  \begin{array}{@{}c@{}}
  E(\mathit{longvid}) = (v', (v_{\tt{to}},\mathit{vid}))
  \qquad
  \mathit{vid'} \neq {\tt{to}}
  \\
  \mbox{$\{{\tt{to}}\mapsto(v_{\tt{to}},{\tt{v}}), \mathit{vid'}\mapsto(v,{\tt{v}})\}$ in Env} \vdash {\tt{to}}~\mathit{vid'} \Rightarrow v''
  \qquad
  v'' \neq \mathit{vid}
  \end{array}
  }{
  E,v \vdash \mathit{longvid} \Rightarrow \mbox{FAIL}
  }
  \end{equation}

\item Add the following rules for patterns:
% E(longvid) = (v',(v_to,vid))    vid' neq to
% {to|->(v_to,v), vid'|->(v,v)} in Env |- to vid' => (vid,v'')
% E,v'' |- atpat => VE/FAIL
% ------------------------------------------------------- (147a)
% E,v |- longvid atpat => VE/FAIL

  \begin{equation}
  \tag{147a}
  \frac{
  \begin{array}{@{}c@{}}
  E(\mathit{longvid}) = (v', (v_{\tt{to}},\mathit{vid}))
  \qquad
  \mathit{vid'} \neq {\tt{to}}
  \\
  \mbox{$\{{\tt{to}}\mapsto(v_{\tt{to}},{\tt{v}}), \mathit{vid'}\mapsto(v,{\tt{v}})\}$ in Env} \vdash {\tt{to}}~\mathit{vid'} \Rightarrow (\mathit{vid},v'')
  \\
  E,v'' \vdash \mathit{atpat} \Rightarrow \mathit{VE}/\mbox{FAIL}
  \end{array}
  }{
  E,v \vdash \mathit{longvid}~\mathit{atpat} \Rightarrow \mathit{VE}/\mbox{FAIL}
  }
  \end{equation}

% E(longvid) = (v',(v_to,vid))    vid' neq to
% {to|->(v_to,v), vid'|->(v,v)} in Env |- to vid' => v''    v'' notin {vid} * Val
% -------------------------------------------------------------------------- (147b)
% E,v |- longvid atpat => FAIL

  \begin{equation}
  \tag{147b}
  \frac{
  \begin{array}{@{}c@{}}
  E(\mathit{longvid}) = (v', (v_{\tt{to}},\mathit{vid}))
  \qquad
  \mathit{vid'} \neq {\tt{to}}
  \\
  \mbox{$\{{\tt{to}}\mapsto(v_{\tt{to}},{\tt{v}}), \mathit{vid'}\mapsto(v,{\tt{v}})\}$ in Env} \vdash {\tt{to}}~\mathit{vid'} \Rightarrow v''
  \qquad
  v'' \notin \{\mathit{vid}\}\times\mbox{Val}
  \end{array}
  }{
  E,v \vdash \mathit{longvid}~\mathit{atpat} \Rightarrow \mbox{FAIL}
  }
  \end{equation}
\end{itemize}

Section 7.1 (Reduced Syntax):
\begin{itemize}
\item In the first bullet, remove ``constructor and''.
\end{itemize}

Section 7.2 (Compound Objects):
\begin{itemize}
\item In Figure 14, change the definition of value interfaces to:
  \begin{eqnarray*}
  \mathit{VI} &\in& \mbox{ValInt} = \mbox{VId} \finto \mbox{ValIntStatus} \\
  \mathit{vis} &\in& \mbox{ValIntStatus} = \mbox{IdStatus} \cup \{{\tt{f}}\}
  \end{eqnarray*}

\item Change the definition of $\mbox{Inter} : \mbox{ValEnv} \to \mbox{ValInt}$ to:
  \begin{eqnarray*}
  \mbox{Inter}(\mathit{VE}) &=& \{\mathit{vid}\mapsto\mathit{is} \;;\; \mathit{VE}(\mathit{vid}) = (v,\mathit{is})\} \\
  &&+~\{\mathit{vid}\mapsto{\tt{f}} \;;\; \mathit{VE}(\mathit{vid}) = (v,(v',\mathit{vid}''))\}
  \end{eqnarray*}
  and extend the following sentence with:
  \begin{quote}
  [\dots] and abstracting view constructors with {\tt f}.
  \end{quote}

\item Change the definition of $\downarrow : \mbox{ValEnv} \times \mbox{ValInt} \to \mbox{ValEnv}$ to:
  \begin{eqnarray*}
  \mathit{VE}\downarrow\mbox{ValInt} &=& \{\mathit{vid}\mapsto(v,\mathit{is}) \;;\; \mathit{VE}(\mathit{vid}) = (v,\mathit{vs})~\mbox{and}~\mathit{VE}(\mathit{vid}) = \mathit{is}\} \\
  &&+~\{\mathit{vid}\mapsto(v,\mathit{vs}) \;;\; \mathit{VE}(\mathit{vid}) = (v,\mathit{vs})~\mbox{and}~\mathit{VE}(\mathit{vid}) = {\tt{f}}\}
  \end{eqnarray*}

\item In the parenthesised sentence following, replace ``identifier status'' with ``value status'' and add:
  \begin{quote}
  [\dots], except in the case of view constructors.
  \end{quote}
\end{itemize}

Section 7.3 (Inference Rules):
\begin{itemize}
\item Add the following rule for specifications:
% |- condesc => VI    VI' = {vid|->f ; VI(vid) = c}    TI = {tycon|->VI'}
% ---------------------------------------------------------------------- (169a)
% IB |- viewtype tyvarseq tycon as condesc => (VI',TI) in Int

  \begin{equation}
  \tag{169a}
  \frac{
  \begin{array}{@{}c@{}}
  \vdash \mathit{condesc} \Rightarrow \mathit{VI}
  \qquad
  \mathit{VI}' = \{\mathit{vid}\mapsto{\tt{f}}\;;\;\mathit{VI}(\mathit{vid}) = {\tt c}\}
  \qquad
  \mathit{TI} = \{\mathit{tycon}\mapsto\mathit{VI}'\}
  \end{array}
  }{
  \begin{array}{@{}l@{}}
  \mathit{IB} \vdash {\tt viewtype}~\mathit{tyvarseq}~\mathit{tycon}~{\tt as}~\mathit{condesc} \Rightarrow \mbox{$(\mathit{VI}',\mathit{TI})$ in Int}
  \end{array}
  }
  \end{equation}

\item In rule 179, add ``$\langle{\tt{of}}~\mathit{ty}\rangle$'' to the phrase in the conclusion, and replace existing single brackets ``$\langle\dots\rangle$'' with double brackets  ``$\langle\langle\dots\rangle\rangle$''.
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 17, extend the box for declarations as follows:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{viewtype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{viewtype}}~\mathit{longtycon}~~
  & {\tt{datatype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{datatype}}~\mathit{longtycon}~~ \\
  \hline
  \end{array}$
  \end{quote}

\item In Figure 19, extend the box for specifications as follows:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{viewtype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{viewtype}}~\mathit{longtycon}~~
  & {\tt{datatype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{datatype}}~\mathit{longtycon}~~ \\
  \hline
  \end{array}$
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 21, add the following productions for declarations:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{dec} ::=] & {\tt{viewtype}}~\mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~{\tt{as}}~\langle\mbox{\tt|}\rangle~\mathit{conbind} & \textrm{viewtype} \\
  & ~~~~~~~~{\tt{with}}~\mathit{dec}~{\tt{end}} \\
  & {\tt{viewtype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{viewtype}}~\mathit{longtycon} & \textrm{viewtype replication}
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

Apart from the additional keyword {\tt viewtype}, this is a conservative extension.
%It may complicate pattern match compilation, but the homogenity requirement in the use of views keeps it at a minimum.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Do Declarations}
\label{ext-do}

A very frequent idiom in SML are declarations of the form
\begin{quote}
\begin{alltt}
val _ = exp
\end{alltt}
\end{quote}
which are used to evaluate an expression for its side effects. This idiom is somewhat verbose and ugly.

On the toplevel, expressions can be evaluated by simply writing them in place of a declaration (which abbreviates a declaration of {\tt it}). However, this form is not available in local scope, and moreover does require putting a semicolon before and after the expression, which is somewhat counterintuitive. This form only is useful in a REPL.

A new derived form simply abbreviates ``{\tt val () =}'' with the keyword {\tt do}.

\subsubsection*{Changes to the Definition}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 17, add the following to the Declarations box:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{do}}~\mathit{exp}~~~~~~
  & {\tt{val}}~\mbox{\tt()}~\mbox{\tt=}~\mathit{exp}~~~ \\
  \hline
  \end{array}$
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 21, add the following production for declarations:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{dec} ::=] & {\tt{do}}~\mathit{exp} & \textrm{evaluation}
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Withtype in Signatures}
\label{ext-withtype}

The absence of the {\tt withtype} derived form in signatures clearly is an oversight in the definition. The derived form is as useful in signatures as it is in declarations.

\subsubsection*{Changes to the Definition}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 19, add the following to the Specifications box:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{datatype}}~\mathit{datdesc}~{\tt{withtype}}~\mathit{typbind}~~~
  & {\tt{datatype}}~\mathit{datdesc}'~\mbox{\tt;}~{\tt{type}}~\mathit{typbind} \\
  \hline
  \end{array}$
  \end{quote}
  and extend the note as follows 
  \begin{quote}
  (see the note in text concerning $\mathit{datdesc}'$, $\mathit{typdesc}$, and $\mathit{longtycon}_1,\dots,\mathit{longtycon}'_m$) 
  \end{quote}

\item Append the following paragraph to the text:
  \begin{quote}
  In the form involving {\tt withtype}, the identifiers bound by $\mathit{datdesc}$ and by $\mathit{typbind}$ must be distinct. The transformed description $\mathit{datdesc}'$ is obtained from $\mathit{datdesc}$ by expanding out all the definitions made by $\mathit{typbind}$, analogous to $\mathit{datbind}$ above. The phrase ``{\tt type} $\mathit{typbind}$'' can be reinterpreted as a type specification that is subject to further transformation.
  \end{quote}
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension, which is already supported by most implementations.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Higher-order Functors}
\label{ext-higherfunctors}

To support higher-order modules, structure expressions are generalised to include functor expressions, analogous to function expressions in the core:
\begin{quote}
\begin{alltt}
fct \(\mathit{strid}\) : \(\mathit{sigexp}\) => \(\mathit{strexp}\)
\end{alltt}
\end{quote}
Likewise, signature expressions may denote dependent functor signatures:
\begin{quote}
\begin{alltt}
fct \(\mathit{strid}\) : \(\mathit{sigexp}\sb1\) -> \(\mathit{sigexp}\sb2\)
\end{alltt}
\end{quote}
As a derived form, non-dependent functor signatures (where $\mathit{strid}$ does not occur in $\mathit{sigexp}_2$) may be abbreviated as follows:
\begin{quote}
\begin{alltt}
\(\mathit{sigexp}\sb1\) -> \(\mathit{sigexp}\sb2\)
\end{alltt}
\end{quote}
SML's functor declarations are degraded to a mere derived forms, analogous to function declarations with {\tt fun} in the core language. They support curried functors:
\begin{quote}
\begin{alltt}
functor \(\mathit{strid}\) (\(\mathit{strid}\sb1\) : \(\mathit{sigexp}\sb1\)) \(\dots\) (\(\mathit{strid}\sb{n}\) : \(\mathit{sigexp}\sb{n}\)) \(\langle\): \(\mathit{sigexp}\rangle\)
           = \(\mathit{strexp}\)
\end{alltt}
\end{quote}
For uniformity, and to avoid subtle syntax, the identifier classes for structures and functors are merged.
As another derived form, SML/NJ compatible syntax is provided for functor descriptions in signatures:
\begin{quote}
\begin{alltt}
functor \(\mathit{strid}\) (\(\mathit{strid}\sb1\) : \(\mathit{sigexp}\sb1\)) \(\dots\) (\(\mathit{strid}\sb{n}\) : \(\mathit{sigexp}\sb{n}\)) : \(\mathit{sigexp}\)
\end{alltt}
\end{quote}

Functor application syntax is generalised to
\begin{quote}
\begin{alltt}
\(\mathit{strexp}\sb1\) \(\mathit{strexp}\sb2\)
\end{alltt}
\end{quote}
as in the core. Parentheses are allowed anywhere in structure and signature expressions. The derived form allowing a parenthesised declaration $\mathit{strdec}$ as a functor argument is maintained and generalised by enabling
\begin{quote}
\begin{alltt}
( \(\mathit{strdec}\) )
\end{alltt}
\end{quote}
to abbreviate a structure in all contexts. For symmetry,
\begin{quote}
\begin{alltt}
( \(\mathit{spec}\) )
\end{alltt}
\end{quote}
can be used to abbreviate a signature.
Particularly, it can  abbreviate a functor argument:
\begin{quote}
\begin{alltt}
fct (\(\mathit{spec}\)) => \(\mathit{strexp}\)
fct (\(\mathit{spec}\)) -> \(\mathit{sigexp}\)
\end{alltt}
\end{quote}
which is also allowed in the functor declaration and specification derived forms, generalising the similar derived form known from SML.

The semantics of higher-order functors is kept simple. All functors are fully generative. The only change to semantic objects of the Definition is in the codomain of stucture environments StrEnv, which may now contain functors.

More extensive examples can be found in {\tt doc/examples/higher-order-functors.sml}.

\subsubsection*{Changes to the Definition}

Section 3.1 (Reserved Words):
\begin{itemize}
\item Add {\tt fct} to the list of additional reserved words for modules.
\end{itemize}

Section 3.2 (Identifiers):
\begin{itemize}
\item Replace the first sentence with:
  \begin{quote}
  The only additional identifier class for Modules is SigId (signature identifiers).
  \end{quote}

\item Replace the start of the second sentence with ``Signature identifiers \dots''.
\end{itemize}

Section 3.4 (Grammar for Modules):
\begin{itemize}
\item In Figure 5, remove FunDec and FunBind from the list of phrase classes.

\item In Figure 6, replace the $\mathit{strexp}$ production ``$\mathit{funid}$ {\tt(} $\mathit{strexp}$ {\tt)}'' for functor application with:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{strexp} ::=] & \mathit{strexp}_1~\mathit{strexp}_2 & \textrm{functor application (L)}
  \end{array}
  $$
  and add the following productions:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{strexp} ::=] & {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigexp}~\mbox{\tt=>}~\mathit{strexp} & \textrm{functor} \\
  & \mbox{\tt(}~\mathit{strexp}~\mbox{\tt)}
  \end{array}
  $$

\item In Figure 6, add the following $\mathit{sigexp}$ productions:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{sigexp} ::=] & {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigexp}_1~\mbox{\tt->}~\mathit{sigexp}_2 & \textrm{functor} \\
  & \mbox{\tt(}~\mathit{sigexp}~\mbox{\tt)}
  \end{array}
  $$

\item In Figure 8, remove the productions for $\mathit{fundec}$ and $\mathit{funbind}$, and the functor declaration production for $\mathit{topdec}$. Change the caption of the figure to ``Grammar: Top-level Declarations''.
\end{itemize}

Section 3.5 (Syntactic Restrictions):
\begin{itemize}
\item In the first bullet, change ``$\mathit{strbind}$, $\mathit{sigbind}$, or $\mathit{funbind}$'' to ``$\mathit{strbind}$ or $\mathit{sigbind}$''.
\end{itemize}

Section 4.2 (Compound Objects):
\begin{itemize}
\item In Figure 10, change the definition of StrEnv as follows:
  \begin{eqnarray*}
  \mathit{SE} &\in& \mbox{StrEnv} = \mbox{StrId} \finto \mbox{Mod} \\
  \mathit{M} &\in& \mbox{Mod} = \mbox{Env} \cup \mbox{FunSig}
  \end{eqnarray*}
  Note: a more consistent treatment would include renaming $\mathit{SE} \in \mbox{StrEnv}$ to $\mathit{ME} \in \mbox{ModEnv}$, but we refrain form that here, in order to keep the number of changes as small as possible.

\item To the paragraph referring to Figure 10, add the following sentence:
  \begin{quote}
  The object class FunSig of functor signatures is defined in Section 5.1.
  \end{quote}
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item In the last paragraph of the introduction, remove component $F$ from the equation decomposing $B$, and replace ``other components $F$ and $G$'' with ``other component $G$''.
\end{itemize}

Section 5.1 (Semantic Objects):
\begin{itemize}
\item In Figure 11, change definitions as follows:
  \begin{eqnarray*}
  \Sigma~\mbox{or}~(T)M &\in& \mbox{Sig} = \mbox{TyNameSet} \times \mbox{Mod} \\
  \Phi~\mbox{or}~(T)(M,(T')M') &\in& \mbox{FunSig} = \mbox{TyNameSet} \times \mbox{Mod} \times \mbox{Sig}
  \end{eqnarray*}
\end{itemize}

Section 5.3 (Signature Instantiation):
\begin{itemize}
\item Replace all occurrences of $E$ with $M$.
\void{
\item Replace with:
  \begin{quote}
  A module $M_2$ \emph{is a $\varphi$-instance} of a signature $\Sigma_1 = (T_1)M_1$, written $\Sigma_1 \geq_\varphi M_2$, if $\varphi(M_1) = M_2$ and $\mbox{Supp}\;\varphi \subseteq T_1$. A module $M_2$ \emph{is an instance} of a signature $\Sigma_1 = (T_1)M_1$, written $\Sigma_1 \geq M_2$, if there exists a realisation $\varphi$ such that $\Sigma_1 \geq_\varphi M_2$.
  \end{quote}
}
\end{itemize}

Section 5.4 (Functor Signature Instantiation):
\begin{itemize}
\item Replace all pairs of the form ``$(E,(T')E')$'' with respective forms ``$(M,(T')M')$.
\end{itemize}

Section 5.5 (Enrichment):
\begin{itemize}
\item Append the following to item 1:
  \begin{quote}
  [\dots], where $M_1 \succ M_2$ either means $M_1 = E_1$ and $M_2 = E_2$ such that $E_1$ enriches $E_2$, or $M_1 = \Phi_1$ and $M_2 = \Phi_2$ such that $\Phi_1 \succ \Phi_2$, as defined in Section 5.6.
  \end{quote}
\end{itemize}

Section 5.6 (Signature Matching):
\begin{itemize}
\item Replace all occurrences of ``an environment'' with ``a module'' and $E$ with $M$.

\item Append the following paragraphs:\footnote{The defined notion of matching on functor signatures is relatively simplistic. In particular, it make transparent functor signature ascription behave as opaque ascription. For example, the module expression
\begin{quote}
\begin{alltt}
(fct () => (type t = int)) : (fct () -> (type t))
\end{alltt}
\end{quote}
will have signature {\tt (fct () -> (type t))}, \emph{not} {\tt (fct () -> (type t = int))} as one might expect. A consistent treatment of transparency is complex in the framework of the Definition and probably not worth the trouble \cite{higherfunctors}. It could be added later as a conservative extension.}
  \begin{quote}
\void{
  A signature $\Sigma_1 = (T_1)M_1$ \emph{matches} a signature $\Sigma_2 = (T_2)M_2$, written $\Sigma_1 \succ \Sigma_2$, if $M_1$ matches $\Sigma_2$ and $T_1 \cap \mbox{tynames}\,\Sigma_2 = \emptyset$ (possibly after changing the bound names in $T_1$).
}
  A signature $\Sigma_1 = (T_1)M_1$ \emph{matches} a signature $\Sigma_2 = (T_2)M_2$, written $\Sigma_1 \succ \Sigma_2$, if there exists a realisation $\varphi$ such that $\Sigma_2 \geq \varphi(M_2) \prec M_1$ and $T_1 \cap \mbox{tynames}\,\Sigma_2 = \emptyset$. %(possibly after changing the bound names in $T_1$).

  A functor signature $\Phi_1 = (T_1)(M_1,\Sigma_1)$ \emph{matches} a functor signature $\Phi_2 = (T_2)(M_2,\Sigma_2)$, written $\Phi_1 \succ \Phi_2$, if there exists a realisation $\varphi$ such that $(T_1)M_1 \geq \varphi(M_1) \prec M_2$ and $\varphi(\Sigma_1) \succ \Sigma_2$ and $T_1 \cap \mbox{tynames}\,\Phi_2 = \emptyset$. %(possibly after changing the bound names in $T_1$).
  \end{quote}
\end{itemize}

Section 5.7 (Inference Rules):
\begin{itemize}
\item In the 2nd paragraph of the introduction, remove component $F$ from the equation decomposing $B$, and remove ``$\mbox{tynames}\;F \cup$'' from the set inequation.

\item Change the box giving the form of inference rules for structure expressions to:
  $$
  \boxed{B \vdash \mathit{strexp} \Rightarrow M}
  $$
  and replace all occurences of $E$ with $M$ in rules 51--53, and $E_2$ with $M$ in rule 55.

\item Change rule 54 to:
% B |- strexp1 => Phi    B |- strexp2 => M
% Phi >= (M'',(T')M'), M \succ M''
% (tynames M \cup T of B) \cap T' = 0
% ------------------------------------------------- (54)
% B |- strexp1 strexp2 => M'
  \begin{equation}
  \tag{54}
  \frac{
  \begin{array}{@{}c@{}}
  B \vdash \mathit{strexp}_1 \Rightarrow \Phi
  \qquad
  B \vdash \mathit{strexp}_2 \Rightarrow M
  \\
  \Phi \geq (M'',(T')M'),~~ M \succ M''
  \\
  (\mbox{tynames}\;M \cup T\;\mbox{of}\;B) \cap T' = \emptyset
  \end{array}
  }{
  B \vdash \mathit{strexp}_1~\mathit{strexp}_2 \Rightarrow M'
  }
  \end{equation}

\item In the comment for rule 54, replace all occurences of $E$ with $M$, and replace ``$B(\mathit{funid})$'' with ``$\Phi$''.

\item Add the following two rules for structure expressions:
% B |- sigexp => (T)M    B \oplus {strid|->M} |- strexp => M'
% T \cap (T of B) = 0    T' = tynames M' \ ((T of B) \cup T)
% ----------------------------------------------------------- (55a)
% B |- fct strid : sigexp => strexp => (T)(M,(T')M')
  \begin{equation}
  \tag{55a}
  \frac{
  \begin{array}{@{}c@{}}
  B \vdash \mathit{sigexp} \Rightarrow (T)M
  \qquad
  B \oplus \{\mathit{strid}\mapsto M\} \vdash \mathit{strexp} \Rightarrow M'
  \\
  T \cap (T\;\mbox{of}\;B) = \emptyset
  \qquad
  T' = \mbox{tynames}\;M' \setminus ((T\;\mbox{of}\;B) \cup T)
  \end{array}
  }{
  B \vdash {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigexp}~\mbox{\tt=>}~\mathit{strexp} \Rightarrow (T)(M,(T')M')
  }
  \end{equation}

% B |- strexp => M
% ----------------- (55b)
% B |- ( strexp ) => M
  \begin{equation}
  \tag{55b}
  \frac{
  B \vdash \mathit{strexp} \Rightarrow M
  }{
  B \vdash \mbox{\tt(}~\mathit{strexp}~\mbox{\tt)} \Rightarrow M
  }
  \end{equation}

\item Change the box giving the form of inference rules for unquantified signature expressions to:
  $$
  \boxed{B \vdash \mathit{sigexp} \Rightarrow M}
  $$
  and replace all occurences of $E$ with $M$ in rules 61, 63 and 65.

\item Add the following two rules for signature expressions:
% B |- sigexp1 => (T)M    B \oplus {strid|->M} |- sigexp2 => (T')M'
% ----------------------------------------------------------- (64a)
% B |- fct strid : sigexp1 -> sigexp2 => (T)(M,(T')M')
  \begin{equation}
  \tag{64a}
  \frac{
  B \vdash \mathit{sigexp}_1 \Rightarrow (T)M
  \qquad
  B \oplus \{\mathit{strid}\mapsto M\} \vdash \mathit{sigexp}_2 \Rightarrow (T')M'
  }{
  B \vdash {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigexp}_1~\mbox{\tt->}~\mathit{sigexp}_2 \Rightarrow (T)(M,(T')M')
  }
  \end{equation}

% B |- sigexp => M
% ----------------- (64b)
% B |- ( sigexp ) => M
  \begin{equation}
  \tag{64b}
  \frac{
  B \vdash \mathit{sigexp} \Rightarrow M
  }{
  B \vdash \mbox{\tt(}~\mathit{sigexp}~\mbox{\tt)} \Rightarrow M
  }
  \end{equation}

\item In rule 84, replace all occurences of $E$ with $M$.

\item Remove rules 85 and 86.

\item Remove rule 89, and change the comment to refer only to rules (87)--(88).
\end{itemize}

Section 6.3 (Compound Objects):
\begin{itemize}
\item In Figure 13, change the definition of structure environments StrEnv as follows:
  \begin{eqnarray*}
  \mathit{SE} &\in& \mbox{StrEnv} = \mbox{StrId} \finto \mbox{Mod} \\
  M &\in& \mbox{Mod} = \mbox{Env} \cup \mbox{FunctorClosure}
  \end{eqnarray*}

\item Add the following paragraph:
  \begin{quote}
  The object class FunctorClosure represents functors and is defined in Section 7.2.
  \end{quote}
\end{itemize}

Section 7.2 (Compound Objects):
\begin{itemize}
\item In Figure 14, change the definition of FunctorClosure and Basis as follows:
  \begin{eqnarray*}
  (\mathit{strid}:I, \mathit{strexp}:\mathit{IC}, B) &\in& \mbox{FunctorClosure} = (\mbox{StrId}\times\mbox{Int})\times(\mbox{StrExp}\times\mbox{IntConstraint})\times\mbox{Basis} \\
  \mathit{IC} &\in& \mbox{IntConstraint} = \mbox{Int} \cup \{\epsilon\} \\
  (G,E) &\in& \mbox{Basis} = \mbox{SigEnv} \times \mbox{Env}
  \end{eqnarray*}

\item Remove the definition for functor environments FunEnv.

\item Change $\mathit{SI}$ in the definition of the function Inter as follows:
  \begin{eqnarray*}
  \mbox{SI} &=& \{\mathit{strid}\mapsto\mbox{Inter}\;M~;~\mathit{SE}(\mathit{strid}) = M\}
  \end{eqnarray*}
  and add the following text:
  \begin{quote}
  where $\mbox{Inter}\;M$ in turn is defined as follows:
  \begin{eqnarray*}
  \mbox{Inter}\;M &=& \left\{
    \begin{array}{ll}
    \mbox{Inter}\;E, & \textrm{if $M = E$;} \\
    \mbox{$\{\}$ in Inter}, & \textrm{if $M = (\mathit{strid}:I', \mathit{strexp}:\mathit{IC}, B)$.}
    \end{array} \right.
  \end{eqnarray*}
  \end{quote}

\item Simplify the definition of the function Inter on a basis $B$ to:
  \begin{eqnarray*}
  \mbox{Inter}(G,E) &=& (G, \mbox{Inter}\;E)
  \end{eqnarray*}

\item Change the definition of $\downarrow : \mbox{StrEnv} \times \mbox{StrInt} \to \mbox{StrEnv}$ to:
  \begin{eqnarray*}
  \mathit{SE}\downarrow\mathit{SI} &=& \{\mathit{strid}\mapsto M \downarrow I~;~\mathit{SE}(\mathit{strid}) = M~\mbox{and}~\mathit{SI}(\mathit{strid}) = I\}
  \end{eqnarray*}

\item After the definition $\downarrow$ on environments, add the following text:
  \begin{quote}
  Here, the definition of $\downarrow: \mbox{Mod} \times \mbox{Int} \to \mbox{Mod}$ is as follows:
  \begin{eqnarray*}
  M\downarrow I &=& \left\{
    \begin{array}{ll}
    E \downarrow I, & \textrm{if $M = E$;} \\
    (\mathit{strid}:I', \mathit{strexp}:I, B), & \textrm{if $M = (\mathit{strid}:I', \mathit{strexp}:\mathit{IC}, B)$.}
    \end{array} \right.
  \end{eqnarray*}
  It is extended to interface constraints:
  \begin{eqnarray*}
  M\downarrow \mathit{IC} &=& \left\{
    \begin{array}{ll}
    M \downarrow I, & \textrm{if $\mathit{IC} = I$;} \\
    M, & \textrm{if $\mathit{IC} = \epsilon$.}
    \end{array} \right.
  \end{eqnarray*}
  Interface constraints express optional interface modifications applied to a functor body via higher-order ascription.
  \end{quote}
\end{itemize}

Section 7.3 (Inference Rules):
\begin{itemize}
\item Change the box giving the form of inference rules for structure expressions to:
  $$
  \boxed{B \vdash \mathit{strexp} \Rightarrow M/p}
  $$
  and replace all occurences of $E$ and $E'$ with $M$ in rules 151--153 and 155.

\item Change rule 154 to:
% B |- strexp1 => (strid:I, strexp':IC,B')    B |- strexp2 => M
% B'+{strid|->M\downarrow I} |- strexp' => M'
% ------------------------------------------------- (154)
% B |- strexp1 strexp2 => M' \downarrow IC
  \begin{equation}
  \tag{154}
  \frac{
  \begin{array}{@{}c@{}}
  B \vdash \mathit{strexp}_1 \Rightarrow (\mathit{strid}:I, \mathit{strexp}':\mathit{IC}, B')
  \qquad
  B \vdash \mathit{strexp}_2 \Rightarrow M
  \\
  B'+\{\mathit{strid}\mapsto M\downarrow I\} \vdash \mathit{strexp}' \Rightarrow M'
  \end{array}
  }{
  B \vdash \mathit{strexp}_1~\mathit{strexp}_2 \Rightarrow M' \downarrow \mathit{IC}
  }
  \end{equation}

\item Add the following two rules for structure expressions:
% Inter B |- sigexp => I
% ------------------------------------------------------ (155a)
% B |- fct strid : sigexp => strexp => (strid:I, strexp:epsilon, B)
  \begin{equation}
  \tag{155a}
  \frac{
  \mbox{Inter}\;B \vdash \mathit{sigexp} \Rightarrow I
  }{
  B \vdash {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigexp}~\mbox{\tt=>}~\mathit{strexp} \Rightarrow (\mathit{strid}:I, \mathit{strexp}:\epsilon, B)
  }
  \end{equation}

% B |- strexp => M
% ----------------- (155b)
% B |- ( strexp ) => M
  \begin{equation}
  \tag{155b}
  \frac{
  B \vdash \mathit{strexp} \Rightarrow M
  }{
  B \vdash \mbox{\tt(}~\mathit{strexp}~\mbox{\tt)} \Rightarrow M
  }
  \end{equation}

\item Add the following two rules for signature expressions:
% IB |- sigexp1 => I1    IB + {strid|->I1} |- sigexp2 => I2
% ----------------------------------------------------------- (163a)
% IB |- fct strid : sigexp1 -> sigexp2 => I2
  \begin{equation}
  \tag{163a}
  \frac{
  \mathit{IB} \vdash \mathit{sigexp}_1 \Rightarrow I_1
  \qquad
  \mathit{IB} + \{\mathit{strid}\mapsto I_1\} \vdash \mathit{sigexp}_2 \Rightarrow I_2
  }{
  \mathit{IB} \vdash {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigexp}_1~\mbox{\tt->}~\mathit{sigexp}_2 \Rightarrow I_2
  }
  \end{equation}

% IB |- sigexp => I
% ----------------- (163b)
% IB |- ( sigexp ) => I
  \begin{equation}
  \tag{163b}
  \frac{
  \mathit{IB} \vdash \mathit{sigexp} \Rightarrow I
  }{
  \mathit{IB} \vdash \mbox{\tt(}~\mathit{sigexp}~\mbox{\tt)} \Rightarrow I
  }
  \end{equation}

\item Remove rules 182, 183 and 186.
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 18, replace the box for structure expressions with the following:
  \begin{quote}
  {\bf Structure Expressions} $\mathit{strexp}$ \\
  $\begin{array}{|l|l|}
  \hline
  \mbox{\tt(}~\mathit{strdec}~\mbox{\tt)}~~~~
  & {\tt{struct}}~\mathit{strdec}~{\tt{end}}~~ \\
  \hline
  {\tt{fct}}~\mbox{\tt(}~\mathit{spec}~\mbox{\tt)}~\mbox{\tt=>}~\mathit{strexp}~~~
  & {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~{\tt{sig}}~\mathit{spec}~{\tt{end}}~\mbox{\tt=>}~~ \\
  & ~~~~~~~~{\tt{let}}~{\tt{open}}~\mathit{strid}~{\tt{in}}~\mathit{strexp}~{\tt{end}}~~ \\
  \hline
  \end{array}$ \\
  ($\mathit{strid}$ new) 
  \end{quote}

\item In Figure 18, replace the box for functor bindings with the following:
  \begin{quote}
  {\bf Functor Bindings} $\mathit{funbind}$ \\
  $\begin{array}{|l|l|}
  \hline
  \mathit{strid}~\mbox{\tt(}\mathit{funarg}_1\mbox{\tt)}~\cdots~\mbox{\tt(}\mathit{funarg}_n\mbox{\tt)}
  & \mathit{strid}~\mbox{\tt=}~{\tt{fct}}~\mathit{funarg}'_1~\mbox{\tt=>}~\cdots~{\tt{fct}}~\mathit{funarg}'_n~\mbox{\tt=>} \\
  ~~~~\langle\mbox{\tt:}\langle\mbox{\tt>}\rangle~\mathit{sigexp}\rangle~\mbox{\tt=}~\mathit{strexp}~\langle{\tt{and}}~\mathit{funbind}\rangle
  &~~~~\mathit{strexp}~\langle\mbox{\tt:}\langle\mbox{\tt>}\rangle~\mathit{sigexp}\rangle~\langle{\tt{and}}~\mathit{funbind}\rangle \\
  \hline
  \end{array}$ \\
  ($n\geq1$; see note in text concerning $\mathit{funarg}_1,\dots,\mathit{funarg}'_n$) 
  \end{quote}

\item In Figure 18, add a box for structure declarations as follows:
  \begin{quote}
  {\bf Structure Declarations} $\mathit{strdec}$ \\
  $\begin{array}{|l|l|}
  \hline
  {\tt{functor}}~\mathit{funbind}~~~~~~
  & {\tt{structure}}~\mathit{funbind}~~~ \\
  \hline
  \end{array}$ \\
  \end{quote}

\item In Figure 19, add box for functor descriptions as follows:
  \begin{quote}
  {\bf Functor Descriptions} $\mathit{fundesc}$ \\
  $\begin{array}{|l|l|}
  \hline
  \mathit{strid}~\mbox{\tt(}\mathit{funarg}_1\mbox{\tt)}~\cdots~\mbox{\tt(}\mathit{funarg}_n\mbox{\tt)}
  & \mathit{strid}~\mbox{\tt:}~{\tt{fct}}~\mathit{funarg}'_1~\mbox{\tt->}~\cdots~{\tt{fct}}~\mathit{funarg}'_n~\mbox{\tt->} \\
  ~~~~\mbox{\tt:}~\mathit{sigexp}
  & ~~~~\mathit{sigexp} \\
  \hline
  \end{array}$ \\
  ($n\geq1$; see note in text concerning $\mathit{funarg}_1,\dots,\mathit{funarg}'_n$) 
  \end{quote}

\item In Figure 19, extend the box for specifications as follows:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{functor}}~\mathit{fundesc}~~~~~~
  & {\tt{structure}}~\mathit{fundesc}~~~ \\
  \hline
  \end{array}$ \\
  \end{quote}

\item In Figure 19, extend the box for signature expressions as follows:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  \mbox{\tt(}~\mathit{spec}~\mbox{\tt)}~~~~
  & {\tt{sig}}~\mathit{spec}~{\tt{end}}~~ \\
  \hline
  {\tt{fct}}~\mbox{\tt(}~\mathit{spec}~\mbox{\tt)}~\mbox{\tt->}~\mathit{sigexp}~~~
  & {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~{\tt{sig}}~\mathit{spec}~{\tt{end}}~\mbox{\tt->}~\mathit{sigexp}'~ \\
  \hline
  \mathit{sigexp}_1~\mbox{\tt->}~\mathit{sigexp}_2~~~
  & {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigexp}_1~\mbox{\tt->}~\mathit{sigexp}_2~ \\
  \hline
  \end{array}$
  \end{quote}
  and add the following note to the box:
  \begin{quote}
  (see note in text concerning $\mathit{sigexp}'$; $\mathit{strid}$ new) 
  \end{quote}

\item Add the following paragraph to the text:
  \begin{quote}
  In the signature expression form for functors with a specification $\mathit{spec}$ as argument, the transformed signature expressions $\mathit{sigexp}'$ is obtained from $\mathit{sigexp}$ by replacing any identifier $\mathit{id}$ that is bound in $\mathit{spec}$ with $\mathit{strid}\mbox{\tt.}\mathit{id}$, except where hidden by a local binding.
  \end{quote}

\item Add the following paragraph to the text:
  \begin{quote}
  In the derived forms for functor bindings and functor descriptions, the phrase $\mathit{funarg}$ is defined by the following grammar:
  $$
  \begin{array}{lll}
  \mathit{funarg} & ::= & \mathit{strid}~\mbox{\tt:}~\mathit{sigexp} \\
  && \mathit{spec}
  \end{array}
  $$
  In the former case, the corresponding $\mathit{funarg}'$ is the same phrase. In the latter case it is the phase ``$\mbox{\tt(}\mathit{spec}\mbox{\tt)}$'', such that the meaning is given in terms of the derived form for structure and signature expressions, respectively.
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In the 3rd paragraph, extend the first sentence with ``and of Modules''.

\item After the 3rd paragraph, add a paragraph as follows:
  \begin{quote}
  There are also three classes of structure expressions as follows:
  $$
  \mbox{AtStrExp} \subset \mbox{AppStrExp} \subset \mbox{StrExp}
  $$
  Finally, there are two classes of signature expressions:
  $$
  \mbox{AtSigExp} \subset \mbox{SigExp}
  $$
  \end{quote}

\item In the next paragraph, replace ``Figures 20, 21, 22 and 23'' with ``Figures 20 to 23d''.

\item Add the following figure, ``Figure 23a: Structure expressions'':
  $$
  \begin{array}{llll}
  \mathit{atstrexp} & ::= & {\tt{struct}}~\mathit{strdec}~{\tt{end}} & \textrm{basic} \\
  && \mbox{\tt(}~\mathit{strdec}~\mbox{\tt)} & \textrm{basic (short)} \\
  && \mathit{longstrid} & \textrm{structure identifier} \\
  && {\tt{let}}~\mathit{strdec}~{\tt{in}}~\mathit{strexp}~{\tt{end}} & \textrm{local declaration} \\
  && \mbox{\tt(}~\mathit{strexp}~\mbox{\tt)} \\
  \\
  \mathit{appstrexp} & ::= & \mathit{atstrexp} \\
  && \mathit{appstrexp}~\mathit{atstrexp} & \textrm{functor application} \\
  \\
  \mathit{strexp} & ::= & \mathit{appstrexp} \\
  && \mathit{strexp}~\mbox{\tt:}~\mathit{sigexp} & \textrm{transparent constraint} \\
  && \mathit{strexp}~\mbox{\tt:>}~\mathit{sigexp} & \textrm{opaque constraint} \\
  && {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigexp}~\mbox{\tt=>}~\mathit{strexp} & \textrm{functor} \\
  && {\tt{fct}}~\mbox{\tt(}~\mathit{spec}~\mbox{\tt)}~\mbox{\tt=>}~\mathit{strexp} & \textrm{functor (short)} \\
  \end{array}
  $$

\item Add the following figure, ``Figure 23b: Signature expressions'':
  $$
  \begin{array}{llll}
  \mathit{atsigexp} & ::= & {\tt{sig}}~\mathit{spec}~{\tt{end}} & \textrm{basic} \\
  && \mbox{\tt(}~\mathit{spec}~\mbox{\tt)} & \textrm{basic (short)} \\
  && \mathit{sigid} & \textrm{signature identifier} \\
  && \mbox{\tt(}~\mathit{sigexp}~\mbox{\tt)} \\
  \\
  \mathit{sigexp} & ::= & \mathit{atsigexp} \\
  && \mathit{sigexp}~{\tt{where}}~{\tt{type}} & \textrm{type realisation} \\
  && ~~~~~~~~~~~~\mathit{tyvarseq}~\mathit{longtycon}~\mbox{\tt=}~\mathit{ty} \\
  && {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{atsigexp}~\mbox{\tt->}~\mathit{sigexp} & \textrm{functor} \\
  && {\tt{fct}}~\mbox{\tt(}~\mathit{spec}~\mbox{\tt)}~\mbox{\tt->}~\mathit{sigexp} & \textrm{functor (short)} \\
  && \mathit{atsigexp}~\mbox{\tt->}~\mathit{sigexp} & \textrm{non-dependent functor} \\
  \end{array}
  $$

\item Add the following figure, ``Figure 23c: Specifications and descriptions'':
  $$
  \begin{array}{llll}
  \mathit{spec} & ::= & {\tt{val}}~\mathit{valdesc} & \textrm{value} \\
  && {\tt{type}}~\mathit{typdesc} & \textrm{type} \\
  && {\tt{type}}~\mathit{syndesc} & \textrm{type} \\
  && {\tt{eqtype}}~\mathit{typdesc} & \textrm{eqtype} \\
  && {\tt{datatype}}~\mathit{datdesc}~\langle{\tt{withtype}}~\mathit{typbind}\rangle & \textrm{datatype} \\
  && {\tt{datatype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{datatype}}~\mathit{longtycon} & \textrm{replication} \\
  && {\tt{viewtype}}~\mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~{\tt{as}}~\langle\mbox{\tt|}\rangle~\mathit{condesc} & \textrm{viewtype} \\
  && {\tt{viewtype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{viewtype}}~\mathit{longtycon} & \textrm{viewtype replication} \\
  && {\tt{exception}}~\mathit{exdesc} & \textrm{exception} \\
  && {\tt{structure}}~\mathit{strdesc} & \textrm{structure} \\
  && {\tt{functor}}~\mathit{fundesc} & \textrm{functor} \\
  && {\tt{include}}~\mathit{sigexp} & \textrm{include} \\
  && {\tt{include}}~\mathit{sigid}_1~\cdots~\mathit{sigid}_n & \textrm{multiple include} \\
  &&  & \textrm{empty} \\
  && \mathit{spec}_1~\langle\mbox{\tt;}\rangle~\mathit{spec}_2 & \textrm{sequential} \\
  && \mathit{spec}~{\tt{sharing}}~{\tt{type}}~ & \textrm{type sharing} \\
  && ~~~~~~~~~\mathit{longtycon}_1~\mbox{\tt=}~\cdots~\mbox{\tt=}~\mathit{longtycon}_n & (n\geq2) \\
  && \mathit{spec}~{\tt{sharing}}~ & \textrm{structure sharing} \\
  && ~~~~~~~~~\mathit{longstrid}_1~\mbox{\tt=}~\cdots~\mbox{\tt=}~\mathit{longstrid}_n & (n\geq2) \\
  \\
  \mathit{valdesc} & ::= & \mathit{vid}~\mbox{\tt:}~\mathit{ty}~\langle{\tt{and}}~\mathit{valdesc}\rangle \\
  \mathit{typdesc} & ::= & \mathit{tyvarseq}~\mathit{tycon}~\langle{\tt{and}}~\mathit{typdesc}\rangle \\
  \mathit{syndesc} & ::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~\langle{\tt{and}}~\mathit{syndesc}\rangle \\
  \mathit{datdesc} & ::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\langle\mbox{\tt|}\rangle~\mathit{condesc}~\langle{\tt{and}}~\mathit{datdesc}\rangle \\
  \mathit{condesc} & ::= & \mathit{vid}~\langle{\tt{of}}~\mathit{ty}\rangle~\langle\mbox{\tt|}~\mathit{condesc}\rangle \\
  \mathit{exdesc} & ::= & \mathit{vid}~\langle{\tt{of}}~\mathit{ty}\rangle~\langle{\tt{and}}~\mathit{exdesc}\rangle \\
  \mathit{strdesc} & ::= & \mathit{strid}~\mbox{\tt:}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{strdesc}\rangle \\
  \mathit{fundesc} & ::= & \mathit{strid}~\mbox{\tt(}~\mathit{funarg}_1~\mbox{\tt)}~\cdots~\mbox{\tt(}~\mathit{funarg}_n~\mbox{\tt)} & (n\geq1) \\
  && ~~~~~~~\mbox{\tt:}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{fundesc}\rangle \\
  \mathit{funarg} & ::= & \mathit{strid}~\mbox{\tt:}~\mathit{sigexp} \\
  && \mathit{spec} \\
  \end{array}
  $$

\item Add the following figure, ``Figure 23d: Structure-level and top-level declarations'':
  $$
  \begin{array}{llll}
  \mathit{strdec} & ::= & \mathit{dec} & \textrm{declaration} \\
  && {\tt{structure}}~\mathit{strbind} & \textrm{structure} \\
  && {\tt{functor}}~\mathit{funbind} & \textrm{functor} \\
  && {\tt{local}}~\mathit{strdec}_1~{\tt{in}}~\mathit{strdec}_2~{\tt{end}} & \textrm{local} \\
  && & \textrm{empty} \\
  && \mathit{strdec}_1~\langle\mbox{\tt;}\rangle~\mathit{strdec}_2 & \textrm{sequential} \\
  \\
  \mathit{strbind} & ::= & \mathit{strid}~\langle\mbox{\tt:}\langle\mbox{\tt>}\rangle~\mathit{sigexp}\rangle~\mbox{\tt=}~\mathit{strexp}~\langle{\tt{and}}~\mathit{strbind}\rangle \\
  \mathit{funbind} & ::= & \mathit{strid}~\mbox{\tt(}~\mathit{funarg}_1~\mbox{\tt)}~\cdots~\mbox{\tt(}~\mathit{funarg}_n~\mbox{\tt)} & (n\geq1) \\
  && ~~~~~~~\langle\mbox{\tt:}\langle\mbox{\tt>}\rangle~\mathit{sigexp}\rangle~\mbox{\tt=}~\mathit{strexp}~\langle{\tt{and}}~\mathit{funbind}\rangle \\
  \\
  \mathit{sigdec} & ::= & {\tt{signature}}~\mathit{sigbind} \\
  \\
  \mathit{sigbind} & ::= & \mathit{sigid}~\mbox{\tt=}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{sigbind}\rangle \\
  \\
  \mathit{topdec} & ::= & \mathit{strdec}~\langle\mathit{topdec}\rangle & \textrm{structure-level declaration} \\
  && \mathit{sigdec}~\langle\mathit{topdec}\rangle & \textrm{signature declaration} \\
  \end{array}
  $$
\end{itemize}

Appendix C (The Initial Static Basis):
\begin{itemize}
\item In the text, replace ``$B_0 = T_0,F_0,G_0,E_0$ where $F_0=\{\}$, $G_0=\{\}$ and'' with ``$B_0 = T_0,G_0,E_0$ where $G_0=\{\}$ and''.
\end{itemize}

Appendix D (The Initial Dynamic Basis):
\begin{itemize}
\item In the text, replace ``$B_0 = F_0,G_0,E_0$ where $F_0=\{\}$, $G_0=\{\}$ and \dots'' with ``$B_0 = G_0,E_0$ where $G_0=\{\}$ and \dots''.
\end{itemize}

\subsubsection*{Compatibility}

This extension is not conservative because it merges identifier classes for structures and functors. The new reserved word {\tt fct} may also break some existing programs. Otherwise, it is a generalisation of the existing syntax and semantics for modules. Syntactically, it subsumes the higher-order modules of SML/NJ.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Nested Signatures}
\label{ext-nestedsignatures}

In order to make the name spacing mechanism realised by structures applicable to signatures, signatures are allowed as structure members. This implies the presence of qualified signature identifiers, and the addition of signature specifications in signatures:
\begin{quote}
\begin{alltt}
signature S = \(\mathit{sigexp}\)
\end{alltt}
\end{quote}
A signature definition matches a signature specification if and only if they denote equivalent signatures.
Note that -- unlike for types -- there are no opaque signature specifications, because that would make the type system undecidable in combination with higher-order functors \cite{translucent}.

\subsubsection*{Changes to the Definition}

The changes described here are relative to the changes for higher-order functors given in Appendix \ref{ext-higherfunctors}.

Section 3.2 (Identifiers):
\begin{itemize}
\item Extend the first sentence with
  \begin{quote}
  [\dots] and the accompanying $\mathit{longSigId}$ (long signature identifiers).
  \end{quote}
\end{itemize}

Section 3.4 (Grammar for Modules):
\begin{itemize}
\item In Figure 5, remove SigDec form the list of phrase classes, and add the following:
  \begin{quote}
  \begin{tabular}{ll}
  SigDesc & signature descriptions
  \end{tabular}
  \end{quote}

\item In Figure 6, add the following production for structure-level declarations $\mathit{strdec}$:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{strdec} ::=] & {\tt{signature}}~\mathit{sigbind} & \textrm{signature} \\
  \end{array}
  $$

\item Replace the $\mathit{sigexp}$ production for signature identifiers to:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{sigexp} ::=] & \mathit{longsigid} & \textrm{signature identifier} \\
  \end{array}
  $$

\item Remove the production for signature declarations $\mathit{sigdec}$.

\item In Figure 7, add the following production for specifications:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{spec} ::=] & {\tt{signature}}~\mathit{sigdesc} & \textrm{signature} \\
  \end{array}
  $$

\item Add the following production for the new class of signature descriptions:
  $$
  \begin{array}{lll}
  \mathit{sigdesc} & ::= & \mathit{sigid}~\mbox{\tt=}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{sigdesc}\rangle \\
  \end{array}
  $$

\item In Figure 8, remove the production for signature declarations from $\mathit{topdec}$ and simplify the remaining production for structure declarations to:
  $$
  \begin{array}{lll}
  \mathit{topdec} & ::= & \mathit{strdec} \\
  \end{array}
  $$

\item Remove the second part of the restriction note that was added by the change from Appendix \ref{ext-syntaxfixes}.
\end{itemize}

Section 3.5 (Syntactic Restrictions):
\begin{itemize}
\item In the second item, replace ``or $\mathit{strdesc}$'' with ``, $\mathit{strdesc}$ or $\mathit{sigdesc}$''.
\end{itemize}

Section 4.2 (Compound Objects):
\begin{itemize}
\item In Figure 10, change the definition of environments as follows:
  \begin{eqnarray*}
  E~\mbox{or}~(G,\mathit{SE},\mathit{TE},\mathit{VE}) &\in& \mbox{Env} = \mbox{SigEnv}\times\mbox{StrEnv}\times\mbox{TyEnv}\times\mbox{ValEnv}
  \end{eqnarray*}

\item In the paragraph referring to Figure 10, modify the sentence added by the change described in Appendix \ref{ext-higherfunctors} to
  \begin{quote}
  The object classes FunSig of functor signatures and SigEnv of signature environments belong to Modules and are defined in Section 5.1.
  \end{quote}
\end{itemize}

Section 4.3 (Projection, Injection and Modification):
\begin{itemize}
\item In the paragraph on Modification, replace ``$E+(\{\},\{\},\mathit{VE})$'' with ``$E+(\{\},\{\},\{\},\mathit{VE})$''.
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item In the last paragraph of the introduction, remove the partial sentence after the semicolon, which starts with ``one reason [\dots]''.
\end{itemize}

Section 5.1 (Semantic Objects):
\begin{itemize}
\item In Figure 11, simplify the definition of Basis to:
  \begin{eqnarray*}
  B~\mbox{or}~(T,E) &\in& \mbox{Basis} = \mbox{TyNameSet}\times\mbox{Env}
  \end{eqnarray*}
\end{itemize}

Section 5.5 (Enrichment):
\begin{itemize}
\item In the second paragraph, replace ``$E_1 = (\mathit{SE}_1,\mathit{TE}_1,\mathit{VE}_1)$'' with ``$E_1 = (G_1,\mathit{SE}_1,\mathit{TE}_1,\mathit{VE}_1)$''; likewise for $E_2$.

\item Add the following item to the enumeration:
  \begin{enumerate}
  \item[4.] $\mbox{Dom}\;G_1 \supseteq \mbox{Dom}\;G_2$, and $G_1(\mathit{sigid}) \;\begin{array}{@{}c@{}}\succ\\[-8pt] \prec\end{array}\; G_2(\mathit{sigid})$ for all $\mathit{sigid} \in \mbox{Dom}\;G_2$, where $\Sigma_1 \;\begin{array}{@{}c@{}}\succ\\[-8pt] \prec\end{array}\; \Sigma_2$ denotes mutual signature matching as defined in Section 5.6.
  \end{enumerate}
\end{itemize}

Section 5.5 (Signature Matching):
\begin{itemize}
\item Extend the second paragraph (as added by the change described in Appendix \ref{ext-higherfunctors}) with the following sentence:
  \begin{quote}
  We write $\Sigma_1 \;\begin{array}{@{}c@{}}\succ\\[-8pt] \prec\end{array}\; \Sigma_2$ to mean mutual matching $\Sigma_1 \succ \Sigma_2$ and $\Sigma_1 \prec \Sigma_2$.
  \end{quote}
\end{itemize}

Section 5.7 (Inference Rules):
\begin{itemize}
\item In the 2nd paragraph of the introduction, remove component $G$ from the equation decomposing $B$, and remove ``$\mbox{tynames}\;G \cup$'' from the set inequation.

\item Add the following rule for structure declarations:
% B |- sigbind => G
% -------------------------------- (57a)
% B |- signature sigbind => G in Env
  \begin{equation}
  \tag{57a}
  \frac{
  B \vdash \mathit{sigbind} \Rightarrow G
  }{
  B \vdash {\tt{signature}}~\mathit{sigbind} \Rightarrow \mbox{$G$ in Env}
  }
  \end{equation}

\item Change rule 63 as follows:
% B(longsigid) = (T)M    T \cap (T of B) = 0
% --------------------------------------- (63)
% B |- longsigid => M
  \begin{equation}
  \tag{63}
  \frac{
  B(\mathit{longsigid}) = (T)M
  \qquad
  T \cap (T~\mbox{of}~B) = \emptyset
  }{
  B \vdash \mathit{longsigid} \Rightarrow M
  }
  \end{equation}

\item Remove rule 66.

\item Add the following rule for specifications:
% B |- sigdesc => G
% -------------------------------- (74a)
% B |- signature sigdesc => G in Env
  \begin{equation}
  \tag{74a}
  \frac{
  B \vdash \mathit{sigdesc} \Rightarrow G
  }{
  B \vdash {\tt{signature}}~\mathit{sigdesc} \Rightarrow \mbox{$G$ in Env}
  }
  \end{equation}

\item Add a section for signature description rules of the form
  $$
  \boxed{B \vdash \mathit{sigdesc} \Rightarrow G}
  $$
  and the following rule:
% B |- sigexp => Sigma    <B |- sigdesc => G>
% ---------------------------------------- (84a)
% B |- sigid = sigexp <and sigdesc> => {sigid|->Sigma}<+ G>
  \begin{equation}
  \tag{84a}
  \frac{
  B \vdash \mathit{sigexp} \Rightarrow \Sigma
  \qquad
  \langle B \vdash \mathit{sigdesc} \Rightarrow G\rangle
  }{
  B \vdash \mathit{sigid}~\mbox{\tt=}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{sigdesc}\rangle \Rightarrow \{\mathit{sigid}\mapsto\Sigma\}\langle+ G\rangle
  }
  \end{equation}

\item Simplify rule 87 as follows:
% B |- strdec => E    tyvars E = 0
% ---------------------------------------- (87)
% B |- strdec => (tynames E, E) in Basis
  \begin{equation}
  \tag{87}
  \frac{
  B \vdash \mathit{strdec} \Rightarrow E
  \qquad
  \mbox{tyvars}\;E = \emptyset
  }{
  B \vdash \mathit{strdec} \Rightarrow \mbox{$(\mbox{tynames}\,E, E)$ in Basis}
  }
  \end{equation}

\item Remove rule 88, and change the comment to refer only to rule 87.
\end{itemize}

Section 6.3 (Compound Objects):
\begin{itemize}
\item In Figure 13, change the definition of environments as follows:
  \begin{eqnarray*}
  (G,\mathit{SE},\mathit{TE},\mathit{VE})~\mbox{or}~E &\in& \mbox{Env} = \mbox{SigEnv}\times\mbox{StrEnv}\times\mbox{TyEnv}\times\mbox{ValEnv}
  \end{eqnarray*}

\item Change the paragraph added by the change described in Appendix \ref{ext-higherfunctors} to
  \begin{quote}
  The object classes FunctorClosure and SigEnv describe functors and signature environments, respectively, and are defined in Section 7.2.
  \end{quote}
\end{itemize}

Section 7.2 (Compound Objects):
\begin{itemize}
\item In Figure 14, change the definition of interfaces and basis as follows:
  \begin{eqnarray*}
  I~\mbox{or}~(G,\mathit{SI},\mathit{TI},\mathit{VI}) &\in& \mbox{Int} = \mbox{SigEnv}\times\mbox{StrInt}\times\mbox{TyInt}\times\mbox{ValInt} \\
  B~\mbox{or}~E &\in& \mbox{Basis} = \mbox{Env}
  \end{eqnarray*}

\item Remove the definition of IntBasis.

\item In the text, add after the first sentence:
  \begin{quote}
  A basis $B$ is isomophic to an environment $E$, but we write explicit injections ``$E$ in Basis'' and projections ``$E$ of $B$''.
  \end{quote}
  Note: The main motivation here is to keep the number of changes small, as there are many references to the notion of ``dynamic basis''.

\item Adapt the definition of the function $\mbox{Inter}:\mbox{Env}\to\mbox{Int}$ as follows:
  $$
  \mbox{Inter}(G,\mathit{SE},\mathit{TE},\mathit{VE}) = (G,\mathit{SI},\mathit{TI},\mathit{VI})
  $$

\item Remove the paragraph on interface basis and the extended definition of Inter on a basis.
  \begin{quote}
  The object classes FunctorClosure and SigEnv describe functors and signature environments, respectively, and are defined in Section 7.2.
  \end{quote}

\item Adapt the definition of the cut down operator $\downarrow$ on environments as follows:
  $$
  (G,\mathit{SE},\mathit{TE},\mathit{VE}) \downarrow (G',\mathit{SI},\mathit{TI},\mathit{VI}) = (G,\mathit{SE}\downarrow\mathit{SI},\mathit{TE}\downarrow\mathit{TI},\mathit{VE}\downarrow\mathit{VI})
  $$
  and add the following sentence directly after it:
  \begin{quote}
  The static semantics ensures that $G$ and $G'$ are equivalent signature environments.
  \end{quote}
\end{itemize}

Section 7.3 (Inference Rules):
\begin{itemize}
\item Add the following rule for structure declarations:
% Inter B |- sigbind => G
% -------------------------------- (157a)
% B |- signature sigbind => G in Env
  \begin{equation}
  \tag{157a}
  \frac{
  \mbox{Inter}\;B \vdash \mathit{sigbind} \Rightarrow G
  }{
  B \vdash {\tt{signature}}~\mathit{sigbind} \Rightarrow \mbox{$G$ in Env}
  }
  \end{equation}

\item In rules 162--175 and 181, except for the ones mentioned in the following, replace all occurrences of $\mathit{IB}$ with $I$, likewise in the respective boxes giving their form; in those rules already containing occurences of $I$ (162, 165, 173, 181), replace these occurences with $I'$.

\item Change rule 163 as follows:
% I(longsigid) = I'
% ---------------------------- (163)
% I |- longsigid => I'
  \begin{equation}
  \tag{163}
  \frac{
  I(\mathit{longsigid}) = I'
  }{
  I \vdash \mathit{longsigid} \Rightarrow I'
  }
  \end{equation}

\item Remove rule 164.

\item Add the following rule for specifications:
% I |- sigdesc => G
% -------------------------------- (172a)
% I |- signature sigdesc => G in Env
  \begin{equation}
  \tag{172a}
  \frac{
  I \vdash \mathit{sigdesc} \Rightarrow G
  }{
  I \vdash {\tt{signature}}~\mathit{sigdesc} \Rightarrow \mbox{$G$ in Inter}
  }
  \end{equation}

\item Add a section for signature description rules of the form
  $$
  \boxed{I \vdash \mathit{sigdesc} \Rightarrow G}
  $$
  and the following rule:
% I |- sigexp => I'    <I |- sigdesc => G>
% ---------------------------------------- (181a)
% I |- sigid = sigexp <and sigdesc> => {sigid|->I'}<+ G>
  \begin{equation}
  \tag{181a}
  \frac{
  I \vdash \mathit{sigexp} \Rightarrow I'
  \qquad
  \langle I \vdash \mathit{sigdesc} \Rightarrow G\rangle
  }{
  I \vdash \mathit{sigid}~\mbox{\tt=}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{sigdesc}\rangle \Rightarrow \{\mathit{sigid}\mapsto I'\}\langle+ G\rangle
  }
  \end{equation}

\item Simplify rule 184 as follows:
% B |- strdec => E
% ---------------------------------------- (184)
% B |- strdec => E in Basis
  \begin{equation}
  \tag{184}
  \frac{
  B \vdash \mathit{strdec} \Rightarrow E
  }{
  B \vdash \mathit{strdec} \Rightarrow \mbox{$E$ in Basis}
  }
  \end{equation}

\item Remove rule 185.
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 19, in the box for specifications $\mathit{spec}$, replace the entry for {\tt include} with:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{include}}~\mathit{longsigid}_1~\cdots~\mathit{longsigid}_n~~~~
  & {\tt{include}}~\mathit{longsigid}_1~\mbox{\tt;}~\cdots~\mbox{\tt;}~{\tt{include}}~\mathit{longsigid}_n~~~ \\
  \hline
  \end{array}$ \\
  \end{quote}
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 23b (as defined in Appendix \ref{ext-higherfunctors}), replace the $\mathit{sigexp}$ production for signature identifiers to:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{sigexp} ::=] & \mathit{longsigid} & \textrm{signature identifier} \\
  \end{array}
  $$

\item In Figure 23c (as defined in Appendix \ref{ext-higherfunctors}), add the following production for specifications:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{spec} ::=] & {\tt{signature}}~\mathit{sigdesc} & \textrm{signature} \\
  \end{array}
  $$
  and replace the one for multiple include with:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{spec} ::=] & {\tt{include}}~\mathit{longsigid}_1~\cdots~\mathit{longsigid}_n & \textrm{multiple include} \\
  \end{array}
  $$

\item Add the following production for signature descriptions:
  $$
  \begin{array}{lll}
  \mathit{sigdesc} & ::= & \mathit{sigid}~\mbox{\tt=}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{sigdesc}\rangle
  \end{array}
  $$

\item In Figure 23d (as defined in Appendix \ref{ext-higherfunctors}), add the following production for structure-level declarations $\mathit{strdec}$:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{strdec} ::=] & {\tt{signature}}~\mathit{sigbind} & \textrm{signature} \\
  \end{array}
  $$

\item Remove the production for signature declarations $\mathit{sigdec}$.

\item Simplify the definition of $\mathit{topdec}$ to:
  $$
  \begin{array}{lll}
  \mathit{topdec} & ::= & \mathit{strdec} \\
  \end{array}
  $$
\end{itemize}

Appendix C (The Initial Static Basis):
\begin{itemize}
\item In the text, replace the definition of $B_0$ with ``$B_0 = T_0,E_0$'' and drop ``$G_0=\{\}$ and''.

\item Replace ``$E_0 = (\mathit{SE}_0,\mathit{TE}_0,\mathit{VE}_0)$, where $\mathit{SE}_0 = \{\}$'' with ``$E_0 = (G_0,\mathit{SE}_0,\mathit{TE}_0,\mathit{VE}_0)$, where $G_0 = \{\}$ and $\mathit{SE}_0 = \{\}$''.
\end{itemize}

Appendix D (The Initial Dynamic Basis):
\begin{itemize}
\item Replace the second sentence with
  \begin{quote}
  The initial dynamic basis is $B_0 = E_0 = (G_0,\mathit{SE}_0,\mathit{TE}_0,\mathit{VE}_0)$, where $G_0=\{\}$, $\mathit{SE}_0 = \{\}$, $\mathit{TE}_0$ is shown in Figure 26 and
  \end{quote}
\end{itemize}


\subsubsection*{Compatibility}

This is a conservative extension.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Local Modules}
\label{ext-localmodules}

Structure, functor and signature declarations are allowed in local scope:
\begin{quote}
\begin{alltt}
fun sortWithoutDups compare =
    let
        structure Set = MkSet(type t = string
                              val compare = compare)
    in
        Set.toList o foldr Set.insert Set.empty
    end
\end{alltt}
\end{quote}
Furthermore, as a derived form, open declarations may contain arbitrary module expressions:
\begin{quote}
\begin{alltt}
fun sortWithoutDups compare =
    let
        open MkSet(type t = string; val compare = compare)
    in
        toList o foldr insert empty
    end
\end{alltt}
\end{quote}


\subsubsection*{Changes to the Definition}

The changes described here are relative to the changes for higher-order functors and nested signatures given in Appendices \ref{ext-higherfunctors} and \ref{ext-nestedsignatures}.

Section 2.8 (Grammar):
\begin{itemize}
\item Extend the first paragraph with the following sentence:
  \begin{quote}
  In Figure 4, the variable $\mathit{strdec}$ appearing in Figure 4 ranges over the set StrDec of structure-level declarations, which is defined in Section 3.4.
  \end{quote}

\item In Figure 4, add the following production for declarations $\mathit{dec}$:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{dec} ::=] & \mathit{strdec} & \textrm{module declaration} \\
  \end{array}
  $$
\end{itemize}

Section 3.3 (Infixed operators):
\begin{itemize}
\item In the first paragraph, replace ``structure-level declaration $\mathit{strdec}$'' with ``declaration $\mathit{dec}$''.

\item In the list of phrases, replace ``$\mathit{strdec}$'' with ``$\mathit{dec}$'' and remove the phrase concerning {\tt local}.
\end{itemize}

Section 3.4 (Grammar for Modules):
\begin{itemize}
\item In Figure 6, replace all occurrences ``$\mathit{strdec}$'' in the productions for structure expressions $\mathit{strexp}$ with ``$\mathit{dec}$''.

\item Remove the productions for core, local, empty and sequential structure-level declarations and the respective restriction note that was added as part of the changes described in Appendix \ref{ext-syntaxfixes}.

\item In Figure 8, replace occurrences ``$\mathit{strdec}$'' in the productions for top-level declarations $\mathit{topdec}$ and the respective restriction note with ``$\mathit{dec}$''.
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item Add the following rule for declarations:
% C |- strdec => E
% ------------------ (20a)
% C |- strdec => E
  \begin{equation}
  \tag{20a}
  \frac{
  C \vdash \mathit{strdec} \Rightarrow E
  }{
  C \vdash \mathit{strdec} \Rightarrow E
  }
  \end{equation}
  and an accompanying comment:
  \begin{enumerate}
  \item[(20a)] The premise of this rule is a sentence of the static semantics for Modules, see Section 5.7.
  \end{enumerate}
\end{itemize}

Section 5.1 (Semantic Objects):
\begin{itemize}
\item In the third paragraph, add the following after the first sentence:
  \begin{quote}
  Inversely, we define $C$ in Basis to be the basis $(T~\mbox{of}~C, E~\mbox{of}~C)$.
  \end{quote}
\end{itemize}

Section 5.7 (Inference Rules):
\begin{itemize}
\item Change the box giving the form of inference rules for structure expressions to:
  $$
  \boxed{C \vdash \mathit{strexp} \Rightarrow M}
  $$
  and replace all occurences of $B$ with $C$ in rules 50--55, except for the premises regarding a signature expression $\mathit{sigexp}$ in rules 52, 53 and 55a, where it is replaced by ``$C$ in Basis''.

\item In rules 50 and 55, replace $\mathit{strdec}$ with $\mathit{dec}$.

\item Change the box giving the form of inference rules for structure declarations to:
  $$
  \boxed{C \vdash \mathit{strdec} \Rightarrow E}
  $$
  and replace all occurences of $B$ with $C$ in rules 57 and 57a, except for the premise of rule 57a, where it is replaced by ``$C$ in Basis''.

\item Remove rules 56 and 58--60.

\item Change the box giving the form of inference rules for structure bindings to:
  $$
  \boxed{C \vdash \mathit{strbind} \Rightarrow \mathit{SE}}
  $$
  and replace all occurences of $B$ with $C$ in rule 61.

\item In rule 87, replace $\mathit{strdec}$ with $\mathit{dec}$, and the $B$ in the premise with ``$C$ of $B$''.
\end{itemize}

Section 6.7 (Inference Rules):
\begin{itemize}
\item Add the following rule for declarations:
% E in Basis |- strdec => E'
% ------------------------ (119a)
% E |- strdec => E'
  \begin{equation}
  \tag{119a}
  \frac{
  \mbox{$E$ in Basis} \vdash \mathit{strdec} \Rightarrow E'
  }{
  E \vdash \mathit{strdec} \Rightarrow E'
  }
  \end{equation}
  and an accompanying comment:
  \begin{enumerate}
  \item[(119a)] The premise of this rule is a sentence of the dynamic semantics for Modules, see Section 7.3. The definition of dynamic basis Basis appears in Section 7.2.
  \end{enumerate}
\end{itemize}

Section 7.3 (Inference Rules):
\begin{itemize}
\item In rules 150 and 155, replace $\mathit{strdec}$ with $\mathit{dec}$, and $B$ in the premises with ``$E$ of $B$''.

\item Remove rules 156 and 158--160.

\item In rule 184, replace $\mathit{strdec}$ with $\mathit{dec}$, and the $B$ in the premise with ``$E$ of $B$''.
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 17, add the following to the box for declarations:
  \begin{quote}
  $\begin{array}{|l|l|}
  \hline
  {\tt{open}}~\mathit{strexp}~~~~
  & {\tt{local}}~{\tt{structure}}~\mathit{strid}~\mbox{\tt=}~\mathit{strexp}~{\tt{in}}~{\tt{open}}~\mathit{strid}~{\tt{end}} \\
  \hline
  \end{array}$
  \end{quote}
  and extend the note with
  \begin{quote}
  [\dots] and $\mathit{strexp}$; $\mathit{strid}$ new
  \end{quote}

\item Add the following bullet to the list of notes regarding Figure 17:
  \begin{quote}
  In the form involving {\tt open}, the structure expression $\mathit{strexp}$ may not be a functor application of the form $\mathit{longstrid}_0~\mathit{longstrid}_1~\cdots~\mathit{longstrid}_n$.
  \end{quote}

\item In Figure 18, replace occurrences of  ``$\mathit{strdec}$'' in the box for structure expressions $\mathit{strexp}$ with ``$\mathit{dec}$''.
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 20, add the following productions for declarations $\mathit{dec}$:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{dec} ::=] & \mathit{strdec} & \textrm{module declaration} \\
  & {\tt{open}}~\mathit{strexp} & \textrm{open declaration} \\
  \end{array}
  $$

\item In Figure 23a (as defined by Appendices \ref{ext-higherfunctors} and \ref{ext-nestedsignatures}), replace all occurrences of ``$\mathit{strdec}$'' with ``$\mathit{dec}$''.

\item In Figure 23d (as defined by Appendices \ref{ext-higherfunctors} and \ref{ext-nestedsignatures}), remove the productions for core, local, empty and sequential structure-level declarations.

\item Replace ``$\mathit{strdec}$'' in the productions for top-level declarations $\mathit{topdec}$ with ``$\mathit{dec}$''.
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension. The syntactic restriction on generalised {\tt open} declarations prevents overlap with the existing form, although deprecation of multiple open might arguably be a preferable solution.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{First-class Modules}
\label{ext-firstclass}

Modules can be wrapped up as first-class values, by giving a module expression and an appropriate signature:
\begin{quote}
\begin{alltt}
val p = pack Int : INTEGER
\end{alltt}
\end{quote}
The type of such a value is
\begin{quote}
\begin{alltt}
val p : pack INTEGER
\end{alltt}
\end{quote}
To unwrap a package, another signature constraint is necessary, e.g.:
\begin{quote}
\begin{alltt}
fun four x =
    let
        structure I = unpack x : INTEGER
    in
        I.toString(I.fromString "4")
    end
\end{alltt}
\end{quote}

More extensive examples can be found in {\tt doc/examples/first-class-modules.sml}.

\subsubsection*{Changes to the Definition}

The changes described here are relative to the changes for higher-order and local modules given in Appendices \ref{ext-higherfunctors}--\ref{ext-localmodules}.

Section 2.1 (Reserved Words):
\begin{itemize}
\item Add {\tt pack} to the list of reserved words.
\end{itemize}

Section 2.3 (Grammar):
\begin{itemize}
\item Extend the first paragraph further with the following sentence:
  \begin{quote}
  Moreover, the variable $\mathit{longsigid}$ occurring in Figures 3 and 4 ranges over the class of long signature identifiers, defined in Section 3.2.
  \end{quote}

\item In Figure 3, add the following production for types:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{ty} ::=] & {\tt{pack}}~\mathit{longsigid} & \textrm{first-class module} \\
  \end{array}
  $$

\item In Figure 4, add the following production for expressions:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{exp} ::=] & {\tt{pack}}~\mathit{longstrid}~\mbox{\tt:}~\mathit{longsigid} & \textrm{pack module} \\
  \end{array}
  $$
\end{itemize}

Section 3.1 (Reserved Words):
\begin{itemize}
\item Add {\tt unpack} to the list of reserved words used in Modules.
\end{itemize}

Section 3.4 (Grammar for Modules):
\begin{itemize}
\item In Figure 6, add the following production for structure expressions:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{strexp} ::=] & {\tt{unpack}}~\mathit{atexp}~\mbox{\tt:}~\mathit{sigexp} & \textrm{unpack module} \\
  \end{array}
  $$
\end{itemize}

Section 4.2 (Compound Objects):
\begin{itemize}
\item In Figure 10, extend the definition of Type with ``$\cup\,\mbox{PackType}$'' and add the following:
  \begin{eqnarray*}
  [\Sigma] &\in& \mbox{PackType} = \mbox{Sig}
  \end{eqnarray*}

\item In the paragraph referring to Figure 10, modify the sentence added by the changes described in Appendix \ref{ext-higherfunctors} and \ref{ext-nestedsignatures} to
  \begin{quote}
  The object classes Sig, FunSig and SigEnv belong to Modules and are defined in Section 5.1.
  \end{quote}
\end{itemize}

Section 4.4 (Types and Type functions):
\begin{itemize}
\item Add the following bullet to the list of forms that admit equality:
  \begin{itemize}
  \item[$\bullet$] $[\Sigma]$, where $\Sigma \in \mbox{Sig}$.
  \end{itemize}
\end{itemize}

Section 4.10 (Inference Rules):
\begin{itemize}
\item Add the following rule for expressions:
% C in Basis |- longstrid : longsigid => M    C(longsigid) = Sigma
% --------------------------------------------------------------------- (9a)
% C |- pack longstrid : longsigid => [Sigma]
  \begin{equation}
  \tag{9a}
  \frac{
  \mbox{$C$ in Basis} \vdash \mathit{longstrid}~\mbox{\tt:}~\mathit{longsigid} \Rightarrow M
  \qquad
  C(\mathit{longsigid}) = \Sigma
  }{
  C \vdash {\tt{pack}}~\mathit{longstrid}~\mbox{\tt:}~\mathit{longsigid} \Rightarrow [\Sigma]
  }
  \end{equation}
  and an accompanying note:
  \begin{enumerate}
  \item[(9a)] The premise of this rule is a sentence of the static semantics for Modules, see Section 5.7. It ensures that $C(\mathit{longstrid})$ matches $\Sigma$.
  \end{enumerate}

\item Add the following rule for types:
% C(longsigid) = Sigma
% ----------------------------------- (47a)
% C |- pack longsigid => [Sigma]
  \begin{equation}
  \tag{47a}
  \frac{
  C(\mathit{longsigid}) = \Sigma
  }{
  C \vdash {\tt{pack}}~\mathit{longsigid} \Rightarrow [\Sigma]
  }
  \end{equation}
\end{itemize}

Section 5.7 (Inference Rules):
\begin{itemize}
\item Add the following rule for structure expressions:
% C |- atexp => [Sigma]    C in Basis |- sigexp => (T)M
% Sigma >< (T)M    T \cap (T of C) = 0
% --------------------------------------------------------- (53a)
% C |- unpack atexp : sigexp => M
  \begin{equation}
  \tag{53a}
  \frac{
  \begin{array}{@{}c@{}}
  C \vdash \mathit{atexp} \Rightarrow [\Sigma]
  \qquad
  \mbox{$C$ in Basis} \vdash \mathit{sigexp} \Rightarrow (T)M
  \\
  \Sigma\;\begin{array}{@{}c@{}}\succ\\[-8pt] \prec\end{array}\;(T)M
  \qquad
  T \cap (T~\mbox{of}~C) = \emptyset
  \end{array}
  }{
  C \vdash {\tt{unpack}}~\mathit{atexp}~\mbox{\tt:}~\mathit{sigexp} \Rightarrow M
  }
  \end{equation}
\end{itemize}

Section 6.3 (Compound Objects):
\begin{itemize}
\item In Figure 13, extend the definition of Val with ``$\cup\,\mbox{Mod}$''.
\end{itemize}

Section 6.7 (Inference Rules):
\begin{itemize}
\item Add the following rule for expressions:
% E |- longstrid : longsigid => M
% ----------------------------------------- (103a)
% E |- pack longstrid : longsigid => M
  \begin{equation}
  \tag{103a}
  \frac{
  \mbox{$E$ in Basis} \vdash \mathit{longstrid}~\mbox{\tt:}~\mathit{longsigid} \Rightarrow M
  }{
  E \vdash {\tt{pack}}~\mathit{longstrid}~\mbox{\tt:}~\mathit{longsigid} \Rightarrow M
  }
  \end{equation}
  and an accompanying note:
  \begin{enumerate}
  \item[(103a)] The premise of this rule is a sentence of the dynamic semantics for Modules, see Section 7.3.
  \end{enumerate}
\end{itemize}

Section 7.3 (Inference Rules):
\begin{itemize}
\item Add the following rule for structure expressions:
% E of B |- atexp => M
% ------------------------------------- (153a)
% B |- unpack atexp : sigexp => M
  \begin{equation}
  \tag{153a}
  \frac{
  E~\mbox{of}~B \vdash \mathit{atexp} \Rightarrow M
  }{
  B \vdash {\tt{unpack}}~\mathit{atexp}~\mbox{\tt:}~\mathit{sigexp} \Rightarrow M
  }
  \end{equation}
  and note:
  \begin{enumerate}
  \item[(153a)] Because there is no subtyping on package types, the static semantics ensures that $M$ is already cut down to the signature denoted by $\mathit{sigexp}$.
  \end{enumerate}
\end{itemize}

Appendix A (Derived Forms):
\begin{itemize}
\item In Figure 15, add the following to the box for expressions:

  $\begin{array}{|l|l|}
  \hline
  {\tt{pack}}~\mathit{atstrexp}~\mbox{\tt:}~\mathit{atsigexp}~~~
  & {\tt{let}}~{\tt{structure}}~\mathit{strid}~\mbox{\tt=}~\mathit{atstrexp}~~\\
  & ~~~~~~~\,{\tt{signature}}~\mathit{sigid}~\mbox{\tt=}~\mathit{atsigexp}~~\\
  & {\tt{in}}~{\tt{pack}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigid}~{\tt{end}} \\
  \hline
  \end{array}$~($\mathit{strid}$, $\mathit{sigid}$ new)
\end{itemize}

Appendix B (Full Grammar):
\begin{itemize}
\item In Figure 20, add the following production for expressions:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{exp} ::=] & {\tt{pack}}~\mathit{atstrexp}~\mbox{\tt:}~\mathit{atsigexp} & \textrm{pack module} \\
  \end{array}
  $$

\item In Figure 23, add the following production for types:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{ty} ::=] & {\tt{pack}}~\mathit{longsigid} & \textrm{first-class module} \\
  \end{array}
  $$

\item In Figure 23a (as defined by Appendices \ref{ext-higherfunctors} and \ref{ext-nestedsignatures}), add the following production for structure expressions:
  $$
  \begin{array}{l@{\qquad}l@{\qquad}l}
  [\mathit{strexp} ::=] & {\tt{unpack}}~\mathit{atexp}~\mbox{\tt:}~\mathit{sigexp} & \textrm{unpack module} \\
  \end{array}
  $$
\end{itemize}

\subsubsection*{Compatibility}

Except for the new reserved words {\tt pack} and {\tt unpack} this is a conservative extension.


\void{ Template!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{}
\label{ext-}

\subsubsection*{Changes to the Definition}

Section ():
\begin{itemize}
\item
\end{itemize}

\subsubsection*{Compatibility}

This is a conservative extension.
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax Summary}
\label{grammar}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following gives a summary of the full grammar as defined by all the changes given in Appendix \ref{extensions}. A bullet $\bullet$ marks phrases that are new, a parenthesised bullet $(\bullet)$ phrases that have been extended relative to SML'97.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Core Language}
\label{coregrammar}

  $$
  \begin{array}{llll}
  \mathit{atexp} & ::= & \mathit{scon} & \textrm{special constant} \\
  && \langle{\tt{op}}\rangle\mathit{longvid} & \textrm{value identifier} \\
  && \mbox{\tt\{}~\langle\mathit{atexp}~{\tt{where}}\rangle~\langle\mathit{exprow}\rangle~\mbox{\tt\}} & \textrm{record $(\bullet)$} \\
  && \mbox{\tt\#}~\mathit{lab} & \textrm{record selector} \\
  && \mbox{\tt( )} & \textrm{$0$-tuple} \\
  && \mbox{\tt(}~\mathit{exp}_1~\mbox{\tt,}~\cdots~\mbox{\tt,}~\mathit{exp}_n~\mbox{\tt)} & \textrm{$n$-tuple, $n\geq2$} \\
  && \mbox{\tt[}~\mathit{exp}_1~\mbox{\tt,}~\cdots~\mbox{\tt,}~\mathit{exp}_n~\mbox{\tt]} & \textrm{list, $n\geq0$} \\
  && \mbox{\tt(}~\mathit{exp}_1~\mbox{\tt;}~\cdots~\mbox{\tt;}~\mathit{exp}_n~\langle\mbox{\tt;}\rangle~\mbox{\tt)} & \textrm{sequence, $n\geq1$ $(\bullet)$} \\
  && {\tt{let}}~\mathit{dec}~{\tt{in}}~\mathit{exp}_1~\mbox{\tt;}~\cdots~\mbox{\tt;}~\mathit{exp}_n~\langle\mbox{\tt;}\rangle~{\tt{end}} & \textrm{local declaration, $n\geq1$ $(\bullet)$} \\
%  && \mbox{\tt(}~\mathit{exp}~\langle\mbox{\tt;}\rangle~\mbox{\tt)} \\
  \\
  \mathit{exprow} & ::= & \mbox{\tt...}~\mbox{\tt=}~\mathit{exp}~\langle\mbox{\tt,}~\mathit{exprow}\rangle & \textrm{ellipses $\bullet$} \\
  && \mathit{lab}~\mbox{\tt=}~\mathit{exp}~\langle\mbox{\tt,}~\mathit{exprow}\rangle & \textrm{expression row} \\
  && \mathit{vid}~\langle\mbox{\tt:}~\mathit{ty}\rangle~\langle\mbox{\tt,}~\mathit{exprow}\rangle & \textrm{label as variable $\bullet$} \\
  \\
  \mathit{appexp} & ::= & \mathit{atexp} \\
  && \mathit{appexp}~\mathit{atexp} & \textrm{application} \\
  \\
  \mathit{infexp} & ::= & \mathit{appexp} \\
  && \mathit{infexp}_1~\mathit{vid}~\mathit{infexp}_2 & \textrm{infix application} \\
  \\
  \mathit{exp} & ::= & \mathit{infexp} \\
  && \mathit{exp}~\mbox{\tt:}~\mathit{ty} & \textrm{type constraint (L)} \\
  && {\tt{pack}}~\mathit{atstrexp}~\mbox{\tt:}~\mathit{atsigexp} & \textrm{pack module $\bullet$} \\
  && \mathit{exp}_1~{\tt{andalso}}~\mathit{exp}_2 & \textrm{conjunction} \\
  && \mathit{exp}_1~{\tt{orelse}}~\mathit{exp}_2 & \textrm{disjunction} \\
  && \mathit{exp}~{\tt{handle}}~\langle\mbox{\tt|}\rangle~\mathit{match} & \textrm{handle exception $(\bullet)$} \\
  && {\tt{raise}}~\mathit{exp} & \textrm{raise exception} \\
  && {\tt{if}}~\mathit{exp}_1 ~{\tt{then}}~\mathit{exp}_2~\langle{\tt{else}}~\mathit{exp}_3\rangle & \textrm{conditional $(\bullet)$} \\
  && {\tt{while}}~\mathit{exp}_1 ~{\tt{do}}~\mathit{exp}_2 & \textrm{iteration} \\
  && {\tt{case}}~\mathit{exp} ~{\tt{of}}~\langle\mbox{\tt|}\rangle~\mathit{match} & \textrm{case analysis $(\bullet)$} \\
  && {\tt{fn}}~\langle\mbox{\tt|}\rangle~\mathit{match} & \textrm{function $(\bullet)$}
  \end{array}
  $$

\clearpage

  $$
  \begin{array}{llll}
  \mathit{atpat} & ::= & \mbox{\tt\_} & \textrm{wildcard} \\
  && \mathit{scon} & \textrm{special constant} \\
  && \langle{\tt{op}}\rangle\mathit{longvid} & \textrm{value identifier} \\
  && \mbox{\tt?}~\mathit{atexp} & \textrm{transformation $\bullet$} \\
  && \mbox{\tt\{}~\langle\mathit{patrow}\rangle~\mbox{\tt\}} & \textrm{record} \\
  && \mbox{\tt( )} & \textrm{$0$-tuple} \\
  && \mbox{\tt(}~\mathit{pat}_1~\mbox{\tt,}~\cdots~\mbox{\tt,}~\mathit{pat}_n~\mbox{\tt)} & \textrm{$n$-tuple, $n\geq2$} \\
  && \mbox{\tt[}~\mathit{pat}_1~\mbox{\tt,}~\cdots~\mbox{\tt,}~\mathit{pat}_n~\mbox{\tt]} & \textrm{list, $n\geq0$} \\
  && \mbox{\tt(}~\mathit{pat}~\mbox{\tt)} \\
  \\
  \mathit{patrow} & ::= & \mbox{\tt...}~\langle\mbox{\tt=}~\mathit{pat}\rangle~\langle\mbox{\tt,}~\mathit{patrow}\rangle & \textrm{ellipses $(\bullet)$} \\
  && \mathit{lab}~\mbox{\tt=}~\mathit{pat}~\langle\mbox{\tt,}~\mathit{patrow}\rangle & \textrm{pattern row} \\
  && \mathit{vid}~\langle\mbox{\tt:}~\mathit{ty}\rangle~\langle{\tt{as}}~\mathit{pat}\rangle~\langle\mbox{\tt,}~\mathit{patrow}\rangle & \textrm{label as variable} \\
  \\
  \mathit{apppat} & ::= & \mathit{atpat} \\
  && \langle{\tt{op}}\rangle\mathit{longvid}~\mathit{atpat} & \textrm{constructed value} \\
  && \mbox{\tt?}~\mathit{atexp}~\mathit{atpat} & \textrm{constructed transformation $\bullet$} \\
  \\
  \mathit{infpat} & ::= & \mathit{apppat} \\
  && \mathit{infpat}_1~\mathit{vid}~\mathit{infpat}_2 & \textrm{constructed value (infix)} \\
  \\
  \mathit{pat} & ::= & \mathit{infpat} \\
  && \mathit{pat}~\mbox{\tt:}~\mathit{ty} & \textrm{typed} \\
  && \mathit{pat}_1~{\tt{as}}~\mathit{pat}_2 & \textrm{conjunctive $(\bullet)$} \\
  && \mathit{pat}_1~\mbox{\tt|}~\mathit{pat}_2 & \textrm{disjunctive $\bullet$} \\
  && \mathit{pat}_1~{\tt{with}}~\mathit{pat}_2~\mbox{\tt=}~\mathit{exp} & \textrm{nested match $\bullet$} \\
  && \mathit{pat}~{\tt{if}}~\mathit{exp} & \textrm{guard $\bullet$} \\
  \\
  \mathit{match} & ::= & \mathit{mrule}~\langle\mbox{\tt|}~\mathit{match}\rangle \\
  \mathit{mrule} & ::= & \mathit{pat}~\mbox{\tt=>}~\mathit{exp} & \textrm{match rule} \\
  \\
  \mathit{fmatch} &::=& \mathit{fmrule}~\langle\mbox{\tt|}~\mathit{fmatch}\rangle \\
  \mathit{fmrule} &::=& \mathit{fpat}~\langle\mbox{\tt:}~\mathit{ty}\rangle~\langle{\tt{if}}~\mathit{atexp}\rangle~\mbox{\tt=}~\mathit{exp} & \textrm{match clause $(\bullet)$} \\
  \mathit{fpat} &::=& \langle{\tt{op}}\rangle\mathit{vid}~\mathit{atpat}_1~\cdots~\mathit{atpat}_n & n\geq1 \\
  && \mbox{\tt(}\mathit{atpat}_1~\mathit{vid}~\mathit{atpat}_2\mbox{\tt)}~\mathit{atpat}_3~\cdots~\mathit{atpat}_n & n\geq3 \\
  && \mathit{atpat}_1~\mathit{vid}~\mathit{atpat}_2
  \end{array}
  $$

  $$
  \begin{array}{llll}
  \mathit{ty} & ::= & \mathit{tyvar} & \textrm{type variable} \\
  && \mbox{\tt\{}~\langle\mathit{tyrow}\rangle~\mbox{\tt\}} & \textrm{record} \\
  && \mathit{tyseq}~\mathit{longtycon} & \textrm{type construction} \\
  && \mathit{ty}_1~\mbox{\tt*}~\cdots~\mbox{\tt*}~\mathit{ty}_n & \textrm{$n$-tuple, $n\geq2$} \\
  && \mathit{ty}_1~\mbox{\tt->}~\mathit{ty}_2 & \textrm{function type (R)} \\
  && {\tt{pack}}~\mathit{longsigid} & \textrm{first-class module $\bullet$} \\
  && \mbox{\tt(}~\mathit{ty}~\mbox{\tt)} \\
  \\
  \mathit{tyrow} & ::= & \mbox{\tt...}~\mbox{\tt:}~\mathit{ty}~\langle\mbox{\tt,}~\mathit{tyrow}\rangle & \textrm{ellipses $\bullet$} \\
  && \mathit{lab}~\mbox{\tt:}~\mathit{ty}~\langle\mbox{\tt,}~\mathit{tyrow}\rangle & \textrm{type row} \\
  \end{array}
  $$

  $$
  \begin{array}{llll}
  \mathit{dec} & ::= & {\tt{do}}~\mathit{exp} & \textrm{evaluation $\bullet$} \\
  && {\tt{val}}~\langle{\tt{rec}}\rangle~\mathit{tyvarseq}~\mathit{valbind} & \textrm{value $(\bullet)$} \\
  && {\tt{fun}}~\mathit{tyvarseq}~\mathit{funbind} & \textrm{function} \\
  && {\tt{type}}~\mathit{typbind} & \textrm{type} \\
  && {\tt{datatype}}~\mathit{datbind}~\langle{\tt{withtype}}~\mathit{typbind}\rangle & \textrm{datatype} \\
  && {\tt{datatype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{datatype}}~\mathit{longtycon} & \textrm{replication} \\
  && {\tt{viewtype}}~\mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~{\tt{as}}~\langle\mbox{\tt|}\rangle~\mathit{conbind} & \textrm{viewtype $\bullet$} \\
  && ~~~~~~~~{\tt{with}}~\mathit{dec}~{\tt{end}} \\
  && {\tt{viewtype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{viewtype}}~\mathit{longtycon} & \textrm{viewtype replication $\bullet$} \\
  && {\tt{abstype}}~\mathit{datbind}~\langle{\tt{withtype}}~\mathit{typbind}\rangle & \textrm{abstract type} \\
  && ~~~~~~~~{\tt{with}}~\mathit{dec}~{\tt{end}} \\
  && {\tt{exception}}~\mathit{exbind} & \textrm{exception} \\
  && \mathit{strdec} & \textrm{module declaration $\bullet$} \\
  && {\tt{open}}~\mathit{strexp} & \textrm{open $\bullet$} \\
  && {\tt{open}}~\mathit{longstrid}_1~\cdots~\mathit{longstrid}_n & \textrm{multiple open} \\
  && {\tt{local}}~\mathit{dec}_1~{\tt{in}}~\mathit{dec}_2~{\tt{end}} & \textrm{local} \\
  &&  & \textrm{empty} \\
  && \mathit{dec}_1~\langle\mbox{\tt;}\rangle~\mathit{dec}_2 & \textrm{sequential} \\
  && {\tt{infix}}~\langle d\rangle~\mathit{vid}_1~\cdots~\mathit{vid}_n & \textrm{infix left directive, $n\geq1$} \\
  && {\tt{infixr}}~\langle d\rangle~\mathit{vid}_1~\cdots~\mathit{vid}_n & \textrm{infix right directive, $n\geq1$} \\
  && {\tt{nonfix}}~\mathit{vid}_1~\cdots~\mathit{vid}_n & \textrm{nonfix directive, $n\geq1$} \\
  \\
  \mathit{valbind} & ::= & \mathit{pat}~\mbox{\tt=}~\mathit{exp}~\langle{\tt{and}}~\mathit{valbind}\rangle \\
  \mathit{fvalbind} &::=& \langle\mbox{\tt|}\rangle~\mathit{fmatch}~\langle{\tt{and}}~\mathit{fvalbind}\rangle & \textrm{$(\bullet)$} \\
  \mathit{typdesc} & ::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~\langle{\tt{and}}~\mathit{typbind}\rangle \\
  \mathit{datbind} & ::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\langle\mbox{\tt|}\rangle~\mathit{conbind}~\langle{\tt{and}}~\mathit{datbind}\rangle & \textrm{$(\bullet)$} \\
  \mathit{conbind} & ::= & \langle{\tt{op}}\rangle\mathit{vid}~\langle{\tt{of}}~\mathit{ty}\rangle~\langle\mbox{\tt|}~\mathit{conbind}\rangle \\
  \mathit{exbind} & ::= & \langle{\tt{op}}\rangle\mathit{vid}~\langle{\tt{of}}~\mathit{ty}\rangle~\langle{\tt{and}}~\mathit{exbind}\rangle \\
  && \langle{\tt{op}}\rangle\mathit{vid}~\mbox{\tt=}~\langle{\tt{op}}\rangle\mathit{longvid}~\langle{\tt{and}}~\mathit{exbind}\rangle \\
  \end{array}
  $$


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Module Language}
\label{modulegrammar}

  $$
  \begin{array}{llll}
  \mathit{atstrexp} & ::= & {\tt{struct}}~\mathit{dec}~{\tt{end}} & \textrm{basic} \\
  && \mbox{\tt(}~\mathit{dec}~\mbox{\tt)} & \textrm{basic (short) $\bullet$} \\
  && \mathit{longstrid} & \textrm{structure identifier} \\
  && {\tt{let}}~\mathit{dec}~{\tt{in}}~\mathit{strexp}~{\tt{end}} & \textrm{local declaration} \\
  && \mbox{\tt(}~\mathit{strexp}~\mbox{\tt)} & \textrm{$\bullet$} \\
  \\
  \mathit{appstrexp} & ::= & \mathit{atstrexp} \\
  && \mathit{appstrexp}~\mathit{atstrexp} & \textrm{functor application $(\bullet)$} \\
  \\
  \mathit{strexp} & ::= & \mathit{appstrexp} \\
  && \mathit{strexp}~\mbox{\tt:}~\mathit{sigexp} & \textrm{transparent constraint} \\
  && \mathit{strexp}~\mbox{\tt:>}~\mathit{sigexp} & \textrm{opaque constraint} \\
  && {\tt{unpack}}~\mathit{atexp}~\mbox{\tt:}~\mathit{sigexp} & \textrm{unpack module $\bullet$} \\
  && {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{sigexp}~\mbox{\tt=>}~\mathit{strexp} & \textrm{functor $\bullet$} \\
  && {\tt{fct}}~\mbox{\tt(}~\mathit{spec}~\mbox{\tt)}~\mbox{\tt=>}~\mathit{strexp} & \textrm{functor (short) $\bullet$} \\
  \end{array}
  $$

  $$
  \begin{array}{llll}
  \mathit{atsigexp} & ::= & {\tt{sig}}~\mathit{spec}~{\tt{end}} & \textrm{basic} \\
  && \mbox{\tt(}~\mathit{spec}~\mbox{\tt)} & \textrm{basic (short) $\bullet$} \\
  && \mathit{longsigid} & \textrm{signature identifier $(\bullet)$} \\
  && \mbox{\tt(}~\mathit{sigexp}~\mbox{\tt)} & \textrm{$\bullet$} \\
  \\
  \mathit{sigexp} & ::= & \mathit{atsigexp} \\
  && \mathit{sigexp}~{\tt{where}}~{\tt{type}} & \textrm{type realisation} \\
  && ~~~~~~~~~~~~\mathit{tyvarseq}~\mathit{longtycon}~\mbox{\tt=}~\mathit{ty} \\
  && {\tt{fct}}~\mathit{strid}~\mbox{\tt:}~\mathit{atsigexp}~\mbox{\tt->}~\mathit{sigexp} & \textrm{functor $\bullet$} \\
  && {\tt{fct}}~\mbox{\tt(}~\mathit{spec}~\mbox{\tt)}~\mbox{\tt->}~\mathit{sigexp} & \textrm{functor (short) $\bullet$} \\
  && \mathit{atsigexp}~\mbox{\tt->}~\mathit{sigexp} & \textrm{non-dependent functor $\bullet$} \\
  \end{array}
  $$

  $$
  \begin{array}{llll}
  \mathit{spec} & ::= & {\tt{val}}~\mathit{valdesc} & \textrm{value} \\
  && {\tt{type}}~\mathit{typdesc} & \textrm{type} \\
  && {\tt{type}}~\mathit{syndesc} & \textrm{type} \\
  && {\tt{eqtype}}~\mathit{typdesc} & \textrm{eqtype} \\
  && {\tt{datatype}}~\mathit{datdesc}~\langle{\tt{withtype}}~\mathit{typbind}\rangle & \textrm{datatype $(\bullet)$} \\
  && {\tt{datatype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{datatype}}~\mathit{longtycon} & \textrm{replication} \\
  && {\tt{viewtype}}~\mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~{\tt{as}}~\langle\mbox{\tt|}\rangle~\mathit{condesc} & \textrm{viewtype $\bullet$} \\
  && {\tt{viewtype}}~\mathit{tycon}~\mbox{\tt=}~{\tt{viewtype}}~\mathit{longtycon} & \textrm{viewtype replication $\bullet$} \\
  && {\tt{exception}}~\mathit{exdesc} & \textrm{exception} \\
  && {\tt{structure}}~\mathit{strdesc} & \textrm{structure} \\
  && {\tt{functor}}~\mathit{fundesc} & \textrm{functor $\bullet$} \\
  && {\tt{signature}}~\mathit{sigdesc} & \textrm{signature $\bullet$} \\
  && {\tt{include}}~\mathit{sigexp} & \textrm{include} \\
  && {\tt{include}}~\mathit{longsigid}_1~\cdots~\mathit{longsigid}_n & \textrm{multiple include $(\bullet)$} \\
  &&  & \textrm{empty} \\
  && \mathit{spec}_1~\langle\mbox{\tt;}\rangle~\mathit{spec}_2 & \textrm{sequential} \\
  && \mathit{spec}~{\tt{sharing}}~{\tt{type}}~ & \textrm{type sharing} \\
  && ~~~~~~~~~\mathit{longtycon}_1~\mbox{\tt=}~\cdots~\mbox{\tt=}~\mathit{longtycon}_n & (n\geq2) \\
  && \mathit{spec}~{\tt{sharing}}~ & \textrm{structure sharing} \\
  && ~~~~~~~~~\mathit{longstrid}_1~\mbox{\tt=}~\cdots~\mbox{\tt=}~\mathit{longstrid}_n & (n\geq2) \\
  \\
  \mathit{valdesc} & ::= & \mathit{vid}~\mbox{\tt:}~\mathit{ty}~\langle{\tt{and}}~\mathit{valdesc}\rangle \\
  \mathit{typdesc} & ::= & \mathit{tyvarseq}~\mathit{tycon}~\langle{\tt{and}}~\mathit{typdesc}\rangle \\
  \mathit{syndesc} & ::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\mathit{ty}~\langle{\tt{and}}~\mathit{syndesc}\rangle \\
  \mathit{datdesc} & ::= & \mathit{tyvarseq}~\mathit{tycon}~\mbox{\tt=}~\langle\mbox{\tt|}\rangle~\mathit{condesc}~\langle{\tt{and}}~\mathit{datdesc}\rangle & \textrm{$(\bullet)$} \\
  \mathit{condesc} & ::= & \mathit{vid}~\langle{\tt{of}}~\mathit{ty}\rangle~\langle\mbox{\tt|}~\mathit{condesc}\rangle \\
  \mathit{exdesc} & ::= & \mathit{vid}~\langle{\tt{of}}~\mathit{ty}\rangle~\langle{\tt{and}}~\mathit{exdesc}\rangle \\
  \mathit{strdesc} & ::= & \mathit{strid}~\mbox{\tt:}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{strdesc}\rangle \\
  \mathit{fundesc} & ::= & \mathit{strid}~\mbox{\tt(}~\mathit{funarg}_1~\mbox{\tt)}~\cdots~\mbox{\tt(}~\mathit{funarg}_n~\mbox{\tt)} & (n\geq1)~\bullet \\
  && ~~~~~~~\mbox{\tt:}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{fundesc}\rangle \\
  \mathit{funarg} & ::= & \mathit{strid}~\mbox{\tt:}~\mathit{sigexp} \\
  && \mathit{spec} \\
  \mathit{sigdesc} & ::= & \mathit{sigid}~\mbox{\tt=}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{sigdesc}\rangle & \textrm{$\bullet$} \\
  \end{array}
  $$

  $$
  \begin{array}{llll}
  \mathit{strdec} & ::= & {\tt{structure}}~\mathit{strbind} & \textrm{structure} \\
  && {\tt{functor}}~\mathit{funbind} & \textrm{functor $(\bullet)$} \\
  && {\tt{signature}}~\mathit{sigbind} & \textrm{signature $(\bullet)$} \\
  \\
  \mathit{strbind} & ::= & \mathit{strid}~\langle\mbox{\tt:}\langle\mbox{\tt>}\rangle~\mathit{sigexp}\rangle~\mbox{\tt=}~\mathit{strexp}~\langle{\tt{and}}~\mathit{strbind}\rangle \\
  \mathit{funbind} & ::= & \mathit{strid}~\mbox{\tt(}~\mathit{funarg}_1~\mbox{\tt)}~\cdots~\mbox{\tt(}~\mathit{funarg}_n~\mbox{\tt)} & (n\geq1)~ (\bullet) \\
  && ~~~~~~~\langle\mbox{\tt:}\langle\mbox{\tt>}\rangle~\mathit{sigexp}\rangle~\mbox{\tt=}~\mathit{strexp}~\langle{\tt{and}}~\mathit{funbind}\rangle \\
  \\
  \mathit{sigbind} & ::= & \mathit{sigid}~\mbox{\tt=}~\mathit{sigexp}~\langle{\tt{and}}~\mathit{sigbind}\rangle \\
  \\
  \mathit{topdec} & ::= & \mathit{dec} & (\bullet) \\
  \\
  \mathit{program} &::=& \mathit{topdec}~\mbox{\tt;}~\langle\mathit{program}\rangle \\
  && \mathit{exp}~\mbox{\tt;}~\langle\mathit{program}\rangle
  \end{array}
  $$


\void{
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Library Extensions}
\label{libextensions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Library Module for Generic Functionals}
\label{lib-fn}

\subsubsection*{Changes to the Basis Library }

Add a section on ``The {\tt Fn} structure'':
\begin{quote}
The structure {\tt Fn} defines basic generic combinators for functions that are useful for a wide range of programming tasks.

{\bf Synopsis}
\begin{alltt}
\textbf{signature} FN
\textbf{structure} Fn \textbf{:>} FN
\end{alltt}

{\bf Interface}
\begin{alltt}
\textbf{val} id \textbf{:} 'a \textbf{->} 'a
\textbf{val} const \textbf{:} 'a \textbf{->} 'b \textbf{->} 'a
\textbf{val} apply \textbf{:} ('a \textbf{->} 'b) * 'a \textbf{->} 'b
\textbf{val} o \textbf{:} ('b \textbf{->} 'c) * ('a \textbf{->} 'b) \textbf{->} ('a \textbf{->} 'c)
\textbf{val} curry \textbf{:} ('a * 'b \textbf{->} 'c) \textbf{->} ('a \textbf{->} 'b \textbf{->} 'c)
\textbf{val} uncurry \textbf{:} ('a \textbf{->} 'b \textbf{->} 'c) \textbf{->} ('a * 'b \textbf{->} 'c)
\textbf{val} flip \textbf{:} ('a * 'b \textbf{->} 'c) \textbf{->} ('b * 'a \textbf{->} 'c)
\textbf{val} repeat \textbf{:} int \textbf{->} ('a \textbf{->} 'a) \textbf{->} ('a \textbf{->} 'a)
\textbf{val} forever \textbf{:} ('a \textbf{->} 'a) \textbf{->} 'a \textbf{->} 'b
\textbf{val} iter \textbf{:} int \textbf{->} (unit \textbf{->} unit) \textbf{->} unit
\end{alltt}

{\bf Description}
\begin{alltt}
\textbf{val} id \textbf{:} 'a \textbf{->} 'a
\end{alltt}
  \begin{quote}
  {\tt id} is the identity function. Thus, {\tt id \textsl{a}} is equivalent to {\tt\textsl{a}}.
  \end{quote}

\begin{alltt}
\textbf{val} const \textbf{:} 'a \textbf{->} 'b \textbf{->} 'a
\end{alltt}
  \begin{quote}
  {\tt const \textsl{a}} is a constant function that always returns {\tt\textsl{a}}. Thus, {\tt const \textsl{a b}} is equivalent to {\tt\textsl{a}}, except for side-effects.
  \end{quote}

\begin{alltt}
\textbf{val} apply \textbf{:} ('a \textbf{->} 'b) * 'a \textbf{->} 'b
\end{alltt}
  \begin{quote}
  {\tt apply(\textsl{f},\textsl{a})} applies {\tt\textsl{f}} to {\tt\textsl{a}}. Thus, it is equivalent to {\tt\textsl{f a}}.
  \end{quote}

\begin{alltt}
\textbf{val} o \textbf{:} ('b \textbf{->} 'c) * ('a \textbf{->} 'b) \textbf{->} ('a \textbf{->} 'c)
\end{alltt}
  \begin{quote}
  {\tt\textsl{f} o \textsl{g}} is the function composition of {\tt\textsl{f}} and {\tt\textsl{g}}. Thus, {\tt(\textsl{f} o \textsl{g}) \textsl{a}} is equivalent to {\tt\textsl{f}(\textsl{g a})}.
  \end{quote}

\begin{alltt}
\textbf{val} curry \textbf{:} ('a * 'b \textbf{->} 'c) \textbf{->} ('a \textbf{->} 'b \textbf{->} 'c)
\end{alltt}
  \begin{quote}
  {\tt curry \textsl{f}} transforms the binary function {\tt\textsl{f}} into curried form. Thus, {\tt curry \textsl{f a b}} is equivalent to {\tt \textsl{f}(\textsl{a},\textsl{b})}.
  \end{quote}

\begin{alltt}
\textbf{val} uncurry \textbf{:} ('a \textbf{->} 'b \textbf{->} 'c) \textbf{->} ('a * 'b \textbf{->} 'c)
\end{alltt}
  \begin{quote}
  {\tt uncurry \textsl{f}} transforms a curried function {\tt\textsl{f}} into a binary function. Thus, {\tt uncurry \textsl{f} (\textsl{a},\textsl{b})} is equivalent to {\tt\textsl{f a b}}.
  \end{quote}

\begin{alltt}
\textbf{val} flip \textbf{:} ('a * 'b \textbf{->} 'c) \textbf{->} ('b * 'a \textbf{->} 'c)
\end{alltt}
  \begin{quote}
  {\tt flip \textsl{f}} switches the argument order of the binary function {\tt\textsl{f}}. Thus, {\tt flip \textsl{f} (\textsl{a},\textsl{b})} is equivalent to {\tt\textsl{f}(\textsl{b},\textsl{a})}.
  \end{quote}

\begin{alltt}
\textbf{val} repeat \textbf{:} int \textbf{->} ('a \textbf{->} 'a) \textbf{->} ('a \textbf{->} 'a)
\end{alltt}
  \begin{quote}
  {\tt repeat \textsl{n f}} is the {\tt\textsl{n}}-fold composition of {\tt\textsl{f}}. Thus, {\tt repeat \textsl{n f a}} is equivalent to {\tt \textsl{f}($\cdots$(\textsl{f}(\textsl{a}))$\cdots$)}, where {\tt\textsl{f}} occurs {\tt\textsl{n}} times.
  \end{quote}

\begin{alltt}
\textbf{val} forever \textbf{:} ('a \textbf{->} 'a) \textbf{->} 'a \textbf{->} 'b
\end{alltt}
  \begin{quote}
  {\tt forever \textsl{f a}} performs infinite repetition of the function {\tt\textsl{f}}. Thus, {\tt forever \textsl{f}} can be thought of as being equivalent to {\tt repeat $\infty$ \textsl{f}}.
  \end{quote}

\begin{alltt}
\textbf{val} iter \textbf{:} int \textbf{->} (unit \textbf{->} unit) \textbf{->} unit
\end{alltt}
  \begin{quote}
  {\tt iter \textsl{n f}} performs {\tt\textsl{n}} times the application {\tt\textsl{f}()}. Thus, {\tt iter \textsl{n f}} is equivalent to {\tt(\textsl{f}();$\cdots$;\textsl{f}())}, with {\tt\textsl{f}} occurring {\tt\textsl{n}} times.
  \end{quote}
\end{quote}

\subsubsection*{Compatibility}

This is a conservative extension.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{History}
\label{history}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.0 (2001/10/04)}

Public release. No history for prior versions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.0.1 (2001/10/11)}

Basis:
\begin{itemize} \setlength{\itemsep}{0em}
\item Fixed ASCII and Unicode escapes in {\tt Char.scan} and {\tt Char.scanC} (and thus in {\tt Char.fromString}, {\tt Char.fromCString}, {\tt String.fromString}).
\item Fixed octal escapes in {\tt Char.toCString} (and thus {\tt String.toCString}).
\item Fixed possible NaN's in {\tt Real.scan} for mantissa 0 and large exponents.
\end{itemize}

Documentation:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added issue of obligatory formatting characters to Appendix.
\item Some minor additions/clarifications in Appendix.
\end{itemize}

Test cases:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added test case {\tt redundant}.
\item Removed accidental carriage returns from {\tt asterisk}, {\tt semicolon} and {\tt typespec}.
\item Small additions to {\tt semicolon} and {\tt valrec}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.1 (2002/07/26)}

Basis:
\begin{itemize} \setlength{\itemsep}{0em}
\item Adapted signatures to latest version of the Basis specification \cite{basis}.
\item Implemented new library functions and adapted functions with changed semantics.
\item Implemented all signatures and structures dealing with array and vector slices.
\item Implemented new {\tt Text} structure, along with missing {\tt CharVector} and {\tt CharArray} structures.
\item Implemented missing {\tt Byte} structure.
\item Removed {\tt SML90} structure and signature.
\item Use opaque signature constraints where the specification uses them (with some necessary exceptions).
\item Implemented missing {\tt Bool.scan} and {\tt Bool.fromString}.
\item Implemented missing {\tt Real.posInf} and {\tt Real.negInf}.
\item Handle exceptions from {\tt Char.chr} correctly.
\item Fixed generation of $\tt\backslash${\tt\^{}X}-escapes in {\tt Char.toString}.
\item Fixed treatment of gap escapes in {\tt Char.scan}.
\end{itemize}

Test cases:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added test case {\tt replication}.
\item Updated conformance table.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.1.1 (2004/04/17)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Disallow undetermined types (a.k.a.\ ``free type variables'') on toplevel.
\item Implement accurate scope checking for type names.
\item Fixed soundness bug w.r.t.\ undetermined types in type scheme generalisation test.
\item Reject out-of-range real constants.
\item Accept multiple line input.
\item Output file name and line/columns with error messages.
\item Improved pretty printing.
\end{itemize}

Basis:
\begin{itemize} \setlength{\itemsep}{0em}
\item Sync'ed with updates to the specification \cite{basis}: overloaded $\tt\sim$ on words, added {\tt Word.fromLarge}, {\tt Word.toLarge}, {\tt Word.toLargeX}; removed {\tt Substring.all}; changed {\tt TextIO.inputLine}; changed {\tt Byte.unpackString} and {\tt Byte.unpackStringVec}.
\item Fixed {\tt String.isSubstring}, {\tt String.fields}, and {\tt Vector.foldri}.
\end{itemize}

Test cases:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added test cases {\tt abstype2}, {\tt dec-strdec}, {\tt flexrecord2}, {\tt tyname}, {\tt undetermined2}, {\tt undetermined3}.
\item Split conformance table into different classes of deviation and updated it.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.1.2 (2005/01/14)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Fix parsing of sequential and sharing specifications.
\item Add arity checks missing in rules 64 and 78 of the Definition.
\item Implement type name equality attribute as {\tt bool}.
\end{itemize}

Basis:
\begin{itemize} \setlength{\itemsep}{0em}
\item Fixed {\tt StringCvt.padLeft} and {\tt StringCvt.padRight}.
\end{itemize}

Documentation:
\begin{itemize} \setlength{\itemsep}{0em}
\item Add parsing ambiguity for sharing specifications to issue list.
\item Add missing side conditions in rules 64 and 78 to issue list.
\item Added version history to appendix.
\end{itemize}

Test cases:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added test cases {\tt poly-exception}, {\tt tyvar-shadowing}, and {\tt where2} and extended {\tt id} and {\tt valrec}.
\item Updated conformance table.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2 (2005/02/04)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Refactored code: semantic objects are now collected in one structure for each part of the semantics; type variable scoping and closure computation (expansiveness check) are separated from elaboration module.
\item Made checking of syntactic restrictions a separate inference pass.
\item Added missing check for bound variables in signature realisation.
\item Fixed precedence of environments for {\tt open} declarations.
\item Fixed implementation of Abs operator for {\tt abstype}.
\item Print type name set $T$ of inferred basis in elaboration mode.
\item Fixed parenthesisation in pretty printing type applications.
\end{itemize}

Basis:
\begin{itemize} \setlength{\itemsep}{0em}
\item More correct path resolution for {\tt use} function.
\item Added {\tt checkFloat} to {\tt REAL} signature so that bootstrapping actually works again.
\item Fixed {\tt ArraySlice.copy} for overlapping ranges.
\item Fixed {\tt ArraySlice.foldr} and {\tt ArraySlice.foldri}.
\item Fixed {\tt Char.isSpace}.
\item Fixed octal escapes in {\tt Char.fromCString}.
\item Updated treatment of trailing gap escapes in {\tt Char.scan}.
\item Updated scanning of hex prefix in {\tt Word.scan}.
\item Fixed traversal order in {\tt Vector.map}.
\end{itemize}

Documentation:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added typo in rule 28 to issue list.
\end{itemize}

Test files:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added {\tt generalise}.
\item Extended {\tt poly-exception}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2.1 (2005/07/27)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Fixed bug in implementation of rule 35.
\item Fixed bug in check for redundant match rules.
\end{itemize}

Basis:
\begin{itemize} \setlength{\itemsep}{0em}
\item Fixed {\tt Substring.splitr}.
\item Fixed border cases in {\tt OS.Path.toString}, {\tt OS.Path.joinBaseExt}, {\tt OS.Path.mkAbsolute}, and {\tt OS.Path.mkRelative}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2.2 (2005/12/09)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Simplified implementation of pattern checker.
\end{itemize}

Test files:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added {\tt fun-infix}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2.3 (2006/07/18)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Fixed check for duplicate variables in records and layered patterns.
\item Added missing check for undetermined types in functor declarations.
\item Overhaul of line/column computation and management of source file names.
\end{itemize}

Documentation:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added principal typing problem with functors to issue list.
\end{itemize}

Test files:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added {\tt fun-partial}, {\tt functor-poly} and {\tt functor-poly2}.
\item Updated conformance table.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2.4 (2006/08/14)}

Documentation:
\begin{itemize} \setlength{\itemsep}{0em}
\item Clarified license.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.3.0 (2007/03/22)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Output abstract syntax tree in parsing mode.
\item Output type and signature environments in evaluation mode.
\item Fixed computation of tynames on a static basis.
\item Reorganised directory structure.
\item Some clean-ups.
\end{itemize}

Documentation:
\begin{itemize} \setlength{\itemsep}{0em}
\item Updated a few out-of-sync sections.
\item Added typo in definition of $\downarrow$ operator (Section 7.2) to issues list.
\end{itemize}

Test files:
\begin{itemize} \setlength{\itemsep}{0em}
\item Extended {\tt sharing} and {\tt where}.
\item Updated conformance table.
\end{itemize}

Platforms:
\begin{itemize} \setlength{\itemsep}{0em}
\item Support for Poly/ML, Alice ML, and the ML Kit.
\item Support for incremental batch compilation with Moscow ML and Alice ML.
\item Target to build a generic monolithic source file.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2.2/S1 (2005/12/12)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Implemented RFC: Syntax fixes.
\item Implemented RFC: Semantic fixes.
\item Implemented RFC: Line comments.
\item Implemented RFC: Extended literal syntax.
\item Implemented RFC: Record punning.
\item Implemented RFC: Record extension.
\item Implemented RFC: Record update.
\item Implemented RFC: Disjunctive patterns.
\item Implemented RFC: Conjunctive patterns.
\item Implemented RFC: Match guards.
\item Implemented RFC: Optional bar in matches.
\item Implemented RFC: Simplified recursive bindings.
\item Implemented RFC: Strengthened value restriction.
\item Implemented RFC: Degraded abstype.
\item Implemented RFC: Proper scoping for transparent type specifications.
\item Implemented RFC: Withtype specifications.
\item Implemented RFC: Remove "and" in type realisations.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2.2/S2 (2006/01/02)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Implemented RFC: Do declarations.
\item Extended RFC: Record extension to support record type extension and freely placed ellipses.
\item Fixed bug in record type field lookup.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2.3/S2 (2006/07/18)}

Merged changes from 1.2.3.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2.4/S2 (2006/08/14)}

Documentation:
\begin{itemize} \setlength{\itemsep}{0em}
\item Clarified license.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.2.4/S3 (2006/09/10)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Modified RFC: Line comments to use {\tt (*)} as delimiter.
\item Extended RFC: Optional bar in matches to support datatype declarations and specifications.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.3.0/S4 (2007/03/22)}

Merged changes from 1.3.0, plus:

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Implemented RFC: Views.
\item Implemented RFC: Nested matches.
\item Implemented RFC: Transformation patterns.
\item Generalised RFC: Match guards to Pattern guards.
\item Implemented RFC: Higher-order functors.
\item Implemented RFC: Nested signatures.
\item Implemented RFC: Local modules.
\item Implemented RFC: First-class modules.
\item Extended RFC: Optional bars to cover semicolons as well.
\end{itemize}

Documentation:
\begin{itemize} \setlength{\itemsep}{0em}
\item Added Appendix \ref{extensions} documenting all extensions.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.3.1 (2008/04/28)}

Platforms:
\begin{itemize} \setlength{\itemsep}{0em}
\item Preliminary support for SML\#.
\item Avoid name clash with library of SML/NJ 110.67.
\item Avoid shell-specific code in {\tt Makefile}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.3.1/S5 (2008/04/28)}

Merged changes from 1.3.1, plus:

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Implemented RFC: Optional {\tt else} branch.
\item Fixed and simplified definition of signature matching for RFC: Higher-order functors.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.3.2 (unreleased)}

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Fixed bug in lexing of negative hex constants (thanks to Matthew Fluet).
\item Fixed bug in evaluation order of `open` with multiple structures (reported by Arata Mizuki).
\end{itemize}

Build:
\begin{itemize} \setlength{\itemsep}{0em}
\item Avoid backslashes in echo command, problematic on MacOS (thanks to Arata Mizuki).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Version 1.3.2/S6 (2025/07/27)}

Merged changes from 1.3.2, plus:

Interpreter:
\begin{itemize} \setlength{\itemsep}{0em}
\item Adjust functional record update to match spec, making exprow optional (reported by Arata Mizuki).
\item Fix exhaustiveness check for record ellipses (reported by Arata Mizuki).
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vfill
\pagebreak
\begin{thebibliography}{MTHM97}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibitem[MTHM97]{definition}
Robin Milner, Mads Tofte, Robert Harper, David MacQueen \\
{\it The Definition of Standard ML} (Revised) \\
The MIT Press, 1997

\bibitem[MTH90]{definition90}
Robin Milner, Mads Tofte, Robert Harper \\
{\it The Definition of Standard ML} \\
The MIT Press, 1990

\bibitem[MT91]{commentary}
Robin Milner, Mads Tofte \\
{\it Commentary on Standard ML} \\
The MIT Press, 1991

\bibitem[K93]{mistakes}
Stefan Kahrs \\
{\it Mistakes and Ambiguities in the Definition of Standard ML} \\
University of Edinburgh, 1993 \\
{\small\tt{http://www.cs.ukc.ac.uk/pubs/1993/569/}}

\bibitem[SML05]{successorml}
{\it Successor ML} \\
{\small\tt{http://www.successor-ml.org/}}

\bibitem[K96]{addenda}
Stefan Kahrs \\
{\it Mistakes and Ambiguities in the Definition of Standard ML -- Addenda} \\
University of Edinburgh, 1996 \\
{\small\tt{ftp://ftp.dcs.ed.ac.uk/pub/smk/SML/errors-new.ps.Z}}

\bibitem[MT94]{higherfunctors}
Dave MacQueen, Mads Tofte \\
{\it A Semantics for Higher-order Functors} \\
in: Proc. of the 5th European Symposium on Programming \\
Springer-Verlag, 1994

\bibitem[DB07]{principalmodules}
Derek Dreyer, Matthias Blume \\
{\it Principal Type Schemes for Modular Programs} \\
in: Proc. of the 2007 European Symposium on Programming \\
Springer-Verlag, 2007

\void{
\bibitem[DHCK06]{typeclasses}
Derek Dreyer, Robert Harper, Manuel Chakravarty, Gabriele Keller \\
{\it Modular Type Classes} \\
Draft, 2006 \\
{\small\tt{http://www.cs.cmu.edu/~rwh/papers/mtc/apr06.pdf}}
}

\bibitem[L97]{translucent}
Mark Lillibridge \\
{\it Translucent Sums: A Foundation for Higher-Order Module Systems} \\
PhD Thesis \\
School of Computer Science, Carnegie Mellon University, 1997

\bibitem[W87]{views}
Philip Wadler \\
{\it Views: a way for pattern matching to cohabit with data abstraction} \\
in: Proc. of the 14th Annual ACM Symposium on Principles of Programming Languages \\
ACM Press, 1987

\bibitem[O98]{sml-views}
Chris Okasaki \\
{\it Views for {Standard ML}} \\
in: 1998 ACM SIGPLAN Workshop on ML \\
ACM Press, 1998

\bibitem[GR96]{basis-old}
Emden Gansner, John Reppy \\
{\it The Standard ML Basis Library}
(preliminary version 1996) \\
AT\&T and Lucent Technologies, 2004 \\
{\small\tt{http://cm.bell-labs.com/cm/cs/what/smlnj/doc/basis/}}

\bibitem[GR04]{basis}
Emden Gansner, John Reppy \\
{\it The Standard ML Basis Library} \\
Cambridge University Press, 2004 \\
{\small\tt{http://www.standardml.org/Basis/}}

\bibitem[DM82]{principal}
Luis Damas, Robin Milner \\
{\it Principal type schemes for functional programs} \\
in: Proc. of 9th Annual ACM Symposium on Principles of Programming Languages \\
ACM Press, 1982

\bibitem[C87]{typechecking}
Luca Cardelli \\
{\it Basic Polymorphic Typechecking} \\
in: {\it Science of Computer Programming} 8(2) \\
Elsevier Science Publisher, 1987

\bibitem[S96]{patterns}
Peter Sestoft \\
{\it ML pattern match compilation and partial evaluation} \\
in: Dagstuhl Seminar on Partial Evaluation, LNCS 1110 \\
Springer-Verlag 1996 \\
{\small\tt{ftp://ftp.dina.kvl.dk/pub/Staff/Peter.Sestoft/papers/match.ps.gz}}

\bibitem[W98]{pretty}
Philip Wadler \\
{\it A prettier printer} \\
in: The Fun of Programming \\
Palgrave Macmillan, 2003 \\
{\small\tt{http://cm.bell-labs.com/cm/cs/who/wadler/}}

\bibitem[BRTT93]{kit}
Lars Birkedal, Nick Rothwell, Mads Tofte, David Turner \\
{\it The ML Kit} (Version 1) \\
{\small\tt{http://www.diku.dk/research-groups/topps/activities/kit2/mlkit1.html}}

\bibitem[K06]{mlkit}
{\it The ML Kit} \\
{\small\tt{http://www.it-c.dk/research/mlkit/}}

\bibitem[NJ07]{smlnj}
{\it Standard ML of New Jersey} \\
{\small\tt{http://cm.bell-labs.com/cm/cs/what/smlnj/}}

\bibitem[NJ98]{njlib}
{\it The SML/NJ Library} \\
{\small\tt{http://cm.bell-labs.com/cm/cs/what/smlnj/doc/smlnj-lib/index.html}}

\bibitem[CFJW05]{mlton}
Henry Cejtin, Matthew Fluet, Suresh Jagannathan, Stephen Weeks \\
{\it MLton User Guide} \\
{\small\tt{http://www.mlton.org/}}

\bibitem[M07]{polyml}
David Matthews \\
{\it Poly/ML} \\
{\small\tt{http://www.polyml.org/}}

\bibitem[RRS00]{mosml}
Sergei Romanenko, Claudio Russo, Peter Sestoft \\
{\it Moscow ML Owner's Manual} (Version 2.01) \\
{\small\tt{http://www.dina.kvl.dk/~sestoft/mosml.html}}

\bibitem[AT06]{alice}
{\it The Alice Programming System} \\
{\small\tt{http://www.ps.uni-sb.de/alice/}}

\bibitem[ST07]{smlsharp}
{\it SML\# Project} \\
{\small\tt{http://www.pllab.riec.tohoku.ac.jp/smlsharp/}}

\bibitem[TA00]{mlyacc}
David Tarditi, Andrew Appel \\
{\it ML-Yacc User Manual} (Version 2.4) \\
{\small\tt{http://cm.bell-labs.com/cm/cs/what/smlnj/doc/ML-Yacc/manual.html}}

\bibitem[AMT94]{mllex}
Andrew Appel, James Mattson, David Tarditi \\
{\it A lexical analyzer generator for Standard ML} (Version 1.6.0) \\
{\small\tt{http://cm.bell-labs.com/cm/cs/what/smlnj/doc/ML-Lex/manual.html}}

\end{thebibliography}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{appendix}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
