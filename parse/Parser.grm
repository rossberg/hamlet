(*										*)
(* (c) Andreas Rossberg 1999-2007						*)
(*										*)
(* Standard ML syntactical analysis						*)
(*										*)
(* Definition, Sections 2, 3, and 8, Appendix A and B				*)
(* + RFC: Syntax fixes								*)
(* + RFC: Extended literal syntax						*)
(* + RFC: Optional bars and semicolons						*)
(* + RFC: Optional else branch							*)
(* + RFC: Record punning							*)
(* + RFC: Record extension							*)
(* + RFC: Record update								*)
(* + RFC: Conjunctive patterns							*)
(* + RFC: Disjunctive patterns							*)
(* + RFC: Nested matches							*)
(* + RFC: Pattern guards							*)
(* + RFC: Transformation patterns						*)
(* + RFC: Views									*)
(* + RFC: Simplified recursive value bindings					*)
(* + RFC: Do declarations							*)
(* + RFC: Withtype in signatures						*)
(* + RFC: Abolish sequenced type realisations					*)
(* + RFC: Higher-order functors							*)
(* + RFC: Nested signatures							*)
(* + RFC: Local modules								*)
(* + RFC: First-class modules							*)
(*										*)
(* Notes:									*)
(*   - Two phrases named Fmatch and Fmrule have been added to factorize		*)
(*     Fvalbind.								*)
(*   - A phrase named SynDesc has been added to factorize type synonym		*)
(*     specifications.								*)
(*   - Infix expressions [Definition, Section 2.6] are resolved externally in	*)
(*     structure Infix. The parser just maintains the infix environment J by	*)
(*     side effect. To achieve correct treatment of scoped fixity directives,	*)
(*     a stack of environments is used. To handle `local' we even need a	*)
(*     second environment J' (together with a a second stack).			*)
(*   - Syntactic restrictions [Definition, Sections 2.9 and 3.5] are checked	*)
(*     in a separate pass.							*)
(*   - Although not completely clear from the wording we assume that the	*)
(*     Definition rules out the use of `=' as a tycon. Otherwise we would have	*)
(*     a massive amount of grammar conflicts.					*)
(*   - Datatype replication requires rules for datatype to be duplicated to	*)
(*     avoid conflicts on empty tyvarseqs.					*)
(*   - ML-Yacc does not seem to like comments that stretch over several		*)
(*     lines... Similarly, comments in semantic actions make it puke...		*)
(*										*)


    (* Import *)

    open GrammarCore
    open GrammarModule
    open GrammarProgram
    open DerivedFormsCore
    open DerivedFormsModule
    open DerivedFormsProgram


    (* Handling infix environments *)

    val J  = ref Infix.empty	(* context *)
    val J' = ref Infix.empty	(* local environment (+ enclosing one) *)

    val stackJ  = ref [] : Infix.InfEnv list ref
    val stackJ' = ref [] : Infix.InfEnv list ref

    fun initJandJ'(J0) =
	(
	    J       := J0;
	    J'      := J0;
	    stackJ  := [];
	    stackJ' := []
	)

    fun pushJ() =
	(
	    stackJ  := !J :: !stackJ
	)

    fun popJ() =
	(
	    J       := List.hd(!stackJ);
	    stackJ  := List.tl(!stackJ)
	)

    fun pushJ'shiftJ() =
	(
	    stackJ' := !J' :: !stackJ';
	    J'      := List.hd(!stackJ)
	)

    fun popJandJ'() =
	(
	    J       := !J';
	    J'      := List.hd(!stackJ');
	    stackJ  := List.tl(!stackJ);
	    stackJ' := List.tl(!stackJ')
	)


    fun assignInfix(infstatus, vids) =
	(
	    J  := Infix.assign(!J, vids, infstatus);
	    J' := Infix.assign(!J', vids, infstatus)
	)

    fun cancelInfix(vids) =
	(
	    J  := Infix.cancel(!J, vids);
	    J' := Infix.cancel(!J', vids)
	)


    (* Helper for long identifiers *)

    fun toLongId toId (strids, id) =
	    ( List.map StrId.fromString strids, toId id )


%%


%header (functor LrValsFn(structure Token : TOKEN))
%name Parser

%pos  Source.pos
%arg  (I, J0) : (Source.pos * Source.pos -> Source.info) * Infix.InfEnv

%verbose



%term	(* End of file *)
	  EOF

	(* Reserved words for the core language
	 * [Section 2.1; RFC: Transformation patterns; RFC: Views;
			 RFC: First-class modules] *)
	| ABSTYPE | AND | ANDALSO | AS | CASE | DO | DATATYPE | ELSE
	| END | EXCEPTION | FN | FUN | HANDLE | IF | IN | INFIX
	| INFIXR | LET | LOCAL | NONFIX | OF | OP | OPEN | ORELSE | PACK
	| RAISE | REC | THEN | TYPE | VAL | VIEWTYPE | WITH | WITHTYPE | WHILE
	| LPAR | RPAR | LBRACK | RBRACK | LBRACE | RBRACE | COMMA | COLON
	| SEMICOLON | DOTS | UNDERBAR | BAR | EQUALS | DARROW | ARROW | HASH
	| QUEST

	(* Additional reserved words for the modules language
	 * [Section 3.1; RFC: Higher-order functors;
	 *               RFC: First-class modules] *)
	| EQTYPE | FCT | FUNCTOR | INCLUDE | SHARING | SIG
	| SIGNATURE | STRUCT | STRUCTURE | UNPACK | WHERE | SEAL

	(* Special constants [Section 2.2] *)
	| ZERO | DIGIT of string | NUMERIC of string
	| INT of string | HEXINT of string | BININT of string
	| WORD of string | HEXWORD of string | BINWORD of string
	| REAL of string | STRING of string | CHAR of string

	(* Identifiers [Section 2.4] *)
	| ALPHA of string | SYMBOL of string | STAR
	| TYVAR of string | ETYVAR of string
	| LONGID of string list * string

%keyword ABSTYPE AND ANDALSO AS CASE DO DATATYPE ELSE
	 END EXCEPTION FN FUN HANDLE IF IN INFIX
	 INFIXR LET LOCAL NONFIX OF OP OPEN ORELSE
	 RAISE REC THEN TYPE VAL VIEWTYPE WITH WITHTYPE WHILE
	 EQTYPE FUNCTOR INCLUDE SHARING SIG
	 SIGNATURE STRUCT STRUCTURE WHERE

%eop     EOF
%noshift EOF


%left  SEMICOLON SHARING
%right VAL FUN TYPE EQTYPE DATATYPE ABSTYPE VIEWTYPE EXCEPTION
       STRUCTURE SIGNATURE FUNCTOR
%right LOCAL OPEN INFIX INFIXR NONFIX INCLUDE
%right AND
%left  DARROW		(* L/R is arbitrary *)
%left  BAR		(* L/R is arbitrary *)
%left  WITH		(* L/R is arbitrary *)
%left  DO		(* L/R is arbitrary *)
%right ELSE
%left  RAISE		(* L/R is arbitrary *)
%right HANDLE
%right ORELSE
%right ANDALSO
%right AS
%left  COLON SEAL
%right ARROW WHERE


%start program

%nonterm
	(* Constants *)
	  scon				of SCon
	| d				of int

	(* Identifiers and labels *)
	| lab				of Lab
	| vid				of VId
	|    vid'			of VId		(* excludes `=' *)
	| tycon				of TyCon
	| tyvar				of TyVar
	| strid				of StrId
	| sigid				of SigId
	(* Removed funid [RFC: Higher-order functors] *)

	| longvid			of longVId
	|    longvid'			of longVId	(* excludes `=' *)
	| longtycon			of longTyCon
	| longstrid			of longStrId
	(* [RFC: Nested signatures] *)
	| longsigid			of longSigId

	| OP_opt			of Op
	(* [RFC: Simplified recursive value bindings] *)
	| REC_opt			of Rec

	(* Nonterminals for core grammar *)
	| atexp				of AtExp
	|    exp_COMMA_list0		of Exp list
	|    exp_COMMA_list1		of Exp list
	|    exp_COMMA_list2		of Exp list
	|    exp_SEMICOLON_list1	of Exp list
	|    exp_SEMICOLON_list2	of Exp list
	| exprow			of ExpRow
	|    exprow_opt			of ExpRow option
	|    COMMA_exprow_opt		of ExpRow option
	| appexp			of AppExp
	| infexp			of InfExp
	| exp				of Exp
	|    BAR_opt			of unit
	|    ELSE_exp_opt		of Exp option

	| match				of Match
	|    BAR_match_opt		of Match option
	| mrule				of Mrule

	| dec				of Dec
	|    dec'			of Dec (* excludes semicolon *)
	|    dec1			of Dec
	|    dec1'			of Dec (* excludes semicolon *)
	|    dec1''			of Dec (* excludes sequencing *)
	|    WITHTYPE_typbind_opt	of TypBind option
	|    vid_list1			of VId list
	|    d_opt			of int
	| valbind			of ValBind
	|    AND_valbind_opt		of ValBind option
	| fvalbind			of FvalBind
	|    AND_fvalbind_opt		of FvalBind option
	| fmatch			of Fmatch
	|    BAR_fmatch_opt		of Fmatch option
	(* [RFC: Syntax fixes] *)
	| fmrule			of Fmrule
	|    atpat_list1		of AtPat list
	|    IF_atexp_opt		of AtExp option
	| typbind			of TypBind
	|    AND_typbind_opt		of TypBind option
	| datbind			of DatBind
	|    datbind0			of DatBind
	|    datbind1			of DatBind
	|    AND_datbind_opt		of DatBind option
	| conbind			of ConBind
	|    BAR_conbind_opt		of ConBind option
	|    OF_ty_opt			of Ty option
	| exbind			of ExBind
	|    AND_exbind_opt		of ExBind option

	| atpat				of AtPat
	|    atpat'			of AtPat (* excludes <op>longvid *)
	|    pat_COMMA_list0		of Pat list
	|    pat_COMMA_list1		of Pat list
	|    pat_COMMA_list2		of Pat list
	| patrow			of PatRow
	|    patrow_opt			of PatRow option
	|    EQUALS_pat_opt		of Pat option
	|    COMMA_patrow_opt		of PatRow option
	|    COLON_ty_opt		of Ty option
	|    AS_pat_opt			of Pat option
	(* [RFC: Syntax fixes] *)
	| apppat			of AppPat
	(* [RFC: Syntax fixes] *)
	| infpat			of InfPat
	| pat				of Pat
	|    pat'			of Pat

	| ty				of Ty
	|    tupty			of Ty
	|    ty_STAR_list		of Ty list
	|    consty			of Ty
	|    atty			of Ty
	| tyrow				of TyRow
	|    tyrow_opt			of TyRow option
	|    COMMA_tyrow_opt		of TyRow option
	| tyseq				of Tyseq
	|    ty_COMMA_list2		of Ty list
	| tyvarseq			of TyVarseq
	|    tyvarseq1			of TyVarseq
	|    tyvar_COMMA_list1		of TyVar list

	(* Nonterminals for the module language *)
	(* [RFC: Higher-order functors] *)
	| atstrexp			of AtStrExp
	| appstrexp			of AppStrExp
	| strexp			of StrExp
	| strdec			of StrDec
	| strbind			of StrBind
	|    AND_strbind_opt		of StrBind option
	|    COLON_sigexp_opt		of SigExp option

	| atsigexp			of AtSigExp
	| sigexp			of SigExp
	(* Removed sigdec [RFC: Nested signatures] *)
	| sigbind			of SigBind
	|    AND_sigbind_opt		of SigBind option

	| spec				of Spec
	|    spec1			of Spec
	|    spec1'			of Spec (* excludes sharing *)
	|    spec1''			of Spec (* excludes sharing and seq. *)
	(* [RFC: Nested signatures] *)
	|    longsigid_list2		of longSigId list
	|    longtycon_EQUALS_list1	of longTyCon list
	|    longtycon_EQUALS_list2	of longTyCon list
	|    longstrid_EQUALS_list1	of longStrId list
	|    longstrid_EQUALS_list2	of longStrId list

	| valdesc			of ValDesc
	|    AND_valdesc_opt		of ValDesc option
	| typdesc			of TypDesc
	|    AND_typdesc_opt		of TypDesc option
	| syndesc			of SynDesc
	|    AND_syndesc_opt		of SynDesc option
	| datdesc			of DatDesc
	|    datdesc0			of DatDesc
	|    datdesc1			of DatDesc
	|    AND_datdesc_opt		of DatDesc option
	| condesc			of ConDesc
	|    BAR_condesc_opt		of ConDesc option
	| exdesc			of ExDesc
	|    AND_exdesc_opt		of ExDesc option
	| strdesc			of StrDesc
	|    AND_strdesc_opt		of StrDesc option
	(* [RFC: Higher-order functors] *)
	| fundesc			of FunDesc
	|    AND_fundesc_opt		of FunDesc option
	| funarg			of FunArg
	|    funarg_list1		of FunArg list
	(* [RFC: Nested signatures] *)
	| sigdesc			of SigDesc
	|    AND_sigdesc_opt		of SigDesc option

	(* Removed fundec [RFC: Higher-order functors] *)
	| funbind			of FunBind
	|    AND_funbind_opt		of FunBind option
	| topdec			of TopDec

	(* Top nonterminal *)
	| program			of Program * Infix.InfEnv
	|    program'			of Program
	|    program_opt		of Program option

	(* Pseudo symbols to handle infix environment *)
	| initInfix			of unit
	| pushInfix			of unit
	| popInfix			of unit
	| pushLocalInfix		of unit
	| popLocalInfix			of unit


%%


  (* Handling of infix environment *)

  initInfix:		( initJandJ'(J0) )
  pushInfix:		( pushJ() )
  popInfix:		( popJ() )
  pushLocalInfix:	( pushJ'shiftJ() )
  popLocalInfix:	( popJandJ'() )



  (* Special constants [Section 2.2] *)

  scon:
	  ZERO		( SCon.INT(SCon.DEC, "0", ref NONE) )
	| DIGIT		( SCon.INT(SCon.DEC, DIGIT, ref NONE) )
	| NUMERIC	( SCon.INT(SCon.DEC, NUMERIC, ref NONE) )
	| INT		( SCon.INT(SCon.DEC, INT, ref NONE) )
	| HEXINT	( SCon.INT(SCon.HEX, HEXINT, ref NONE) )
	(* [RFC: Extended literal syntax] *)
	| BININT	( SCon.INT(SCon.BIN, BININT, ref NONE) )
	| WORD		( SCon.WORD(SCon.DEC, WORD, ref NONE) )
	| HEXWORD	( SCon.WORD(SCon.HEX, HEXWORD, ref NONE) )
	(* [RFC: Extended literal syntax] *)
	| BINWORD	( SCon.WORD(SCon.BIN, BINWORD, ref NONE) )
	| REAL		( SCon.REAL(REAL, ref NONE) )
	| STRING	( SCon.STRING(STRING, ref NONE) )
	| CHAR		( SCon.CHAR(CHAR, ref NONE) )

  d:
	  ZERO		( 0 )
	| DIGIT		( Option.valOf(Int.fromString DIGIT) )



  (* Identifiers [Section 2.4] *)

  lab:
	  ALPHA		( Lab.fromString ALPHA )
	| SYMBOL	( Lab.fromString SYMBOL )
	| STAR		( Lab.fromString "*" )
	| DIGIT		( Lab.fromString DIGIT )
	| NUMERIC	( Lab.fromString NUMERIC )


  vid:
	  vid'		( vid' )
	| EQUALS	( VId.fromString "=" )

     vid':
	  ALPHA		( VId.fromString ALPHA )
	| SYMBOL	( VId.fromString SYMBOL )
	| STAR		( VId.fromString "*" )

  tycon:
	  ALPHA		( TyCon.fromString ALPHA )
	| SYMBOL	( TyCon.fromString SYMBOL )

  tyvar:  TYVAR		( TyVar.fromString TYVAR )

  strid:  ALPHA		( StrId.fromString ALPHA )

  sigid:  ALPHA		( SigId.fromString ALPHA )

  (* Removed funid [RFC: Higher-order functors] *)


  longvid:
	  longvid'	( longvid' )
	| EQUALS	( LongVId.fromId(VId.fromString "=") )

     longvid':
	  vid'		( LongVId.fromId vid' )
	| LONGID	( LongVId.implode(toLongId VId.fromString LONGID) )

  longtycon:
	  tycon		( LongTyCon.fromId tycon )
	| LONGID	( LongTyCon.implode(toLongId TyCon.fromString LONGID) )

  longstrid:
	  strid		( LongStrId.fromId strid )
	| LONGID	( LongStrId.implode(toLongId StrId.fromString LONGID) )

  (* [RFC: Nested signatures] *)
  longsigid:
	  sigid		( LongSigId.fromId sigid )
	| LONGID	( LongSigId.implode(toLongId SigId.fromString LONGID) )


  OP_opt:
	  OP		( WITHOp )
	| (*empty*)	( SANSOp )




  (* Core: Expressions [Figure 20] *)

  atexp:
	  scon		( SCONAtExp(I(sconleft,sconright), scon) )
	| longvid	( IDAtExp(I(longvidleft,longvidright), SANSOp, longvid))
	| OP longvid	( IDAtExp(I(OPleft,longvidright), WITHOp, longvid) )
	| LBRACE exprow_opt RBRACE
			( RECORDAtExp(I(LBRACEleft,RBRACEright), exprow_opt) )
	(* [RFC: Record update] *)
	| LBRACE atexp WHERE exprow_opt RBRACE
			( UPDATEAtExp(I(LBRACEleft,RBRACEright),
				      atexp, exprow_opt) )
	| HASH lab	( HASHAtExp(I(HASHleft,labright), lab) )
	| LPAR RPAR	( UNITAtExp(I(LPARleft,RPARright)) )
	| LPAR exp_COMMA_list2 RPAR
			( TUPLEAtExp(I(LPARleft,RPARright), exp_COMMA_list2) )
	| LBRACK exp_COMMA_list0 RBRACK
			( LISTAtExp(I(LBRACKleft,RBRACKright),
				    exp_COMMA_list0 ))
	| LPAR exp_SEMICOLON_list2 RPAR
			( SEQAtExp(I(LPARleft,RPARright), exp_SEMICOLON_list2) )
	| LET pushInfix dec IN exp_SEMICOLON_list1 popInfix END
			( LETAtExp(I(LETleft,ENDright),
				   dec, exp_SEMICOLON_list1) )
	| LPAR exp RPAR	( PARAtExp(I(LPARleft,RPARright), exp) )
	(* [RFC: Optional bars and semicolons] *)
	| LPAR exp SEMICOLON RPAR
			( PARAtExp(I(LPARleft,RPARright), exp) )

     exp_COMMA_list0:
	  exp_COMMA_list1		( exp_COMMA_list1 )
	| (*empty*)			( [] )

     exp_COMMA_list1:
	  exp COMMA exp_COMMA_list1	( exp::exp_COMMA_list1 )
	| exp				( exp::[] )

     exp_COMMA_list2:
	  exp COMMA exp_COMMA_list1	( exp::exp_COMMA_list1 )

     exp_SEMICOLON_list1:
	  exp SEMICOLON exp_SEMICOLON_list1	( exp::exp_SEMICOLON_list1 )
	(* [RFC: Optional bars and semicolons] *)
	| exp SEMICOLON				( exp::[] )
	| exp					( exp::[] )

     exp_SEMICOLON_list2:
	  exp SEMICOLON exp_SEMICOLON_list2	( exp::exp_SEMICOLON_list2 )
	(* [RFC: Optional bars and semicolons] *)
	| exp SEMICOLON exp SEMICOLON		( [exp1, exp2] )
	| exp SEMICOLON exp			( [exp1, exp2] )


  exprow:
	(* [RFC: Record extension] *)
	  DOTS EQUALS exp COMMA_exprow_opt
			( DOTSExpRow(I(DOTSleft,COMMA_exprow_optright),
				     exp, COMMA_exprow_opt) )
	| lab EQUALS exp COMMA_exprow_opt
	  		( FIELDExpRow(I(lableft,COMMA_exprow_optright),
	  			      lab, exp, COMMA_exprow_opt) )
	(* [RFC: record punning] *)
	| vid' COLON_ty_opt COMMA_exprow_opt
			( IDExpRow(I(vid'left,COMMA_exprow_optright),
				   vid', COLON_ty_opt, COMMA_exprow_opt) )
     COMMA_exprow_opt:
	  COMMA exprow		( SOME exprow )
	| (*empty*)		( NONE )

     exprow_opt:
	  exprow		( SOME exprow )
	| (*empty*)		( NONE )


  appexp:
	  atexp			( atexp::[] )
	| appexp atexp		( atexp::appexp )


  infexp:
	  appexp		( Infix.parseExp(!J, List.rev appexp) )
	(*infexp vid infexp	( included above... )*)


  exp:
	  infexp		( infexp )
	| exp COLON ty		( COLONExp(I(expleft,tyright), exp, ty) )
	(* [RFC: First-class modules] *)
	| PACK atstrexp COLON atsigexp
				( PACKExp(I(PACKleft,atsigexpright),
					  atstrexp, atsigexp) )
	| exp ANDALSO exp	( ANDALSOExp(I(exp1left,exp2right), exp1, exp2))
	| exp ORELSE exp	( ORELSEExp(I(exp1left,exp2right), exp1, exp2) )
	(* [RFC: Optional bars and semicolons] *)
	| exp HANDLE BAR_opt match
				( HANDLEExp(I(expleft,matchright), exp, match) )
	| RAISE exp		( RAISEExp(I(RAISEleft,expright), exp) )
	| IF exp THEN exp ELSE_exp_opt
				( IFExp(I(IFleft,ELSE_exp_optright),
					exp1, exp2, ELSE_exp_opt) )
	| WHILE exp DO exp	( WHILEExp(I(WHILEleft,exp2right), exp1, exp2) )
	(* [RFC: Optional bars and semicolons] *)
	| CASE exp OF BAR_opt match
				( CASEExp(I(CASEleft,matchright), exp, match) )
	(* [RFC: Optional bars and semicolons] *)
	| FN BAR_opt match	( FNExp(I(FNleft,matchright), match) )

     BAR_opt:
	  BAR			( () )
	| (*empty*)		( () )

     ELSE_exp_opt:
	  ELSE exp		( SOME exp )
	| (*empty*)		( NONE )


  (* Core: Matches [Figure 20] *)

  match:
	  mrule BAR_match_opt	( Match(I(mruleleft,BAR_match_optright),
					mrule, BAR_match_opt) )

     BAR_match_opt:
	  BAR match			( SOME match )
	| (*empty*) %prec DARROW	( NONE )

  mrule:
	  pat DARROW exp		( Mrule(I(patleft,expright), pat, exp) )



  (* Core: Declarations [Figure 21] *)

  dec:
	  dec1		( dec1 )
	| (*empty*)	( EMPTYDec(I(defaultPos,defaultPos)) )

     dec':
	  dec1'		( dec1' )
	| (*empty*)	( EMPTYDec(I(defaultPos,defaultPos)) )

     dec1:
	  dec1''	( dec1'' )
	| dec1 dec1 %prec SEMICOLON
			( SEQDec(I(dec11left,dec12right), dec11, dec12) )
	| SEMICOLON	( SEQDec(I(SEMICOLONleft,SEMICOLONright),
				 EMPTYDec(I(SEMICOLONleft,SEMICOLONleft)),
				 EMPTYDec(I(SEMICOLONright,SEMICOLONright))) )
     
     dec1':
	  dec1''	( dec1'' )
	| dec1' dec1' %prec SEMICOLON
			( SEQDec(I(dec1'1left,dec1'2right), dec1'1, dec1'2) )

     dec1'':
	(* [RFC: Do declarations] *)
	  DO exp	( DODec(I(DOleft,expright), exp) )
	(* [RFC: Simplified recursive value bindings] *)
	| VAL REC_opt valbind
			( VALDec(I(VALleft,valbindright), REC_opt,
			     TyVarseq(I(defaultPos,defaultPos), []), valbind) )
	| VAL REC_opt tyvarseq1 valbind
			( VALDec(I(VALleft,valbindright),
				 REC_opt, tyvarseq1, valbind) )
	(* [RFC: Optional bars and semicolons] *)
	| FUN fvalbind	( FUNDec(I(FUNleft,fvalbindright),
			    TyVarseq(I(defaultPos,defaultPos), []), fvalbind) )
	| FUN BAR fvalbind
			( FUNDec(I(FUNleft,fvalbindright),
			    TyVarseq(I(defaultPos,defaultPos), []), fvalbind) )
	| FUN tyvarseq1 BAR_opt fvalbind
			( FUNDec(I(FUNleft,fvalbindright), tyvarseq1, fvalbind))
	| TYPE typbind	( TYPEDec(I(TYPEleft,typbindright), typbind) )
	| DATATYPE datbind0 WITHTYPE_typbind_opt
			( DATATYPEDec(I(DATATYPEleft,WITHTYPE_typbind_optright),
				      datbind0, WITHTYPE_typbind_opt) )
	| DATATYPE datbind1 WITHTYPE_typbind_opt
			( DATATYPEDec(I(DATATYPEleft,WITHTYPE_typbind_optright),
				      datbind1, WITHTYPE_typbind_opt) )
	| DATATYPE tycon EQUALS DATATYPE longtycon
			( DATATYPE2Dec(I(DATATYPEleft,longtyconright),
				       tycon, longtycon) )
	(* [RFC: Views] *)
	| VIEWTYPE tycon EQUALS ty AS BAR_opt conbind WITH dec END
			( VIEWTYPEDec(I(VIEWTYPEleft,ENDright),
				      TyVarseq(I(defaultPos,defaultPos), []),
				      tycon, ty, conbind, dec) )
	(* [RFC: Views] *)
	| VIEWTYPE tyvarseq1 tycon EQUALS ty AS BAR_opt conbind WITH dec END
			( VIEWTYPEDec(I(VIEWTYPEleft,ENDright),
				      tyvarseq1, tycon, ty, conbind, dec) )
	(* [RFC: Views] *)
	| VIEWTYPE tycon EQUALS VIEWTYPE longtycon
			( VIEWTYPE2Dec(I(VIEWTYPEleft,longtyconright),
				       tycon, longtycon) )
	| ABSTYPE datbind WITHTYPE_typbind_opt WITH dec END
			( ABSTYPEDec(I(ABSTYPEleft,ENDright), datbind,
				     WITHTYPE_typbind_opt, dec) )
	| EXCEPTION exbind
			( EXCEPTIONDec(I(EXCEPTIONleft,exbindright), exbind) )
	| strdec	( STRDECDec(I(strdecleft,strdecright), StrDec strdec) )
	(* [RFC: Local modules] *)
	| OPEN strexp	( OPENDec(I(OPENleft,strexpright), strexp) )
	(*OPEN longstrid_list1	( included above ) *)
	| LOCAL pushInfix dec IN pushLocalInfix dec popLocalInfix END
			( LOCALDec(I(LOCALleft,ENDright), dec1, dec2) )
	| INFIX d_opt vid_list1
			( assignInfix((Infix.LEFT, d_opt), vid_list1);
			  EMPTYDec(I(INFIXleft,vid_list1right)) )
	| INFIXR d_opt vid_list1
			( assignInfix((Infix.RIGHT, d_opt), vid_list1);
			  EMPTYDec(I(INFIXRleft,vid_list1right)) )
	| NONFIX vid_list1
			( cancelInfix(vid_list1);
			  EMPTYDec(I(NONFIXleft,vid_list1right)) )

     REC_opt:
	  REC			( WITHRec )
	| (*empty*)		( SANSRec )

     WITHTYPE_typbind_opt:
	  WITHTYPE typbind	( SOME typbind )
	| (*empty*)		( NONE )

     vid_list1:
	  vid vid_list1		( vid::vid_list1 )
	| vid			( vid::[] )

     d_opt:
	  d			( d )
	| (*empty*)		( 0 )



  (* Core: Bindings [Figure 21] *)

  valbind:
	  pat' EQUALS exp AND_valbind_opt
			( ValBind(I(pat'left,AND_valbind_optright),
				  pat', exp, AND_valbind_opt) )
	(* Removed RECValBind [RFC: Simplified recursive value bindings] *)

      AND_valbind_opt:
	  AND valbind	( SOME valbind )
	| (*empty*)	( NONE )


  fvalbind:
	  fmatch AND_fvalbind_opt
			( FvalBind(I(fmatchleft,AND_fvalbind_optright),
				     fmatch, AND_fvalbind_opt) )
     AND_fvalbind_opt:
	  AND fvalbind	( SOME fvalbind )
	| (*empty*)	( NONE )

  fmatch:
	  fmrule BAR_fmatch_opt
			( Fmatch(I(fmruleleft,BAR_fmatch_optright),
				 fmrule, BAR_fmatch_opt) )

     BAR_fmatch_opt:
	  BAR fmatch	( SOME fmatch )
	| (*empty*)	( NONE )

  (* [RFC: Syntax fixes] *)
  fmrule:
	  (* [RFC: Pattern guards] *)
	  atpat_list1 COLON_ty_opt IF_atexp_opt EQUALS exp
			( let
			    val (op_opt, vid, atpats) =
				Infix.parseFmrule(!J, atpat_list1)
			  in
			    Fmrule(I(atpat_list1left,expright),
				   op_opt, vid, atpats, COLON_ty_opt,
				   IF_atexp_opt, exp)
			  end )

     atpat_list1:
	  atpat atpat_list1	( atpat::atpat_list1 )
	| atpat			( atpat::[] )

     IF_atexp_opt:
	  IF atexp		( SOME atexp )
	| (*empty*)		( NONE )


  typbind:
	  tyvarseq tycon EQUALS ty AND_typbind_opt
			( TypBind(I(tyvarseqleft,AND_typbind_optright),
				  tyvarseq, tycon, ty, AND_typbind_opt) )

     AND_typbind_opt:
	  AND typbind	( SOME typbind )
	| (*empty*)	( NONE )


  datbind:
	(* [RFC: Optional bars and semicolons] *)
	  tyvarseq tycon EQUALS BAR_opt conbind AND_datbind_opt
			( DatBind(I(tyvarseqleft,AND_datbind_optright),
				  tyvarseq, tycon, conbind, AND_datbind_opt) )
     datbind0:
	(* [RFC: Optional bars and semicolons] *)
	  tycon EQUALS BAR_opt conbind AND_datbind_opt
			( DatBind(I(tyconleft,AND_datbind_optright),
				  TyVarseq(I(defaultPos,defaultPos), []),
				  tycon, conbind, AND_datbind_opt) )
     datbind1:
	(* [RFC: Optional bars and semicolons] *)
	  tyvarseq1 tycon EQUALS BAR_opt conbind AND_datbind_opt
			( DatBind(I(tyvarseq1left,AND_datbind_optright),
				  tyvarseq1, tycon, conbind, AND_datbind_opt) )

     AND_datbind_opt:
	  AND datbind	( SOME datbind )
	| (*empty*)	( NONE )


  conbind:
	  OP_opt vid' OF_ty_opt BAR_conbind_opt
			( ConBind(I(OP_optleft,BAR_conbind_optright),
				  OP_opt, vid', OF_ty_opt, BAR_conbind_opt) )

     BAR_conbind_opt:
	  BAR conbind	( SOME conbind )
	| (*empty*)	( NONE )

     OF_ty_opt:
	  OF ty		( SOME ty )
	| (*empty*)	( NONE )


  exbind:
	  OP_opt vid' OF_ty_opt AND_exbind_opt
			( NEWExBind(I(OP_optleft,AND_exbind_optright),
				    OP_opt, vid', OF_ty_opt, AND_exbind_opt) )
	| OP_opt vid' EQUALS OP_opt longvid AND_exbind_opt
			( EQUALExBind(I(OP_opt1left,AND_exbind_optright),
				      OP_opt1, vid', OP_opt2, longvid,
				      AND_exbind_opt) )
     AND_exbind_opt:
	  AND exbind	( SOME exbind )
	| (*empty*)	( NONE )



  (* Core: Patterns [Figure 22] *)

  atpat:
	  atpat'	( atpat' )
	| OP_opt longvid'
			( IDAtPat(I(OP_optleft,longvid'right),
				  OP_opt, longvid') )
     atpat':
	  UNDERBAR	( WILDCARDAtPat(I(UNDERBARleft,UNDERBARright)) )
	| scon		( SCONAtPat(I(sconleft,sconright), scon) )
	| LBRACE patrow_opt RBRACE
			( RECORDAtPat(I(LBRACEleft,RBRACEright), patrow_opt) )
	| LPAR RPAR	( UNITAtPat(I(LPARleft,RPARright)) )
	| LPAR pat_COMMA_list2 RPAR
			( TUPLEAtPat(I(LPARleft,RPARright), pat_COMMA_list2) )
	| LBRACK pat_COMMA_list0 RBRACK
			( LISTAtPat(I(LBRACKleft,RBRACKright),
				    pat_COMMA_list0) )
	| LPAR pat RPAR ( PARAtPat(I(LPARleft,RPARright), pat) )
	(* [RFC: Transformation patterns] *)
	| QUEST atexp	( QUESTAtPat(I(QUESTleft,atexpright), atexp) )


     pat_COMMA_list0:
	  pat_COMMA_list1		( pat_COMMA_list1 )
	| (*empty*)			( [] )

     pat_COMMA_list1:
	  pat COMMA pat_COMMA_list1	( pat::pat_COMMA_list1 )
	| pat				( pat::[] )

     pat_COMMA_list2:
	  pat COMMA pat_COMMA_list1	( pat::pat_COMMA_list1 )



  patrow:
	  (* [RFC: Record extension] *)
	  DOTS EQUALS_pat_opt COMMA_patrow_opt
			( DOTSPatRow(I(DOTSleft,COMMA_patrow_optright),
				     EQUALS_pat_opt, COMMA_patrow_opt) )
	| lab EQUALS pat COMMA_patrow_opt
			( FIELDPatRow(I(lableft,COMMA_patrow_optright),
				      lab, pat, COMMA_patrow_opt) )
	| vid' COLON_ty_opt AS_pat_opt COMMA_patrow_opt
			( IDPatRow(I(vid'left,COMMA_patrow_optright),
				   vid', COLON_ty_opt, AS_pat_opt,
				   COMMA_patrow_opt) )
     EQUALS_pat_opt:
	  EQUALS pat	( SOME pat )
	| (*empty*)	( NONE )

     COMMA_patrow_opt:
	  COMMA patrow	( SOME patrow )
	| (*empty*)	( NONE )

     COLON_ty_opt:
	  COLON ty	( SOME ty )
	| (*empty*)	( NONE )

     AS_pat_opt:
	  AS pat	( SOME pat )
	| (*empty*)	( NONE )

     patrow_opt:
	  patrow	( SOME patrow )
	| (*empty*)	( NONE )


  (* [RFC: Syntax fixes] *)
  apppat:
	  atpat		( atpat::[] )
	| apppat atpat	( atpat::apppat )


  (* [RFC: Syntax fixes] *)
  infpat:
	  apppat	( Infix.parsePat(!J, List.rev apppat) )
	(*infpat vid infpat
			( included above... )*)
	(* [RFC: Transformation patterns] *)
	(*QUEST atexp atpat
			( included above... )*)


  pat:
	  pat'		( pat' )
	(* [RFC: Pattern guards] *)
	| pat IF exp	( IFPat(I(patleft,expright), pat, exp) )
	(* [RFC: Nested matches] *)
	| pat WITH pat' EQUALS exp
			( WITHPat(I(pat1left,expright), pat, pat', exp) )
    pat':
	  infpat	( infpat )
	| pat' COLON ty	( COLONPat(I(pat'left,tyright), pat', ty) )
	(* [RFC: Conjunctive patterns] *)
	| pat' AS pat'	( ASPat(I(pat'1left,pat'2right), pat'1, pat'2) )
	(* [RFC: Disjunctive patterns] *)
	| pat' BAR pat'	( BARPat(I(pat'1left,pat'2right), pat'1, pat'2) )
  



  (* Core: Type expressions [Figure 23] *)

  ty:
	  tupty		 ( tupty )
	| tupty ARROW ty ( ARROWTy(I(tuptyleft,tyright), tupty, ty) )

     tupty:
	  ty_STAR_list	 ( TUPLETy(I(ty_STAR_listleft,ty_STAR_listright),
				   ty_STAR_list) )

     ty_STAR_list:
	  consty STAR ty_STAR_list	( consty::ty_STAR_list )
	| consty	 		( consty::[] )	  

     consty:
	  atty			( atty )
	| tyseq longtycon	( CONTy(I(tyseqleft,longtyconright),
					tyseq, longtycon) )
     atty:
	  tyvar		( VARTy(I(tyvarleft,tyvarright), tyvar) )
	| LBRACE tyrow_opt RBRACE
			( RECORDTy(I(LBRACEleft,RBRACEright), tyrow_opt) )
	(* [RFC: First-class modules] *)
	| PACK longsigid
			( PACKTy(I(PACKleft,longsigidright), longsigid) )
	| LPAR ty RPAR	( PARTy(I(LPARleft,RPARright), ty) )


  tyrow:
	  (* [RFC: Record extension] *)
	  DOTS COLON ty COMMA_tyrow_opt
			( DOTSTyRow(I(DOTSleft,COMMA_tyrow_optright),
				    ty, COMMA_tyrow_opt) )
	| lab COLON ty COMMA_tyrow_opt
			( FIELDTyRow(I(lableft,COMMA_tyrow_optright),
				     lab, ty, COMMA_tyrow_opt) )
     COMMA_tyrow_opt:
	  COMMA tyrow	( SOME tyrow )
	| (*empty*)	( NONE )

     tyrow_opt:
	  tyrow		( SOME tyrow )
	| (*empty*)	( NONE )



  (* Core: Sequences [Appendix B, 2nd bullet] *)

  tyseq:
	  consty			( Tyseq(I(constyleft,constyright),
						[consty]) )
	| (*empty*)			( Tyseq(I(defaultPos,defaultPos), []) )
	| LPAR ty_COMMA_list2 RPAR	( Tyseq(I(LPARleft,RPARright),
						ty_COMMA_list2) )

     ty_COMMA_list2:
	  ty COMMA ty_COMMA_list2	( ty::ty_COMMA_list2 )
	| ty COMMA ty			( [ty1, ty2] )


  tyvarseq:
	  tyvarseq1			( tyvarseq1 )
	| (*empty*)			( TyVarseq(I(defaultPos,defaultPos),
						   []) )
     tyvarseq1:
	  tyvar				( TyVarseq(I(tyvarleft,tyvarright),
						   [tyvar]) )
	| LPAR tyvar_COMMA_list1 RPAR	( TyVarseq(I(LPARleft,RPARright),
						   tyvar_COMMA_list1) )
     tyvar_COMMA_list1:
	  tyvar COMMA tyvar_COMMA_list1	( tyvar::tyvar_COMMA_list1 )
	| tyvar				( tyvar::[] )




  (* Modules: Structures [Figures 6, 23a and 23d; RFC: Higher-order functors
   *                                              RFC: Local modules] *)

  (* [RFC: Higher-order functors] *)
  atstrexp:
	(* [RFC: Local modules] *)
	  STRUCT pushInfix dec popInfix END
			( STRUCTStrExp(I(STRUCTleft,ENDright), dec) )
	(* [RFC: Higher-order functors; RFC: Local modules] *)
	| LPAR pushInfix dec popInfix RPAR
			( DECStrExp(I(LPARleft,RPARright), dec) )
	| longstrid	( IDStrExp(I(longstridleft,longstridright), longstrid) )
	(* [RFC: Local modules] *)
	| LET pushInfix dec IN strexp popInfix END
			( LETStrExp(I(LETleft,ENDright), dec, strexp) )
	(* [RFC: Higher-order functors] *)
	| LPAR strexp RPAR
			( PARStrExp(I(LPARleft,RPARright), strexp) )
  
  (* [RFC: Higher-order functors] *)
  appstrexp:
	  atstrexp	( atstrexp )
	(* [RFC: Higher-order functors] *)
	| appstrexp atstrexp
			( APPStrExp(I(appstrexpleft,atstrexpright),
				    appstrexp, atstrexp) )

  strexp:
	  appstrexp	( appstrexp )
	| strexp COLON sigexp
			( COLONStrExp(I(strexpleft,sigexpright),
				      strexp, sigexp) )
	| strexp SEAL sigexp
			( SEALStrExp(I(strexpleft,sigexpright), strexp, sigexp))
	(* [RFC: First-class modules] *)
	| UNPACK atexp COLON sigexp
			( UNPACKStrExp(I(UNPACKleft,sigexpright),
				       atexp, sigexp) )
	(* [RFC: Higher-order functors] *)
	| FCT strid COLON sigexp DARROW strexp
			( FCTStrExp(I(FCTleft,strexpright),
				    strid, sigexp, strexp) )
	(* [RFC: Higher-order functors] *)
	| FCT LPAR spec RPAR DARROW strexp
			( FCTSPECStrExp(I(FCTleft,strexpright), spec, strexp) )

  strdec:
	  STRUCTURE strbind
			( STRUCTUREStrDec(I(STRUCTUREleft,strbindright),
					  strbind) )
	(* [RFC: Higher-order functors] *)
	| FUNCTOR funbind
			( FUNCTORStrDec(I(FUNCTORleft,funbindright), funbind) )
	(* [RFC: Nested signatures] *)
	| SIGNATURE sigbind
			( SIGNATUREStrDec(I(SIGNATUREleft,sigbindright),
					  sigbind) )
	(* Removed local [RFC: Local modules] *)
	(* Removed empty [RFC: Local modules] *)
	(* Removed sequencing [RFC: Local modules] *)


  strbind:
	  strid COLON_sigexp_opt EQUALS strexp AND_strbind_opt
			( TRANSStrBind(I(stridleft,AND_strbind_optright),
				       strid, COLON_sigexp_opt, strexp,
				       AND_strbind_opt) )
	| strid SEAL sigexp EQUALS strexp AND_strbind_opt
			( SEALStrBind(I(stridleft,AND_strbind_optright),
				      strid, sigexp, strexp, AND_strbind_opt) )
     AND_strbind_opt:
	  AND strbind	( SOME strbind )
	| (*empty*)	( NONE )

     COLON_sigexp_opt:
	  COLON sigexp	( SOME sigexp )
	| (*empty*)	( NONE )



  (* Modules: Signatures [Figures 6 and 23b; RFC: Higher-order functors] *)

  (* [RFC: Higher-order functors] *)
  atsigexp:
	  SIG spec END	( SIGSigExp(I(SIGleft,ENDright), spec) )
	(* [RFC: Higher-order functors] *)
	| LPAR spec RPAR
			( SPECSigExp(I(LPARleft,RPARright), spec) )
	(* [RFC: Nested signatures] *)
	| longsigid	( IDSigExp(I(longsigidleft,longsigidright), longsigid) )
	(* [RFC: Higher-order functors] *)
	| LPAR sigexp RPAR
			( PARSigExp(I(LPARleft,RPARright), sigexp) )

  sigexp:
	  atsigexp	( atsigexp )
	(* [RFC: Abolish sequenced type realisations] *)
	| sigexp WHERE TYPE tyvarseq longtycon EQUALS ty
			( WHERETYPESigExp(I(sigexpleft,tyright),
					  sigexp, tyvarseq, longtycon, ty) )
	(* [RFC: Higher-order functors] *)
	| FCT strid COLON atsigexp ARROW sigexp
			( FCTSigExp(I(FCTleft,sigexpright),
				    strid, atsigexp, sigexp) )
	(* [RFC: Higher-order functors] *)
	| FCT LPAR spec RPAR ARROW sigexp
			( FCTSPECSigExp(I(FCTleft,sigexpright), spec, sigexp) )
	(* [RFC: Higher-order functors] *)
	| atsigexp ARROW sigexp
			( ARROWSigExp(I(atsigexpleft,sigexpright),
				      atsigexp, sigexp) )

  (* Removed sigdec [RFC: Nested signatures] *)

  sigbind:
	  sigid EQUALS sigexp AND_sigbind_opt
			( SigBind(I(sigidleft,AND_sigbind_optright),
				  sigid, sigexp, AND_sigbind_opt) )

     AND_sigbind_opt:
	  AND sigbind	( SOME sigbind )
	| (*empty*)	( NONE )



  (* Modules: Specifications [Figures 7 and 23c; RFC: Higher-order functors] *)

  spec:
	  spec1		( spec1 )
	| (*empty*)	( EMPTYSpec(I(defaultPos,defaultPos)) )

     spec1:
	  spec1''	( spec1'' )
	| spec1 spec1' %prec SEMICOLON
			( SEQSpec(I(spec1left,spec1'right), spec1, spec1') )
	| SEMICOLON	( SEQSpec(I(SEMICOLONleft,SEMICOLONright),
				 EMPTYSpec(I(SEMICOLONleft,SEMICOLONleft)),
				 EMPTYSpec(I(SEMICOLONright,SEMICOLONright))) )
	| SHARING TYPE longtycon_EQUALS_list2
			( SHARINGTYPESpec(I(SHARINGleft,
					    longtycon_EQUALS_list2right),
					  EMPTYSpec(I(SHARINGleft,SHARINGleft)),
					  longtycon_EQUALS_list2) )
	| spec1 SHARING TYPE longtycon_EQUALS_list2
			( SHARINGTYPESpec(I(spec1left,
					    longtycon_EQUALS_list2right),
					  spec1, longtycon_EQUALS_list2) )
	| SHARING longstrid_EQUALS_list2
			( SHARINGSpec(I(SHARINGleft,
					longstrid_EQUALS_list2right),
				      EMPTYSpec(I(SHARINGleft,SHARINGleft)),
				      longstrid_EQUALS_list2) )
	| spec1 SHARING longstrid_EQUALS_list2
			( SHARINGSpec(I(spec1left,longstrid_EQUALS_list2right),
				      spec1, longstrid_EQUALS_list2) )

     spec1':
	  spec1''	( spec1'' )
	| spec1' spec1' %prec SEMICOLON
			( SEQSpec(I(spec1'1left,spec1'2right),
				  spec1'1, spec1'2) )
	| SEMICOLON	( SEQSpec(I(SEMICOLONleft,SEMICOLONright),
				 EMPTYSpec(I(SEMICOLONleft,SEMICOLONleft)),
				 EMPTYSpec(I(SEMICOLONright,SEMICOLONright))) )

     spec1'':
	  VAL valdesc	( VALSpec(I(VALleft,valdescright), valdesc) )
	| TYPE typdesc	( TYPESpec(I(TYPEleft,typdescright), typdesc) )
	| EQTYPE typdesc
	  		( EQTYPESpec(I(EQTYPEleft,typdescright), typdesc) )
	| TYPE syndesc
			( SYNSpec(I(TYPEleft,syndescright), syndesc) )
	(* [RFC: Withtype in signatures] *)
	| DATATYPE datdesc0 WITHTYPE_typbind_opt
			( DATATYPESpec(I(DATATYPEleft,
					 WITHTYPE_typbind_optright),
				       datdesc0, WITHTYPE_typbind_opt) )
	| DATATYPE datdesc1 WITHTYPE_typbind_opt
			( DATATYPESpec(I(DATATYPEleft,
					 WITHTYPE_typbind_optright),
				       datdesc1, WITHTYPE_typbind_opt) )
	| DATATYPE tycon EQUALS DATATYPE longtycon
			( DATATYPE2Spec(I(DATATYPEleft,longtyconright),
					tycon, longtycon) )
	(* [RFC: Views] *)
	| VIEWTYPE tycon EQUALS ty AS BAR_opt condesc
			( VIEWTYPESpec(I(VIEWTYPEleft,condescright),
				       TyVarseq(I(defaultPos,defaultPos), []),
				       tycon, ty, condesc) )
	(* [RFC: Views] *)
	| VIEWTYPE tyvarseq1 tycon EQUALS ty AS BAR_opt condesc
			( VIEWTYPESpec(I(VIEWTYPEleft,condescright),
				       tyvarseq1, tycon, ty, condesc) )
	(* [RFC: Views] *)
	| VIEWTYPE tycon EQUALS VIEWTYPE longtycon
			( VIEWTYPE2Spec(I(VIEWTYPEleft,longtyconright),
					tycon, longtycon) )
	| EXCEPTION exdesc
			( EXCEPTIONSpec(I(EXCEPTIONleft,exdescright), exdesc) )
	| STRUCTURE strdesc
			( STRUCTURESpec(I(STRUCTUREleft,strdescright), strdesc))
	(* [RFC: Higher-order functors] *)
	| FUNCTOR fundesc
			( FUNCTORSpec(I(FUNCTORleft,fundescright), fundesc))
	(* [RFC: Nested signatures] *)
	| SIGNATURE sigdesc
			( SIGNATURESpec(I(SIGNATUREleft,sigdescright), sigdesc))
	| INCLUDE sigexp
			( INCLUDESpec(I(INCLUDEleft,sigexpright), sigexp) )
	(* [RFC: Nested signatures] *)
	| INCLUDE longsigid_list2
			( INCLUDEMULTISpec(I(INCLUDEleft,longsigid_list2right),
					   longsigid_list2) )

     longsigid_list2:
	  longsigid longsigid_list2	( longsigid::longsigid_list2 )
	| longsigid longsigid		( longsigid1::longsigid2::[] )

     longtycon_EQUALS_list1:
	  longtycon EQUALS longtycon_EQUALS_list1
				( longtycon::longtycon_EQUALS_list1 )
	| longtycon		( longtycon::[] )

     longtycon_EQUALS_list2:
	  longtycon EQUALS longtycon_EQUALS_list1
				( longtycon::longtycon_EQUALS_list1 )
     longstrid_EQUALS_list1:
	  longstrid EQUALS longstrid_EQUALS_list1
				( longstrid::longstrid_EQUALS_list1 )
	| longstrid		( longstrid::[] )

     longstrid_EQUALS_list2:
	  longstrid EQUALS longstrid_EQUALS_list1
				( longstrid::longstrid_EQUALS_list1 )


  (* Modules: Descriptions [Figures 7 and 23c; RFC: Higher-order functors] *)

  valdesc:
	  vid' COLON ty AND_valdesc_opt
	  		( ValDesc(I(vid'left,AND_valdesc_optright),
				  vid', ty, AND_valdesc_opt) )
     AND_valdesc_opt:
	  AND valdesc	( SOME valdesc )
	| (*empty*)	( NONE )

  typdesc:
	  tyvarseq tycon AND_typdesc_opt
			( TypDesc(I(tyvarseqleft,AND_typdesc_optright),
				  tyvarseq, tycon, AND_typdesc_opt) )
     AND_typdesc_opt:
	  AND typdesc	( SOME typdesc )
	| (*empty*)	( NONE )

  syndesc:
	  tyvarseq tycon EQUALS ty AND_syndesc_opt
			( SynDesc(I(tyvarseqleft,AND_syndesc_optright),
				  tyvarseq, tycon, ty, AND_syndesc_opt) )
     AND_syndesc_opt:
	  AND syndesc	( SOME syndesc )
	| (*empty*)	( NONE )

  datdesc:
	(* [RFC: Optional bars and semicolons] *)
	  tyvarseq tycon EQUALS BAR_opt condesc AND_datdesc_opt
	  		( DatDesc(I(tyvarseqleft,AND_datdesc_optright),
	  			  tyvarseq, tycon, condesc, AND_datdesc_opt) )
     datdesc0:
	(* [RFC: Optional bars and semicolons] *)
	  tycon EQUALS BAR_opt condesc AND_datdesc_opt
	  		( DatDesc(I(tyconleft,AND_datdesc_optright),
	  			  TyVarseq(I(defaultPos,defaultPos), []),
				  tycon, condesc, AND_datdesc_opt) )
     datdesc1:
	(* [RFC: Optional bars and semicolons] *)
	  tyvarseq1 tycon EQUALS BAR_opt condesc AND_datdesc_opt
	  		( DatDesc(I(tyvarseq1left,AND_datdesc_optright),
	  			  tyvarseq1, tycon, condesc, AND_datdesc_opt) )
     AND_datdesc_opt:
	  AND datdesc	( SOME datdesc )
	| (*empty*)	( NONE )

  condesc:
	  vid' OF_ty_opt BAR_condesc_opt
			( ConDesc(I(vid'left,BAR_condesc_optright),
				  vid', OF_ty_opt, BAR_condesc_opt) )
     BAR_condesc_opt:
	  BAR condesc	( SOME condesc )
	| (*empty*)	( NONE )

  exdesc:
	  vid' OF_ty_opt AND_exdesc_opt
	  		( ExDesc(I(vid'left,AND_exdesc_optright),
	  			 vid', OF_ty_opt, AND_exdesc_opt) )
     AND_exdesc_opt:
	  AND exdesc	( SOME exdesc )
	| (*empty*)	( NONE )

  strdesc:
	  strid COLON sigexp AND_strdesc_opt
	  		( StrDesc(I(stridleft,AND_strdesc_optright),
	  			  strid, sigexp, AND_strdesc_opt) )
     AND_strdesc_opt:
	  AND strdesc	( SOME strdesc )
	| (*empty*)	( NONE )

  (* [RFC: Higher-order functors] *)
  fundesc:
	  strid funarg_list1 COLON sigexp AND_fundesc_opt
	  		( FunDesc(I(stridleft,AND_fundesc_optright),
	  			  strid, funarg_list1, sigexp,
	  			  AND_fundesc_opt) )
     AND_fundesc_opt:
	  AND fundesc	( SOME fundesc )
	| (*empty*)	( NONE )

  (* [RFC: Higher-order functors] *)
  funarg:
	  strid COLON sigexp	( COLONFunArg(I(stridleft,sigexpright),
					      strid, sigexp) )
	| spec			( SPECFunArg(I(specleft,specright), spec) )

     funarg_list1:
	  LPAR funarg RPAR		( funarg::nil )
	| LPAR funarg RPAR funarg_list1	( funarg::funarg_list1 )

  (* [RFC: Nested signatures] *)
  sigdesc:
	  sigid EQUALS sigexp AND_sigdesc_opt
			( SigDesc(I(sigidleft,AND_sigdesc_optright),
				  sigid, sigexp, AND_sigdesc_opt) )
     AND_sigdesc_opt:
	  AND sigdesc	( SOME sigdesc )
	| (*empty*)	( NONE )

  (* Modules: Functors [Figures 8 and 23d; RFC: Higher-order functors] *)

  (* Removed fundec [RFC: Higher-order functors] *)

  funbind:
	(* [RFC: Higher-order functors] *)
	  strid funarg_list1 COLON_sigexp_opt EQUALS strexp
		AND_funbind_opt
			( TRANSFunBind(I(stridleft,AND_funbind_optright),
				       strid, funarg_list1, COLON_sigexp_opt,
				       strexp, AND_funbind_opt) )
	(* [RFC: Higher-order functors] *)
	| strid funarg_list1 SEAL sigexp EQUALS strexp
		AND_funbind_opt
			( SEALFunBind(I(stridleft,AND_funbind_optright),
				      strid, funarg_list1, sigexp, strexp,
				      AND_funbind_opt) )
     AND_funbind_opt:
	  AND funbind	( SOME funbind )
	| (*empty*)	( NONE )



  (* Modules: Top-level Declarations [Figure 8 and 23d;
   *                                  RFC: Higher-order functors] *)

  topdec:
	(* [RFC: Nested signatures; RFC: Local modules] *)
	  dec'		( TopDec(I(dec'left,dec'right), dec') )
	(* Removed sigdec [RFC: Nested signatures] *)
	(* Removed fundec [RFC: Higher-order functors] *)



  (* Programs [Section 8 and Figure 18] *)

  program:
	  initInfix program'	( (program', !J) )

     program':
	  topdec SEMICOLON program_opt
	  		( TOPDECProgram(I(topdecleft,SEMICOLONright),
					topdec, program_opt) )
	| exp SEMICOLON program_opt
	  		( EXPProgram(I(expleft,SEMICOLONright),
				     exp, program_opt) )
     program_opt:
	  program'	( SOME program' )
	| (*empty*)	( NONE )
