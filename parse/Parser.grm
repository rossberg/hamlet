(*
 * (c) Andreas Rossberg 1999-2025
 *
 * Standard ML syntactical analysis
 *
 * Definition, Sections 2, 3, and 8, Appendix A and B
 *
 * Notes:
 * - Two phrases named Fmatch and Fmrule have been added to factorize Fvalbind.
 * - A phrase named SynDesc has been added to factorize type synonym
 *   specifications. Similarly, a phrase named TyReaDesc has been added to
 *   factorize type realisation signature expressions.
 * - Infix expressions [Definition, Section 2.6] are resolved externally in
 *   structure Infix. The parser just maintains the infix environment J by
 *   side effect. To achieve correct treatment of scoped fixity directives,
 *   a stack of environments is used. To handle `local' we even need a
 *   second environment J' (together with a a second stack).
 * - Syntactic restrictions [Definition, Sections 2.9 and 3.5] are checked
 *   in a separate pass (structures SyntacticRestrictions* ).
 * - Although not completely clear from the wording we assume that the
 *   Definition rules out the use of `=' as a tycon. Otherwise we would have
 *   a massive amount of grammar conflicts.
 * - The Definition is also vague about what consists a non-infixed occurrence
 *   of an infix identifier: we assume any occurrences in expressions
 *   or patterns. This implies that uses of the keyword `op' in constructor
 *   and exception bindings are completely redundant.
 * - Datatype replication requires rules for datatype to be duplicated to
 *   avoid conflicts on empty tyvarseqs.
 * - Layered patterns require some grammar transformation hack, see pat.
 * - The messy `sigexp where type ... and type ...' syntax requires some
 *   really ugly transformations (in absence of a lookahead of 2), watch out
 *   for non-terminals of the form xxx__AND_yyybind_opt.
 *
 * Bugs:
 * - We do NOT support declarations like
 *     fun f p1 = case e1 of p2 => e2
 *       | f p3 = e3
 *   (without parentheses around the case) because the transformations
 *   required to support this would be even a magnitude uglier than those
 *   above. In fact, no known compiler supports this.
 *)


  (* Import *)

  structure A = Annotation

  open SyntaxCore
  open SyntaxModule
  open SyntaxProgram
  open DerivedFormsCore
  open DerivedFormsModule
  open DerivedFormsProgram


  (* Building annotations *)

  fun x@@loc = A.@@(x, A.fromLoc loc)


  (* Handling infix environments *)

  val J  = ref Infix.empty	(* context *)
  val J' = ref Infix.empty	(* local environment (+ enclosing one) *)

  val stackJ  = ref [] : Infix.InfEnv list ref
  val stackJ' = ref [] : Infix.InfEnv list ref

  fun initJandJ'(J0) = ( J := J0; J' := J0; stackJ := []; stackJ' := [] )
  fun pushJ() = stackJ := !J :: !stackJ
  fun popJ() = ( J := List.hd(!stackJ); stackJ := List.tl(!stackJ) )
  fun pushJ'shiftJ() = ( stackJ' := !J' :: !stackJ'; J' := List.hd(!stackJ) )
  fun popJandJ'() =
      ( J  := !J';
	J' := List.hd(!stackJ');
	stackJ  := List.tl(!stackJ);
	stackJ' := List.tl(!stackJ')
      )

  fun assignInfix(infstatus, vids) =
      let
	val vids' = List.map A.syntax vids
      in
	J  := Infix.assign(!J, vids', infstatus);
	J' := Infix.assign(!J', vids', infstatus)
      end

  fun cancelInfix(vids) =
      let
	val vids' = List.map A.syntax vids
      in
	J  := Infix.cancel(!J, vids');
	J' := Infix.cancel(!J', vids')
      end


  (* Helper for long identifiers *)

  fun toLongId toId (strids, id) = (List.map StrId.fromString strids, toId id)


  (* Helper to handle typed patterns (needed for layered patterns) *)

  fun typedPat(pat, []) = pat
    | typedPat(pat, ty::tys) =
      let open A in typedPat(COLONPat(pat, ty)@@over(pat, ty), tys) end

%%

%header (functor LrValsFn(structure Token : TOKEN))
%name Parser

%pos Source.pos
%arg (A, J0) : (Source.region -> Source.loc) * Infix.InfEnv

%verbose


%term
  (* End of file *)
    EOF

  (* Reserved words for the core language [Section 2.1] *)
  | ABSTYPE | AND | ANDALSO | AS | CASE | DO | DATATYPE | ELSE | END | EXCEPTION
  | FN | FUN | HANDLE | IF | IN | INFIX | INFIXR | LET | LOCAL | NONFIX
  | OF | OP | OPEN | ORELSE | RAISE | REC | THEN | TYPE | VAL
  | WITH | WITHTYPE | WHILE
  | LPAR | RPAR | LBRACK | RBRACK | LBRACE | RBRACE | COMMA | COLON | SEMICOLON
  | DOTS | UNDERBAR | BAR | EQUALS | DARROW | ARROW | HASH

  (* Additional reserved words for the modules language [Section 3.1] *)
  | EQTYPE | FUNCTOR | INCLUDE | SHARING | SIG | SIGNATURE | STRUCT | STRUCTURE
  | WHERE | SEAL

  (* Special constants [Section 2.2] *)
  | ZERO | DIGIT of string | NUMERIC of string
  | INT of string | HEXINT of string | WORD of string | HEXWORD of string
  | REAL of string | STRING of string | CHAR of string

  (* Identifiers [Section 2.4] *)
  | ALPHA of string | SYMBOL of string | STAR
  | TYVAR of string | ETYVAR of string
  | LONGID of string list * string

%keyword
  ABSTYPE AND ANDALSO AS CASE DO DATATYPE ELSE
  END EXCEPTION FN FUN HANDLE IF IN INFIX
  INFIXR LET LOCAL NONFIX OF OP OPEN ORELSE
  RAISE REC THEN TYPE VAL WITH WITHTYPE WHILE
  EQTYPE FUNCTOR INCLUDE SHARING SIG
  SIGNATURE STRUCT STRUCTURE WHERE

%eop     EOF
%noshift EOF


%left  SHARING
%right SEMICOLON
%right VAL FUN TYPE EQTYPE DATATYPE ABSTYPE EXCEPTION
       STRUCTURE SIGNATURE FUNCTOR
%right LOCAL OPEN INFIX INFIXR NONFIX INCLUDE
%right AND
%left  DARROW		(* L/R is arbitrary *)
%left  BAR		(* L/R is arbitrary *)
%left  DO		(* L/R is arbitrary *)
%left  ELSE		(* L/R is arbitrary *)
%left  RAISE		(* L/R is arbitrary *)
%right HANDLE
%right ORELSE
%right ANDALSO
%right AS
%left  COLON
%right ARROW


%start program

%nonterm
  (* Constants *)
    scon				 of SCon
  | d					 of int

  (* Identifiers and labels *)
  | lab					 of Lab
  | vid					 of VId
  |   vid'				 of VId  (* excludes `=' *)
  | tycon				 of TyCon
  | tyvar				 of TyVar
  | strid				 of StrId
  | sigid				 of SigId
  | funid				 of FunId

  | longvid				 of longVId
  |   longvid'				 of longVId  (* excludes `=' *)
  | longtycon				 of longTyCon
  | longstrid				 of longStrId

  | OP_opt				 of Op option

  (* Nonterminals for core grammar *)
  | atexp				 of AtExp
  |   exp_COMMA_list0			 of Exp list
  |   exp_COMMA_list1			 of Exp list
  |   exp_COMMA_list2			 of Exp list
  |   exp_SEMICOLON_list1		 of Exp list
  |   exp_SEMICOLON_list2		 of Exp list
  | exprow				 of ExpRow
  |   exprow_opt			 of ExpRow option
  |   COMMA_exprow_opt			 of ExpRow option
  | appexp				 of AppExp
  | infexp				 of InfExp
  | exp					 of Exp

  | match				 of Match
  |   BAR_match_opt			 of Match option
  | mrule				 of Mrule

  | dec					 of Dec
  |   dec1				 of Dec
  |   dec1'				 of Dec (* excludes local and seq. *)
  |   WITHTYPE_typbind_opt		 of TypBind option
  |   vid_list1				 of VId list
  |   longstrid_list1			 of longStrId list
  |   d_opt				 of int
  | valbind				 of ValBind
  |   AND_valbind_opt			 of ValBind option
  | fvalbind				 of FvalBind
  |   AND_fvalbind_opt			 of FvalBind option
  | fmatch				 of Fmatch
  |   BAR_fmatch_opt			 of Fmatch option
  | fmrule				 of Fmrule
  | typbind				 of TypBind
  |   AND_typbind_opt			 of TypBind option
  | datbind				 of DatBind
  |   datbind0				 of DatBind
  |   datbind1				 of DatBind
  |   AND_datbind_opt			 of DatBind option
  | conbind				 of ConBind
  |   BAR_conbind_opt			 of ConBind option
  |   OF_ty_opt				 of Ty option
  | exbind				 of ExBind
  |   AND_exbind_opt			 of ExBind option

  | atpat				 of AtPat
  |   atpat'				 of AtPat (* excludes <op>longvid *)
  |   pat_COMMA_list0			 of Pat list
  |   pat_COMMA_list1			 of Pat list
  |   pat_COMMA_list2			 of Pat list
  | patrow				 of PatRow
  |   patrow_opt			 of PatRow option
  |   COMMA_patrow_opt			 of PatRow option
  |   COLON_ty_opt			 of Ty option
  |   AS_pat_opt			 of Pat option
  | pat					 of Pat
  |   atpat_list1			 of AtPat list
  |   atpat_list2			 of AtPat list
  |   COLON_ty_list1			 of Ty list

  | ty					 of Ty
  |   tupty				 of Ty
  |   ty_STAR_list			 of Ty list
  |   consty				 of Ty
  |   atty				 of Ty
  | tyrow				 of TyRow
  |   tyrow_opt				 of TyRow option
  |   COMMA_tyrow_opt			 of TyRow option
  | tyseq				 of Ty seq
  |   ty_COMMA_list2			 of Ty list
  | tyvarseq				 of TyVar seq
  |   tyvarseq1				 of TyVar seq
  |   tyvar_COMMA_list1			 of TyVar list

  (* Nonterminals for the module language *)
  | strexp				 of StrExp
  |   strexp'				 of StrExp (* excludes constraints *)
  | strdec				 of StrDec
  |   strdec1				 of StrDec
  |   strdec1'				 of StrDec (* excludes sequencing *)
  | strbind				 of StrBind
  |   AND_strbind_opt			 of StrBind option
  |   strexp__AND_strbind_opt		 of StrExp * StrBind option
  |   sigexp__AND_strbind_opt		 of SigExp * StrBind option
  |   tyreadesc__AND_strbind_opt	 of TyReaDesc * StrBind option
  |   AND_tyreadesc_opt__AND_strbind_opt of TyReaDesc option * StrBind option

  | sigexp				 of SigExp
  |   sigexp'				 of SigExp (* excludes where *)
  | sigdec				 of SigDec
  | sigbind				 of SigBind
  |   AND_sigbind_opt			 of SigBind option
  |   sigexp__AND_sigbind_opt		 of SigExp * SigBind option
  |   tyreadesc__AND_sigbind_opt	 of TyReaDesc * SigBind option
  |   AND_tyreadesc_opt__AND_sigbind_opt of TyReaDesc option * SigBind option
  | tyreadesc				 of TyReaDesc
  |   AND_tyreadesc_opt			 of TyReaDesc option

  | spec				 of Spec
  |   spec1				 of Spec
  |   spec1'				 of Spec (* excludes sharing *)
  |   spec1''				 of Spec (* excludes sharing and seq. *)
  |   sigid_list2			 of SigId list
  |   longtycon_EQUALS_list1		 of longTyCon list
  |   longtycon_EQUALS_list2		 of longTyCon list
  |   longstrid_EQUALS_list1		 of longStrId list
  |   longstrid_EQUALS_list2		 of longStrId list

  | valdesc				 of ValDesc
  |   AND_valdesc_opt			 of ValDesc option
  | typdesc				 of TypDesc
  |   AND_typdesc_opt			 of TypDesc option
  | syndesc				 of SynDesc
  |   AND_syndesc_opt			 of SynDesc option
  | datdesc				 of DatDesc
  |   datdesc0				 of DatDesc
  |   datdesc1				 of DatDesc
  |   AND_datdesc_opt			 of DatDesc option
  | condesc				 of ConDesc
  |   BAR_condesc_opt			 of ConDesc option
  | exdesc				 of ExDesc
  |   AND_exdesc_opt			 of ExDesc option
  | strdesc				 of StrDesc
  |   AND_strdesc_opt			 of StrDesc option
  |   sigexp__AND_strdesc_opt		 of SigExp * StrDesc option
  |   tyreadesc__AND_strdesc_opt	 of TyReaDesc * StrDesc option
  |   AND_tyreadesc_opt__AND_strdesc_opt of TyReaDesc option * StrDesc option

  | fundec				 of FunDec
  | funbind				 of FunBind
  |   AND_funbind_opt			 of FunBind option
  |   strexp__AND_funbind_opt		 of StrExp * FunBind option
  |   sigexp__AND_funbind_opt		 of SigExp * FunBind option
  |   tyreadesc__AND_funbind_opt	 of TyReaDesc * FunBind option
  |   AND_tyreadesc_opt__AND_funbind_opt of TyReaDesc option * FunBind option
  | topdec				 of TopDec
  |   topdec1				 of TopDec
  |   topdec_opt			 of TopDec option

  (* Top nonterminal *)
  | program				 of Program * Infix.InfEnv
  |   program'				 of Program
  |   program_opt			 of Program option

  (* Pseudo symbols to handle infix environment *)
  | initInfix				 of unit
  | pushInfix				 of unit
  | popInfix				 of unit
  | pushLocalInfix			 of unit
  | popLocalInfix			 of unit

%%

  (* Handling of infix environment *)

  initInfix:	  ( initJandJ'(J0) )
  pushInfix:	  ( pushJ() )
  popInfix:	  ( popJ() )
  pushLocalInfix: ( pushJ'shiftJ() )
  popLocalInfix:  ( popJandJ'() )


  (* Special constants [Section 2.2] *)

  scon:
      ZERO	( SCon.INT(SCon.DEC, "0")@@A(ZEROleft, ZEROright) )
    | DIGIT	( SCon.INT(SCon.DEC, DIGIT)@@A(DIGITleft, DIGITright) )
    | NUMERIC	( SCon.INT(SCon.DEC, NUMERIC)@@A(NUMERICleft, NUMERICright) )
    | INT	( SCon.INT(SCon.DEC, INT)@@A(INTleft, INTright) )
    | HEXINT	( SCon.INT(SCon.HEX, HEXINT)@@A(HEXINTleft, HEXINTright) )
    | WORD	( SCon.WORD(SCon.DEC, WORD)@@A(WORDleft, WORDright) )
    | HEXWORD	( SCon.WORD(SCon.HEX, HEXWORD)@@A(HEXWORDleft, HEXWORDright) )
    | REAL	( SCon.REAL(REAL)@@A(REALleft, REALright) )
    | STRING	( SCon.STRING(STRING)@@A(STRINGleft, STRINGright) )
    | CHAR	( SCon.CHAR(CHAR)@@A(CHARleft, CHARright) )

  d:
      ZERO	( 0 )
    | DIGIT	( Option.valOf(Int.fromString DIGIT) )


  (* Identifiers [Section 2.4] *)

  lab:
      ALPHA	( Lab.fromString(ALPHA)@@A(ALPHAleft, ALPHAright) )
    | SYMBOL	( Lab.fromString(SYMBOL)@@A(SYMBOLleft, SYMBOLright) )
    | STAR	( Lab.fromString("*")@@A(STARleft, STARright) )
    | DIGIT	( Lab.fromString(DIGIT)@@A(DIGITleft, DIGITright) )
    | NUMERIC	( Lab.fromString(NUMERIC)@@A(NUMERICleft, NUMERICright) )

  vid:
      vid'	( vid' )
    | EQUALS	( VId.fromString("=")@@A(EQUALSleft, EQUALSright) )

  vid':
      ALPHA	( VId.fromString(ALPHA)@@A(ALPHAleft, ALPHAright) )
    | SYMBOL	( VId.fromString(SYMBOL)@@A(SYMBOLleft, SYMBOLright) )
    | STAR	( VId.fromString("*")@@A(STARleft, STARright) )

  tycon:
      ALPHA	( TyCon.fromString(ALPHA)@@A(ALPHAleft, ALPHAright) )
    | SYMBOL	( TyCon.fromString(SYMBOL)@@A(SYMBOLleft, SYMBOLright) )

  tyvar:
      TYVAR	( TyVar.fromString(TYVAR)@@A(TYVARleft, TYVARright) )

  strid:
      ALPHA	( StrId.fromString(ALPHA)@@A(ALPHAleft, ALPHAright) )

  sigid:
      ALPHA	( SigId.fromString(ALPHA)@@A(ALPHAleft, ALPHAright) )

  funid:
      ALPHA	( FunId.fromString(ALPHA)@@A(ALPHAleft, ALPHAright) )


  longvid:
      longvid'	( longvid' )
    | EQUALS	( LongVId.fromId(VId.fromString "=")
                    @@A(EQUALSleft, EQUALSright) )
  longvid':
      vid'	( LongVId.fromId(A.syntax vid')@@A(vid'left, vid'right) )
    | LONGID	( LongVId.implode(toLongId VId.fromString LONGID)
	            @@A(LONGIDleft, LONGIDright) )

  longtycon:
      tycon	( LongTyCon.fromId(A.syntax tycon)@@A(tyconleft, tyconright) )
    | LONGID	( LongTyCon.implode(toLongId TyCon.fromString LONGID)
	            @@A(LONGIDleft, LONGIDright) )

  longstrid:
      strid	( LongStrId.fromId(A.syntax strid)@@A(stridleft, stridright) )
    | LONGID	( LongStrId.implode(toLongId StrId.fromString LONGID)
	            @@A(LONGIDleft, LONGIDright) )

  OP_opt:
      OP           ( SOME Op )
    | (* empty *)  ( NONE )


  (* Core: Expressions [Figure 20] *)

  atexp:
      scon
        ( SCONAtExp(scon)@@A(sconleft, sconright) )
    | OP_opt longvid
	( IDAtExp(OP_opt, longvid)@@A(OP_optleft, longvidright) )
    | LBRACE exprow_opt RBRACE
	( RECORDAtExp(exprow_opt)@@A(LBRACEleft, RBRACEright) )
    | HASH lab
	( HASHAtExp(lab)@@A(HASHleft, labright) )
    | LPAR RPAR
	( UNITAtExp@@A(LPARleft, RPARright) )
    | LPAR exp_COMMA_list2 RPAR
	( TUPLEAtExp(exp_COMMA_list2)@@A(LPARleft, RPARright) )
    | LBRACK exp_COMMA_list0 RBRACK
	( LISTAtExp(exp_COMMA_list0)@@A(LBRACKleft, RBRACKright) )
    | LPAR exp_SEMICOLON_list2 RPAR
	( SEQAtExp(exp_SEMICOLON_list2)@@A(LPARleft, RPARright) )
    | LET pushInfix dec IN exp_SEMICOLON_list1 popInfix END
	( LETSEQAtExp(dec, exp_SEMICOLON_list1)@@A(LETleft, ENDright) )
    | LPAR exp RPAR
	( PARAtExp(exp)@@A(LPARleft, RPARright) )

  exp_COMMA_list0:
      exp_COMMA_list1			( exp_COMMA_list1 )
    | (* empty *)			( [] )

  exp_COMMA_list1:
      exp COMMA exp_COMMA_list1		( exp::exp_COMMA_list1 )
    | exp				( exp::[] )

  exp_COMMA_list2:
      exp COMMA exp_COMMA_list1		( exp::exp_COMMA_list1 )

  exp_SEMICOLON_list1:
      exp SEMICOLON exp_SEMICOLON_list1	( exp::exp_SEMICOLON_list1 )
    | exp				( exp::[] )

  exp_SEMICOLON_list2:
      exp SEMICOLON exp_SEMICOLON_list2	( exp::exp_SEMICOLON_list2 )
    | exp SEMICOLON exp			( [exp1, exp2] )


  exprow:
      lab EQUALS exp COMMA_exprow_opt
	( ExpRow(lab, exp, COMMA_exprow_opt)@@A(lableft, COMMA_exprow_optright))

  COMMA_exprow_opt:
      COMMA exprow  ( SOME exprow )
    | (* empty *)   ( NONE )

  exprow_opt:
      exprow	    ( SOME exprow )
    | (* empty *)   ( NONE )

  appexp:
      atexp         ( atexp::[] )
    | appexp atexp  ( atexp::appexp )


  infexp:
      appexp	         ( Infix.parseExp(!J, List.rev appexp) )
    (*infexp vid infexp	 ( included above... ) *)


  exp:
      infexp
        ( infexp )
    | exp COLON ty
        ( COLONExp(exp, ty)@@A(expleft, tyright) )
    | exp ANDALSO exp
        ( ANDALSOExp(exp1, exp2)@@A(exp1left, exp2right) )
    | exp ORELSE exp
        ( ORELSEExp(exp1, exp2)@@A(exp1left, exp2right) )
    | exp HANDLE match
        ( HANDLEExp(exp, match)@@A(expleft, matchright) )
    | RAISE exp
        ( RAISEExp(exp)@@A(RAISEleft, expright) )
    | IF exp THEN exp ELSE exp
 	( IFExp(exp1, exp2, exp3)@@A(IFleft, exp3right) )
    | WHILE exp DO exp
        ( WHILEExp(exp1, exp2)@@A(WHILEleft, exp2right) )
    | CASE exp OF match
        ( CASEExp(exp, match)@@A(CASEleft, matchright) )
    | FN match
        ( FNExp(match)@@A(FNleft, matchright) )


  (* Core: Matches [Figure 20] *)

  match:
      mrule BAR_match_opt
        ( Match(mrule, BAR_match_opt)@@A(mruleleft, BAR_match_optright) )

  BAR_match_opt:
      BAR match			( SOME match )
    | (* empty *) %prec DARROW	( NONE )

  mrule:
      pat DARROW exp
        ( Mrule(pat, exp)@@A(patleft, expright) )



  (* Core: Declarations [Figure 21] *)

  dec:
      dec1         ( dec1 )
    | (* empty *)  ( EMPTYDec@@A(defaultPos, defaultPos) )

  dec1:
      dec1'
	( dec1' )
    | LOCAL pushInfix dec IN pushLocalInfix dec popLocalInfix END
	( LOCALDec(dec1, dec2)@@A(LOCALleft, ENDright) )
    | dec1 dec1 %prec SEMICOLON
	( SEQDec(dec11, dec12)@@A(dec11left, dec12right) )
    | SEMICOLON
	( SEQDec(
	    EMPTYDec@@A(SEMICOLONleft, SEMICOLONleft),
	    EMPTYDec@@A(SEMICOLONright, SEMICOLONright)
	  )@@A(SEMICOLONleft, SEMICOLONright) )

  dec1':
      VAL valbind
	( VALDec(Seq[]@@A(defaultPos, defaultPos), valbind)
	    @@A(VALleft, valbindright) )
    | VAL tyvarseq1 valbind
	( VALDec(tyvarseq1, valbind)@@A(VALleft, valbindright) )
    | FUN fvalbind
	( FUNDec(Seq[]@@A(defaultPos, defaultPos), fvalbind)
	    @@A(FUNleft, fvalbindright) )
    | FUN tyvarseq1 fvalbind
	( FUNDec(tyvarseq1, fvalbind)@@A(FUNleft, fvalbindright) )
    | TYPE typbind
	( TYPEDec(typbind)@@A(TYPEleft, typbindright) )
    | DATATYPE datbind0 WITHTYPE_typbind_opt
	( DATATYPEWITHTYPEDec(datbind0, WITHTYPE_typbind_opt)
	    @@A(DATATYPEleft, WITHTYPE_typbind_optright) )
    | DATATYPE datbind1 WITHTYPE_typbind_opt
	( DATATYPEWITHTYPEDec(datbind1, WITHTYPE_typbind_opt)
	    @@A(DATATYPEleft, WITHTYPE_typbind_optright) )
    | DATATYPE tycon EQUALS DATATYPE longtycon
	( DATATYPE2Dec(tycon, longtycon)@@A(DATATYPEleft, longtyconright) )
    | ABSTYPE datbind WITHTYPE_typbind_opt WITH dec END
	( ABSTYPEWITHTYPEDec(datbind, WITHTYPE_typbind_opt, dec)
	    @@A(ABSTYPEleft, ENDright) )
    | EXCEPTION exbind
	( EXCEPTIONDec(exbind)@@A(EXCEPTIONleft, exbindright) )
    | OPEN longstrid_list1
	( OPENDec(longstrid_list1)@@A(OPENleft, longstrid_list1right) )
    | INFIX d_opt vid_list1
	( assignInfix((Infix.LEFT, d_opt), vid_list1);
	  EMPTYDec@@A(INFIXleft, vid_list1right) )
    | INFIXR d_opt vid_list1
	( assignInfix((Infix.RIGHT, d_opt), vid_list1);
	  EMPTYDec@@A(INFIXRleft, vid_list1right) )
    | NONFIX vid_list1
	( cancelInfix(vid_list1);
	  EMPTYDec@@A(NONFIXleft, vid_list1right) )

  WITHTYPE_typbind_opt:
      WITHTYPE typbind	( SOME typbind )
    | (* empty *)	( NONE )

  vid_list1:
      vid vid_list1  ( vid::vid_list1 )
    | vid	     ( vid::[] )

  longstrid_list1:
      longstrid longstrid_list1	 ( longstrid::longstrid_list1 )
    | longstrid			 ( longstrid::[] )

  d_opt:
      d		   ( d )
    | (* empty *)  ( 0 )



  (* Core: Bindings [Figure 21] *)

  valbind:
      pat EQUALS exp AND_valbind_opt
	( PLAINValBind(pat, exp, AND_valbind_opt)
	    @@A(patleft, AND_valbind_optright) )
    | REC valbind
	( RECValBind(valbind)@@A(RECleft, valbindright) )

  AND_valbind_opt:
      AND valbind  ( SOME valbind )
    | (* empty *)  ( NONE )


  fvalbind:
      fmatch AND_fvalbind_opt
	( FvalBind(fmatch, AND_fvalbind_opt)
	    @@A(fmatchleft, AND_fvalbind_optright) )

  AND_fvalbind_opt:
      AND fvalbind  ( SOME fvalbind )
    | (* empty *)   ( NONE )

  fmatch:
      fmrule BAR_fmatch_opt
	( Fmatch(fmrule, BAR_fmatch_opt)@@A(fmruleleft, BAR_fmatch_optright) )

  BAR_fmatch_opt:
      BAR fmatch   ( SOME fmatch )
    | (* empty *)  ( NONE )

  fmrule:
      atpat_list1 COLON_ty_opt EQUALS exp
	( let
	    val (op_opt, vid, atpats) = Infix.parseFmrule(!J, atpat_list1)
	  in
	    Fmrule(op_opt, vid, atpats, COLON_ty_opt, exp)
	      @@A(atpat_list1left, expright)
	  end )

  typbind:
      tyvarseq tycon EQUALS ty AND_typbind_opt
	( TypBind(tyvarseq, tycon, ty, AND_typbind_opt)
	    @@A(tyvarseqleft, AND_typbind_optright) )

  AND_typbind_opt:
      AND typbind  ( SOME typbind )
    | (* empty *)  ( NONE )


  datbind:
      tyvarseq tycon EQUALS conbind AND_datbind_opt
	( DatBind(tyvarseq, tycon, conbind, AND_datbind_opt)
	    @@A(tyvarseqleft, AND_datbind_optright) )
  datbind0:
      tycon EQUALS conbind AND_datbind_opt
	( DatBind(Seq[]@@A(tyconleft, tyconleft),
	    tycon, conbind, AND_datbind_opt)
              @@A(tyconleft, AND_datbind_optright) )
  datbind1:
      tyvarseq1 tycon EQUALS conbind AND_datbind_opt
	( DatBind(tyvarseq1, tycon, conbind, AND_datbind_opt)
	    @@A(tyvarseq1left, AND_datbind_optright) )

  AND_datbind_opt:
      AND datbind  ( SOME datbind )
    | (* empty *)  ( NONE )


  conbind:
      OP_opt vid' OF_ty_opt BAR_conbind_opt
	( ConBind(OP_opt, vid', OF_ty_opt, BAR_conbind_opt)
	    @@A(OP_optleft, BAR_conbind_optright) )

  BAR_conbind_opt:
      BAR conbind  ( SOME conbind )
    | (* empty *)  ( NONE )

  OF_ty_opt:
      OF ty	   ( SOME ty )
    | (* empty *)  ( NONE )


  exbind:
      OP_opt vid' OF_ty_opt AND_exbind_opt
	( NEWExBind(OP_opt, vid', OF_ty_opt, AND_exbind_opt)
	    @@A(OP_optleft, AND_exbind_optright) )
    | OP_opt vid' EQUALS OP_opt longvid AND_exbind_opt
	( EQUALExBind(OP_opt1, vid', OP_opt2, longvid, AND_exbind_opt)
	    @@A(OP_opt1left, AND_exbind_optright) )

  AND_exbind_opt:
      AND exbind   ( SOME exbind )
    | (* empty *)  ( NONE )


  (* Core: Patterns [Figure 22] *)

  atpat:
      atpat'
        ( atpat' )
    | OP_opt longvid'
	( IDAtPat(OP_opt, longvid')@@A(OP_optleft, longvid'right) )

 atpat':
      UNDERBAR
	( WILDCARDAtPat@@A(UNDERBARleft, UNDERBARright) )
    | scon
	( SCONAtPat(scon)@@A(sconleft, sconright) )
    | LBRACE patrow_opt RBRACE
	( RECORDAtPat(patrow_opt)@@A(LBRACEleft, RBRACEright) )
    | LPAR RPAR
	( UNITAtPat@@A(LPARleft, RPARright) )
    | LPAR pat_COMMA_list2 RPAR
	( TUPLEAtPat(pat_COMMA_list2)@@A(LPARleft, RPARright) )
    | LBRACK pat_COMMA_list0 RBRACK
	( LISTAtPat(pat_COMMA_list0)@@A(LBRACKleft, RBRACKright))
    | LPAR pat RPAR
	( PARAtPat(pat)@@A(LPARleft, RPARright) )

  pat_COMMA_list0:
      pat_COMMA_list1            ( pat_COMMA_list1 )
    | (* empty *)                ( [] )

  pat_COMMA_list1:
      pat COMMA pat_COMMA_list1  ( pat::pat_COMMA_list1 )
    | pat                        ( pat::[] )

  pat_COMMA_list2:
      pat COMMA pat_COMMA_list1  ( pat::pat_COMMA_list1 )


  patrow:
      DOTS
	( DOTSPatRow@@A(DOTSleft, DOTSright) )
    | lab EQUALS pat COMMA_patrow_opt
	( FIELDPatRow(lab, pat, COMMA_patrow_opt)
	    @@A(lableft, COMMA_patrow_optright) )
    | vid' COLON_ty_opt AS_pat_opt COMMA_patrow_opt
	( IDPatRow(vid', COLON_ty_opt, AS_pat_opt, COMMA_patrow_opt)
	    @@A(vid'left, COMMA_patrow_optright))

  COMMA_patrow_opt:
      COMMA patrow  ( SOME patrow )
    | (* empty *)   ( NONE )

  COLON_ty_opt:
      COLON ty      ( SOME ty )
    | (* empty *)   ( NONE )

  AS_pat_opt:
      AS pat        ( SOME pat )
    | (* empty *)   ( NONE )

  patrow_opt:
      patrow        ( SOME patrow )
    | (* empty *)   ( NONE )


  pat:
      atpat
	( Infix.parsePat(!J, [atpat]) )
    | atpat_list2
	( Infix.parsePat(!J, atpat_list2) )
    (*pat vid pat
	( included above... ) *)
    (* Split the following cases to avoid conflicts. *)
    | atpat' COLON_ty_list1
	( let val pat = Infix.parsePat(!J, [atpat'])
	  in typedPat(pat, COLON_ty_list1) end )
    | atpat_list2 COLON_ty_list1
	( let val pat = Infix.parsePat(!J, atpat_list2)
	  in typedPat(pat, COLON_ty_list1) end )
    (* Split the following cases to avoid conflicts. *)
    | OP_opt vid' COLON_ty_list1
	( let
	    val longvid = LongVId.fromId(A.syntax vid')@@A(vid'left, vid'right)
	    val atpat   = IDAtPat(OP_opt, longvid)@@A(OP_optleft, vid'right)
	    val pat     = Infix.parsePat(!J, [atpat])
	  in typedPat(pat, COLON_ty_list1) end )
    | OP_opt LONGID COLON_ty_list1
	( let
	    val longvid =
	        LongVId.implode(toLongId VId.fromString LONGID)
	          @@A(LONGIDleft, LONGIDright)
	    val atpat   = IDAtPat(OP_opt, longvid)@@A(OP_optleft, LONGIDright)
	    val pat     = Infix.parsePat(!J, [atpat])
	  in typedPat(pat, COLON_ty_list1) end )
    | OP_opt vid' COLON_ty_opt AS pat
	( let
	    val longvid = LongVId.fromId(A.syntax vid')@@A(vid'left, vid'right)
	    val atpat   = IDAtPat(OP_opt, longvid)@@A(OP_optleft, vid'right)
	  in
	    Infix.parsePat(!J, [atpat]);
	    ASPat(OP_opt, vid', COLON_ty_opt, pat)@@A(OP_optleft, patright)
	  end )

  atpat_list1:
      atpat atpat_list1  ( atpat::atpat_list1 )
    | atpat		 ( atpat::[] )

  atpat_list2:
      atpat atpat_list1  ( atpat::atpat_list1 )

  COLON_ty_list1:
      COLON ty COLON_ty_list1  ( ty::COLON_ty_list1 )
    | COLON ty		       ( ty::[] )


  (* Core: Type expressions [Figure 23] *)

  ty:
      tupty
	( tupty )
    | tupty ARROW ty
	( ARROWTy(tupty, ty)@@A(tuptyleft, tyright) )

  tupty:
      ty_STAR_list
	( TUPLETy(ty_STAR_list)@@A(ty_STAR_listleft, ty_STAR_listright) )

  ty_STAR_list:
      consty STAR ty_STAR_list	( consty::ty_STAR_list )
    | consty	 		( consty::[] )	  

  consty:
      atty
	( atty )
    | tyseq longtycon
	( CONTy(tyseq, longtycon)@@A(tyseqleft, longtyconright) )

  atty:
      tyvar
	( VARTy(tyvar)@@A(tyvarleft, tyvarright) )
    | LBRACE tyrow_opt RBRACE
	( RECORDTy(tyrow_opt)@@A(LBRACEleft, RBRACEright) )
    | LPAR ty RPAR
	( PARTy(ty)@@A(LPARleft, RPARright) )


  tyrow:
      lab COLON ty COMMA_tyrow_opt
	( TyRow(lab, ty, COMMA_tyrow_opt)@@A(lableft, COMMA_tyrow_optright) )

  COMMA_tyrow_opt:
      COMMA tyrow  ( SOME tyrow )
    | (* empty *)  ( NONE )

  tyrow_opt:
      tyrow	   ( SOME tyrow )
    | (* empty *)  ( NONE )


  (* Core: Sequences [Appendix B, 2nd bullet] *)

  tyseq:
      consty
	( Seq[consty]@@A(constyleft, constyright) )
    | (* empty *)
	( Seq[]@@A(defaultPos, defaultPos) )
    | LPAR ty_COMMA_list2 RPAR
	( Seq(ty_COMMA_list2)@@A(LPARleft, RPARright) )

  ty_COMMA_list2:
      ty COMMA ty_COMMA_list2  ( ty::ty_COMMA_list2 )
    | ty COMMA ty	       ( [ty1, ty2] )


  tyvarseq:
      tyvarseq1	   ( tyvarseq1 )
    | (* empty *)  ( Seq[]@@A(defaultPos, defaultPos) )

  tyvarseq1:
      tyvar
	( Seq[tyvar]@@A(tyvarleft, tyvarright) )
    | LPAR tyvar_COMMA_list1 RPAR
	( Seq(tyvar_COMMA_list1)@@A(LPARleft, RPARright))

  tyvar_COMMA_list1:
      tyvar COMMA tyvar_COMMA_list1  ( tyvar::tyvar_COMMA_list1 )
    | tyvar			     ( tyvar::[] )


  (* Modules: Structures [Figures 6 and 18] *)

  strexp:
      strexp'
	( strexp' )
    | strexp COLON sigexp
	( COLONStrExp(strexp, sigexp)@@A(strexpleft, sigexpright) )
    | strexp SEAL sigexp
	( SEALStrExp(strexp, sigexp)@@A(strexpleft, sigexpright))

  strexp':
      STRUCT pushInfix strdec popInfix END
	( STRUCTStrExp(strdec)@@A(STRUCTleft, ENDright) )
    | longstrid
	( IDStrExp(longstrid)@@A(longstridleft, longstridright) )
    | funid LPAR strexp RPAR
	( APPStrExp(funid, strexp)@@A(funidleft, RPARright) )
    | funid LPAR strdec RPAR
	( APPDECStrExp(funid, strdec)@@A(funidleft, RPARright) )
    | LET pushInfix strdec IN strexp popInfix END
	( LETStrExp(strdec, strexp)@@A(LETleft, ENDright) )


  strdec:
      strdec1	   ( strdec1 )
    | (* empty *)  ( EMPTYStrDec@@A(defaultPos, defaultPos) )

  strdec1:
      strdec1'
	( strdec1' )
    | strdec1 strdec1 %prec SEMICOLON
	( SEQStrDec(strdec11, strdec12)@@A(strdec11left, strdec12right) )
    | SEMICOLON
	( SEQStrDec(
	    EMPTYStrDec@@A(SEMICOLONleft, SEMICOLONleft),
	    EMPTYStrDec@@A(SEMICOLONright, SEMICOLONright)
	  )@@A(SEMICOLONleft, SEMICOLONright) )

  strdec1':
      dec1'
	( DECStrDec(dec1')@@A(dec1'left, dec1'right) )
    | STRUCTURE strbind
	( STRUCTUREStrDec(strbind)@@A(STRUCTUREleft, strbindright) )
    | LOCAL pushInfix strdec IN pushLocalInfix strdec popLocalInfix END
	( LOCALStrDec(strdec1, strdec2)@@A(LOCALleft, ENDright) )


  strbind:
      strid EQUALS strexp__AND_strbind_opt
	( PLAINStrBind(strid,
	    #1 strexp__AND_strbind_opt, #2 strexp__AND_strbind_opt
	  )@@A(stridleft, strexp__AND_strbind_optright) )
    | strid COLON sigexp EQUALS strexp__AND_strbind_opt
	( COLONStrBind(strid, sigexp,
	    #1 strexp__AND_strbind_opt, #2 strexp__AND_strbind_opt
	  )@@A(stridleft, strexp__AND_strbind_optright) )
    | strid SEAL sigexp EQUALS strexp__AND_strbind_opt
	( SEALStrBind(strid, sigexp,
	    #1 strexp__AND_strbind_opt, #2 strexp__AND_strbind_opt
	  )@@A(stridleft, strexp__AND_strbind_optright) )

  AND_strbind_opt:
      AND strbind  ( SOME strbind )
    | (* empty *)  ( NONE )

  strexp__AND_strbind_opt:
      strexp' AND_strbind_opt
	( (strexp', AND_strbind_opt) )
    | strexp COLON sigexp__AND_strbind_opt
	( ( COLONStrExp(strexp, #1 sigexp__AND_strbind_opt)
	      @@A(strexpleft, sigexp__AND_strbind_optright),
	    #2 sigexp__AND_strbind_opt ) )
    | strexp SEAL sigexp__AND_strbind_opt
	( ( SEALStrExp(strexp, #1 sigexp__AND_strbind_opt)
	      @@A(strexpleft, sigexp__AND_strbind_optright),
	    #2 sigexp__AND_strbind_opt ) )

  sigexp__AND_strbind_opt:
      sigexp' AND_strbind_opt
	( (sigexp', AND_strbind_opt) )
    | sigexp WHERE tyreadesc__AND_strbind_opt
	( ( WHERETYPEMULTISigExp(sigexp, #1 tyreadesc__AND_strbind_opt)
	      @@A(sigexpleft, tyreadesc__AND_strbind_optright),
	    #2 tyreadesc__AND_strbind_opt ) )

  tyreadesc__AND_strbind_opt:
      TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt__AND_strbind_opt
	( ( TyReaDesc(tyvarseq, longtycon, ty,
	      #1 AND_tyreadesc_opt__AND_strbind_opt
	    )@@A(TYPEleft, AND_tyreadesc_opt__AND_strbind_optright),
	    #2 AND_tyreadesc_opt__AND_strbind_opt ) )

  AND_tyreadesc_opt__AND_strbind_opt:
      AND_strbind_opt
	( (NONE, AND_strbind_opt) )
    | AND tyreadesc__AND_strbind_opt
	( (SOME(#1 tyreadesc__AND_strbind_opt), #2 tyreadesc__AND_strbind_opt) )


  (* Modules: Signatures [Figures 6 and 19] *)

  sigexp:
      sigexp'
	( sigexp' )
    | sigexp WHERE tyreadesc
	( WHERETYPEMULTISigExp(sigexp, tyreadesc)
	    @@A(sigexpleft, tyreadescright) )

  sigexp':
      SIG spec END
	( SIGSigExp(spec)@@A(SIGleft, ENDright) )
    | sigid
	( IDSigExp(sigid)@@A(sigidleft, sigidright) )


  sigdec:
      SIGNATURE sigbind
	( SigDec(sigbind)@@A(SIGNATUREleft, sigbindright) )


  sigbind:
      sigid EQUALS sigexp__AND_sigbind_opt
	( SigBind(sigid,
	    #1 sigexp__AND_sigbind_opt, #2 sigexp__AND_sigbind_opt
	  )@@A(sigidleft, sigexp__AND_sigbind_optright) )

  AND_sigbind_opt:
      AND sigbind  ( SOME sigbind )
    | (* empty *)  ( NONE )

  sigexp__AND_sigbind_opt:
      sigexp' AND_sigbind_opt
	( (sigexp', AND_sigbind_opt) )
    | sigexp WHERE tyreadesc__AND_sigbind_opt
	( ( WHERETYPEMULTISigExp(sigexp, #1 tyreadesc__AND_sigbind_opt)
	      @@A(sigexpleft, tyreadesc__AND_sigbind_optright),
	    #2 tyreadesc__AND_sigbind_opt ) )

  tyreadesc__AND_sigbind_opt:
      TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt__AND_sigbind_opt
	( ( TyReaDesc(tyvarseq, longtycon, ty,
	      #1 AND_tyreadesc_opt__AND_sigbind_opt
	    )@@A(TYPEleft, AND_tyreadesc_opt__AND_sigbind_optright),
	    #2 AND_tyreadesc_opt__AND_sigbind_opt ) )

  AND_tyreadesc_opt__AND_sigbind_opt:
      AND_sigbind_opt
	( (NONE, AND_sigbind_opt) )
    | AND tyreadesc__AND_sigbind_opt
	( (SOME(#1 tyreadesc__AND_sigbind_opt), #2 tyreadesc__AND_sigbind_opt) )


  tyreadesc:
     TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt
	( TyReaDesc(tyvarseq, longtycon, ty, AND_tyreadesc_opt)
	    @@A(TYPEleft, AND_tyreadesc_optright) )

  AND_tyreadesc_opt:
      AND tyreadesc  ( SOME tyreadesc )
    | (* empty *)    ( NONE )


  (* Modules: Specifications [Figures 7 and 19] *)

  spec:
      spec1	   ( spec1 )
    | (* empty *)  ( EMPTYSpec@@A(defaultPos, defaultPos) )

  spec1:
      spec1''
	( spec1'' )
    | spec1 spec1' %prec SEMICOLON
	( SEQSpec(spec1, spec1')@@A(spec1left, spec1'right) )
    | SEMICOLON
	( SEQSpec(
	    EMPTYSpec@@A(SEMICOLONleft, SEMICOLONleft),
	    EMPTYSpec@@A(SEMICOLONright, SEMICOLONright)
	  )@@A(SEMICOLONleft, SEMICOLONright) )
    | SHARING TYPE longtycon_EQUALS_list2
	( SHARINGTYPESpec(
	    EMPTYSpec@@A(SHARINGleft, SHARINGleft), longtycon_EQUALS_list2
	  )@@A(SHARINGleft, longtycon_EQUALS_list2right) )
    | spec1 SHARING TYPE longtycon_EQUALS_list2
	( SHARINGTYPESpec(spec1, longtycon_EQUALS_list2)
	    @@A(spec1left, longtycon_EQUALS_list2right) )
    | SHARING longstrid_EQUALS_list2
	( SHARINGSpec(
	    EMPTYSpec@@A(SHARINGleft, SHARINGleft), longstrid_EQUALS_list2
	  )@@A(SHARINGleft, longstrid_EQUALS_list2right) )
    | spec1 SHARING longstrid_EQUALS_list2
	( SHARINGSpec(spec1, longstrid_EQUALS_list2)
	    @@A(spec1left, longstrid_EQUALS_list2right) )

  spec1':
      spec1''
	( spec1'' )
    | spec1' spec1' %prec SEMICOLON
	( SEQSpec(spec1'1, spec1'2)@@A(spec1'1left, spec1'2right) )
    | SEMICOLON
	( SEQSpec(
	    EMPTYSpec@@A(SEMICOLONleft, SEMICOLONleft),
	    EMPTYSpec@@A(SEMICOLONright, SEMICOLONright)
	  )@@A(SEMICOLONleft, SEMICOLONright) )

  spec1'':
      VAL valdesc
	( VALSpec(valdesc)@@A(VALleft, valdescright) )
    | TYPE typdesc
	( TYPESpec(typdesc)@@A(TYPEleft, typdescright) )
    | EQTYPE typdesc
	( EQTYPESpec(typdesc)@@A(EQTYPEleft, typdescright) )
    | TYPE syndesc
	( SYNSpec(syndesc)@@A(TYPEleft, syndescright) )
    | DATATYPE datdesc0
	( DATATYPESpec(datdesc0)@@A(DATATYPEleft, datdesc0right) )
    | DATATYPE datdesc1
	( DATATYPESpec(datdesc1)@@A(DATATYPEleft, datdesc1right) )
    | DATATYPE tycon EQUALS DATATYPE longtycon
	( DATATYPE2Spec(tycon, longtycon)@@A(DATATYPEleft, longtyconright) )
    | EXCEPTION exdesc
	( EXCEPTIONSpec(exdesc)@@A(EXCEPTIONleft, exdescright) )
    | STRUCTURE strdesc
	( STRUCTURESpec(strdesc)@@A(STRUCTUREleft, strdescright))
    | INCLUDE sigexp
	( INCLUDESpec(sigexp)@@A(INCLUDEleft, sigexpright) )
    | INCLUDE sigid_list2
	( INCLUDEMULTISpec(sigid_list2)@@A(INCLUDEleft, sigid_list2right) )

  sigid_list2:
      sigid sigid_list2  ( sigid::sigid_list2 )
    | sigid sigid	 ( sigid1::sigid2::[] )

  longtycon_EQUALS_list1:
      longtycon EQUALS longtycon_EQUALS_list1
	( longtycon::longtycon_EQUALS_list1 )
    | longtycon
	( longtycon::[] )

  longtycon_EQUALS_list2:
      longtycon EQUALS longtycon_EQUALS_list1
	( longtycon::longtycon_EQUALS_list1 )

  longstrid_EQUALS_list1:
      longstrid EQUALS longstrid_EQUALS_list1
	( longstrid::longstrid_EQUALS_list1 )
    | longstrid
	( longstrid::[] )

  longstrid_EQUALS_list2:
      longstrid EQUALS longstrid_EQUALS_list1
	( longstrid::longstrid_EQUALS_list1 )


  (* Modules: Descriptions [Figures 7 and 19] *)

  valdesc:
      vid' COLON ty AND_valdesc_opt
	( ValDesc(vid', ty, AND_valdesc_opt)
	    @@A(vid'left, AND_valdesc_optright) )

  AND_valdesc_opt:
      AND valdesc  ( SOME valdesc )
    | (* empty *)  ( NONE )


  typdesc:
      tyvarseq tycon AND_typdesc_opt
	( TypDesc(tyvarseq, tycon, AND_typdesc_opt)
	    @@A(tyvarseqleft, AND_typdesc_optright) )

  AND_typdesc_opt:
      AND typdesc  ( SOME typdesc )
    | (* empty *)  ( NONE )


  syndesc:
      tyvarseq tycon EQUALS ty AND_syndesc_opt
	( SynDesc(tyvarseq, tycon, ty, AND_syndesc_opt)
	    @@A(tyvarseqleft, AND_syndesc_optright) )

  AND_syndesc_opt:
      AND syndesc  ( SOME syndesc )
    | (* empty *)  ( NONE )


  datdesc:
      tyvarseq tycon EQUALS condesc AND_datdesc_opt
	( DatDesc(tyvarseq, tycon, condesc, AND_datdesc_opt)
	    @@A(tyvarseqleft, AND_datdesc_optright) )

  datdesc0:
      tycon EQUALS condesc AND_datdesc_opt
	( DatDesc(Seq[]@@A(tyconleft, tyconleft),
	    tycon, condesc, AND_datdesc_opt
	  )@@A(tyconleft, AND_datdesc_optright) )

  datdesc1:
      tyvarseq1 tycon EQUALS condesc AND_datdesc_opt
	( DatDesc(tyvarseq1, tycon, condesc, AND_datdesc_opt)
	    @@A(tyvarseq1left, AND_datdesc_optright) )

  AND_datdesc_opt:
      AND datdesc  ( SOME datdesc )
    | (* empty *)  ( NONE )


  condesc:
      vid' OF_ty_opt BAR_condesc_opt
	( ConDesc(vid', OF_ty_opt, BAR_condesc_opt)
	    @@A(vid'left, BAR_condesc_optright) )

  BAR_condesc_opt:
      BAR condesc  ( SOME condesc )
    | (* empty *)  ( NONE )


  exdesc:
      vid' OF_ty_opt AND_exdesc_opt
	( ExDesc(vid', OF_ty_opt, AND_exdesc_opt)
	    @@A(vid'left, AND_exdesc_optright))

  AND_exdesc_opt:
      AND exdesc  ( SOME exdesc )
    | (* empty *)  ( NONE )


  strdesc:
      strid COLON sigexp__AND_strdesc_opt
	( StrDesc(strid, #1 sigexp__AND_strdesc_opt, #2 sigexp__AND_strdesc_opt)
	    @@A(stridleft, sigexp__AND_strdesc_optright) )

  AND_strdesc_opt:
      AND strdesc  ( SOME strdesc )
    | (* empty *)  ( NONE )

  sigexp__AND_strdesc_opt:
      sigexp' AND_strdesc_opt
	( (sigexp', AND_strdesc_opt) )
    | sigexp WHERE tyreadesc__AND_strdesc_opt
	( ( WHERETYPEMULTISigExp(sigexp, #1 tyreadesc__AND_strdesc_opt)
	      @@A(sigexpleft, tyreadesc__AND_strdesc_optright),
	    #2 tyreadesc__AND_strdesc_opt ) )

  tyreadesc__AND_strdesc_opt:
      TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt__AND_strdesc_opt
	( ( TyReaDesc(tyvarseq, longtycon, ty,
	      #1 AND_tyreadesc_opt__AND_strdesc_opt
	    )@@A(TYPEleft, AND_tyreadesc_opt__AND_strdesc_optright),
	    #2 AND_tyreadesc_opt__AND_strdesc_opt ) )

 AND_tyreadesc_opt__AND_strdesc_opt:
      AND_strdesc_opt
	( (NONE, AND_strdesc_opt) )
    | AND tyreadesc__AND_strdesc_opt
	( (SOME(#1 tyreadesc__AND_strdesc_opt), #2 tyreadesc__AND_strdesc_opt) )


  (* Modules: Functors [Figures 8 and 18] *)

  fundec:
      FUNCTOR funbind
	( FunDec(funbind)@@A(FUNCTORleft, funbindright) )

  funbind:
      funid LPAR strid COLON sigexp RPAR EQUALS strexp__AND_funbind_opt
	( PLAINFunBind(funid, strid, sigexp,
	    #1 strexp__AND_funbind_opt, #2 strexp__AND_funbind_opt
	  )@@A(funidleft, strexp__AND_funbind_optright) )
    | funid LPAR strid COLON sigexp RPAR COLON sigexp EQUALS
      strexp__AND_funbind_opt
	( COLONFunBind(funid, strid, sigexp1, sigexp2,
            #1 strexp__AND_funbind_opt, #2 strexp__AND_funbind_opt
	  )@@A(funidleft, strexp__AND_funbind_optright) )
    | funid LPAR strid COLON sigexp RPAR SEAL sigexp EQUALS
      strexp__AND_funbind_opt
	( SEALFunBind(funid, strid, sigexp1, sigexp2,
	    #1 strexp__AND_funbind_opt, #2 strexp__AND_funbind_opt
	  )@@A(funidleft, strexp__AND_funbind_optright) )
    | funid LPAR spec RPAR EQUALS strexp__AND_funbind_opt
	( SPECFunBind(funid, spec,
	    #1 strexp__AND_funbind_opt, #2 strexp__AND_funbind_opt
	  )@@A(funidleft, strexp__AND_funbind_optright) )
    | funid LPAR spec RPAR COLON sigexp EQUALS strexp__AND_funbind_opt
	( COLONSPECFunBind(funid, spec, sigexp,
	    #1 strexp__AND_funbind_opt, #2 strexp__AND_funbind_opt
	  )@@A(funidleft, strexp__AND_funbind_optright) )
    | funid LPAR spec RPAR SEAL sigexp EQUALS strexp__AND_funbind_opt
	( SEALSPECFunBind(funid, spec, sigexp,
	    #1 strexp__AND_funbind_opt, #2 strexp__AND_funbind_opt
	  )@@A(funidleft, strexp__AND_funbind_optright) )

  AND_funbind_opt:
      AND funbind  ( SOME funbind )
    | (* empty *)  ( NONE )

  strexp__AND_funbind_opt:
      strexp' AND_funbind_opt
	( (strexp', AND_funbind_opt) )
    | strexp COLON sigexp__AND_funbind_opt
	( ( COLONStrExp(strexp, #1 sigexp__AND_funbind_opt)
	      @@A(strexpleft, sigexp__AND_funbind_optright),
	    #2 sigexp__AND_funbind_opt ) )
    | strexp SEAL sigexp__AND_funbind_opt
	( ( SEALStrExp(strexp, #1 sigexp__AND_funbind_opt)
	      @@A(strexpleft, sigexp__AND_funbind_optright),
	    #2 sigexp__AND_funbind_opt ) )

  sigexp__AND_funbind_opt:
      sigexp' AND_funbind_opt
	( (sigexp', AND_funbind_opt) )
    | sigexp WHERE tyreadesc__AND_funbind_opt
	( ( WHERETYPEMULTISigExp(sigexp, #1 tyreadesc__AND_funbind_opt)
	      @@A(sigexpleft, tyreadesc__AND_funbind_optright),
	    #2 tyreadesc__AND_funbind_opt ) )

  tyreadesc__AND_funbind_opt:
      TYPE tyvarseq longtycon EQUALS ty AND_tyreadesc_opt__AND_funbind_opt
	( ( TyReaDesc(tyvarseq, longtycon, ty,
	      #1 AND_tyreadesc_opt__AND_funbind_opt
	    )@@A(TYPEleft, AND_tyreadesc_opt__AND_funbind_optright),
	    #2 AND_tyreadesc_opt__AND_funbind_opt ) )

  AND_tyreadesc_opt__AND_funbind_opt:
      AND_funbind_opt
	( (NONE, AND_funbind_opt) )
    | AND tyreadesc__AND_funbind_opt
	( (SOME(#1 tyreadesc__AND_funbind_opt), #2 tyreadesc__AND_funbind_opt) )


  (* Modules: Top-level Declarations [Figure 8] *)

  topdec:
      topdec1
	( topdec1 )
    | (* empty *)
	( STRDECTopDec(EMPTYStrDec@@A(defaultPos, defaultPos), NONE)
	    @@A(defaultPos, defaultPos) )

  topdec1:
      strdec1' topdec_opt
	( STRDECTopDec(strdec1', topdec_opt)@@A(strdec1'left, topdec_optright) )
    | sigdec topdec_opt
	( SIGDECTopDec(sigdec, topdec_opt)@@A(sigdecleft, topdec_optright) )
    | fundec topdec_opt
	( FUNDECTopDec(fundec, topdec_opt)@@A(fundecleft, topdec_optright) )
    
  topdec_opt:
      topdec1      ( SOME topdec1 )
    | (* empty *)  ( NONE )


  (* Programs [Section 8 and Figure 18] *)

  program:
      initInfix program'  ( (program', !J) )

  program':
      topdec SEMICOLON program_opt
	( TOPDECProgram(topdec, program_opt)@@A(topdecleft, SEMICOLONright))
    | exp SEMICOLON program_opt
	( EXPProgram(exp, program_opt)@@A(expleft, SEMICOLONright))

  program_opt:
      program'     ( SOME program' )
    | (* empty *)  ( NONE )
